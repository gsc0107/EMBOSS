/* @source sigplot application
**
** Reads a signature hits file and validation file and generates gnuplot
** data files of signature performance
**
** @author: Copyright (C) Matt Blades (mblades@hgmp.mrc.ac.uk)
** @author: Copyright (C) Jon Ison (jison@hgmp.mrc.ac.uk)
** @@
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
** 02111-1307, USA.
**

*******************************************************************************
**  Application name
**  sigplot
** 
**  
**   
**  Summary
**  Reads a signature hits file and validation file and generates gnuplot
**  data files of signature performance.
**  
**  
**  
**  Input and Output
**  sigplot reads a directory containing signature hits files; each must contain
**  the results of search of a discriminator for a scop family against a 
**  sequence database.   sigplot also reads a scop validation file and generates
**  gnuplot data files for graphs illustrating the diagnostic performance of the
**  discriminator. 
**  sigplot runs in one of two modes either (i) "do not merge mode" or (ii) 
**  "merge mode". In "do not merge mode", ROC analysis is performed on each 
**  signature hits file individually; a graph is generated containing a ROC plot
**  for each signature hits file.  In "merge mode" the lists of hits in the 
**  signature hits files are merged and ROC analysis is performed on the whole;
**  a single plot on the graph is given.
**  Optionally, sigplot will read a scop family alignment file (from which 
**  the signature was derived) and a signature alignment file and write a file
**  containing matrices of residue similarity data (see below). The names of
**  the signature hits file, validation file, scop family alignment file and
**  signature alignment file are specified by the user.  sigplot generates 
**  various data files for use by gnuplot (see 'Notes' below).
** 
**  
**   
**  Sister applications
**  A 'signature hits file' contains the results of a search of a discriminating
**  element (one of protein signature, hidden Markov model, simple frequency 
**  matrix, Gribskov profile or Hennikoff profile) against a sequence database.
**  The files are generated by sigscan and modelscan.
**  A 'signature alignment file' contains the alignments resulting from a search
**  of a sparse protein signature against a sequence database.  The files are 
**  generated by sigscan.
**  A 'scop validation file' contains sequence relatives (hits) for each of a
**  number of different scop families, superfamilies and folds.  The file 
**  contains the collated results from psiblast searches of a sequence database
**  for the indvidual scop families; hits of unambiguous family assignment are
**  listed under their respective family, otherwise a hit is assigned as 
**  relatives to a scop superfamily or fold instead.  The scop validation file
**  is generated by seqnr and is in embl-like format.
**  A 'scop family alignment file' contains a sequence alignment of domains 
**  belonging to the same scop family.  The file is in embl-like format and is
**  annotated with records describing the SCOP classification of the family.  A
**  scop family alignment file generatd by scopalign will contain a structure-
**  based sequence alignment of domains of known structure only.  Such 
**  alignments can be extended with sequence relatives (of unknown structure)
**  to the family in question by using seqalign.
**  
**  
**  
**  Notes
**  If a signature hits file called sig.hits was read, gnuplot data files called 
**  sig.testhits_red.dat, sig.testhits_non.dat, sig.testhits_cross.dat, 
**  sig.testhits_false.dat, sig.testhits_unknown.dat, sig.testhits_sensi.dat, 
**  sig.testhits_true.dat and  sig.testhits_speci.dat would be generated. 
**  gnuplot driver files called sig.testhits.dat and sig.testhits.dat2 would 
**  also be generated and can be visualised by loading them into gnuplot (type,
**  e.g. load 'sig.testhits.dat' from the gnuplot command line.
**  
**  
**  
**  Known bugs & warnings
**  gnuplot must be started in the same directory as the gnuplot data files.
**
**  
**  
**  Description
**  This program is part of a suite of EMBOSS applications that directly or 
**  indirectly make use of the protein structure databases pdb and scop.  
**  This program is part of an experimental analysis pipeline described in an
**  accompanying document.  We provide the software in the hope that it will
**  be useful.  The applications were designed for specific research purposes
**  and may not be useful or reliable in contexts other than the described 
**  pipeline.  The development of the suite was coordinated by Jon Ison to
**  whom enquiries and bug reports should be sent (email jison@hgmp.mrc.ac.uk).
**  
**  sigplot provides interpretation and graphical display of discriminator 
**  performance.  sigplot reads a signature hits file and generates two 
**  different types of graph of discriminator performance.  The first gives 
**  number of hits versus the proportion of hits detected that are true hits (a
**  'SEED' or 'HIT'), 'CROSS', 'UNKNOWN' or 'FALSE'.  These data correspond to
**  the secondary classification of hit given in the signatures hits file (see
**  sigscan.c).  The second uses Receiver Operating Characteristic (ROC) curves
**  to display the sensitivity and specificity of the discriminating elements.
**  ROC analysis has been used for many years in clinical studies to evaluate
**  the usefulness of diagnostic tests.  It is a powerful aid to 
**  interpretation, in particular of the results of multiple discriminator 
**  scans side-by-side.  The ROC curves generated by sigplot plot sensitivity 
**  or "true positive fraction" versus (1-specificity), the "true negative 
**  fraction":
**  Sensitivity = True positives detected / total number in family
**  specificity = True positives detected / (True negatives + True positives)
**  
**  Where a 'True positives' is a hit classified as TRUE in the signature hits
**  file, 'Total number in family' is the total number of known relatives to 
**  the family taken from the SCOP validation file, and 'True Negatives' are 
**  hits classified as FALSE in the signature hits file.  The basis of ROC 
**  analysis is that every data point is classified as either positive or 
**  negative according to a particular outcome, (e.g. two sequences are 
**  homologous or not).  However, the classification scheme used in the 
**  signature hits file gives four possible classes for every hit.  Only hits
**  classified as TRUE and FALSE in the signature hits file are considered 
**  for the ROC analysis, CROSS and UNKNOWN hits are discarded.  
**  
**  The area (relative to a unit square) under a ROC curve can be calculated 
**  and used as a measure of the probability of correct classification.  For
**  example, an area of 0.88 indicates that a sequence belonging to the same
**  family as that from which the signature was derived has a probability of
**  0.88 of scoring higher than a sequence from the FALSE hits group.  In 
**  practice, this area is calculated for curves which consider a limited 
**  number of hits only, as it would be impractical to store scores for an 
**  entire sequence database.  The ROC50 score is commonly used and is 
**  defined as the area under a ROC curve plotted until 50 true negatives are
**  found.  sigplot will ploy the ROC curve and generate a ROC value for any
**  user-specified number of false hits (FALSE in the signature hits file).
**  
**  The area under the ROC curve is defined as 
**  Area = 1/nT * (Ti summed for i=1 to i=n)
**  where n is the number of false hits to consider (e.g. 50 when calculating
**  ROC50), T is the total number in family and Ti is the number of true hits
**  detected above the ith false hit (when calculating ROC50 Ti is summed from
**  i = 1 to i = 50).
**  
**  Sigplot optionally outputs matrices giving (i) the percentage sequence 
**  similarity between the seed proteins (the proteins in the scop family 
**  alignment file), and (ii) between the TRUE hits in the signature hits file
**  and the seed proteins.  This file indicates whether signatures are able to
**  detect proteins that are very distantly related to the alignment proteins
**  and also the effect (if any) of the relatedness of the seed proteins on 
**  diagnostic performance.
**  
**  
**  
**  Algorithm
**  
**  
**  
**  Usage 
**  An example of interactive use of sigplot is shown below.
**  Unix % sigplot
**  Generates data files of signature performance
**  Location of signature hits files (input) [./]: test_data
**  Extension of signature hits files [.hits]: .testhits
**  Name of seqsort validation file for input [test.all]: test_data/scop.all
**  Graph 'true' hits as proportion of redundant and non-redundant hits [Y]: y
**  Number of false hits to consider for ROC curve [50]: 
**  Generate matrix of %id between seed proteins and hits [Y]: n
**  Location of gnuplot data files (output) [./]: test_data
**  Validation file read ok
**  PROCESSING test_data/sig.testhits
**  Warning: Only 0 false hits found in hits file test_data/sig.testhits
**  
**  Graphs of signature performance were generated from signature hits files in
**  test_data with the file extension .testhits and by reference to the scop 
**  validation file test_data/scop.all.  The data for true hits were not 
**  presented separately for redundant and non-redundant hits.  A ROC curve was
**  generated from hits up to the first 50 false hits.  No matrix of sequence 
**  similarity data for the seed proteins was generated.  Data files for 
**  GNUPLOT were written to test_data
** 
**  The following command line would achieve the same result.
**  sigplot test_data  .testhits test_data/scop.all test_data -splithit N 
**  -rocval 50 -seedid N 
** 
**  
**  
**  Input file format
**  The format of the signature hits file is explained in sigscan.c.
**  The format of the scop validation is exactly the same as the scop families
**  file, described in seqsearch.c. 
**  
**  
**  
**  Output file format
**  The output files contain GNUPLOT commands or data and are not explained 
**  here.
**  
**  
**  
**  Data files
**  sigplot does not use a data file.
**  
**  
**  
**  Diagnostic error messages
**  
**  
**  
**  Authors
**  Matt Blades (mblades@hgmp.mrc.ac.uk)
**  Jon Ison (jison@hgmp.mrc.ac.uk)
**  
**  
**  
**  References
**  Please cite the authors.
**  
**  
**  
******************************************************************************/



#include "emboss.h"
#include <math.h>




typedef struct AjSScopdata
 {
    AjPStr   Class;
    AjPStr   Fold;
    AjPStr   Superfamily;
    AjPStr   Family;
    AjPStr   file_name;
    ajint    num_hits;            /* Total no. of hits */
    ajint    Sunid;
    ajint    num_true;		  /* Number of hits classified 'TRUE' */
    ajint    file_hitnum;
} AjOScopdata, *AjPScopdata;








AjBool  sigplot_CountHits(AjPFile hitsin, AjPScopdata *data, AjPInt *truehits,
			  AjPInt2d *range, AjPStr **codes, AjPInt *rank,
			  ajint	*redun, ajint *non_redun, ajint roc_val);

AjBool	sigplot_ValidatRead(AjPFile validatin, AjPScopdata *data, ajint *vali_TN,
			    ajint *vali_FN, ajint *vali_true,ajint *vali_r, 
			    ajint *vali_nr);

AjBool	sigplot_HitProportion(AjPFile hitsin, AjPScopdata *data, AjPFloat2d *prob_array,
			      AjPFloat *sensi_array, AjPFloat *speci_array, ajint vali_TN,
			      ajint vali_FN, ajint vali_true, ajint vali_r, ajint vali_nr, 
			      AjBool split_hit, float *prop, float *prop_r, float *prop_nr, 
			      ajint roc_val, float *roc_score);

AjBool  sigplot_DataWrite(AjPFile datafile, AjPFile ssdatafile, AjPScopdata data, 
			  AjPFloat2d prob_array, AjPFloat sensi_array, AjPFloat speci_array,
			  AjBool split_hit, float prop, float prop_r, float prop_nr, 
			  ajint list_num, AjPStr temp, float roc_score, AjPStr outdir);

AjBool  sigplot_SeedIdCalc(AjPList seedlist,  AjPScopalg alg, AjPFile matrixout,
			   AjPMatrixf submat, float gapopen, float gapextn); 
AjBool  sigplot_HitIdCalc(AjPList seedlist, AjPList hitlist,  AjPScopalg alg, 
			  AjPFile matrixout, AjPMatrixf submat, float gapopen, 
			  float gapextn, AjPStr **codes, AjPInt rank); 
AjBool	sigplot_AlignSeqExtract(AjPFile sigalignfile, AjPInt truehits, AjPInt2d range, 
				AjPStr **sig_seqs, AjPStr **temp_seqs, ajint num,
				ajint num_true, ajint file_hitnum); 
void sigplot_ScopdataDel(AjPScopdata *pthis);
AjPScopdata  sigplot_ScopdataNew();









/* @prog sigplot *************************************************************
**
** Signature performance plotting program
**
******************************************************************************/
int main(int argc, char **argv)
{

    AjPFile     hitsin      = NULL;      /* Signature hits input file                      */
    AjPFile     validatin   = NULL;      /* Validation input file                          */
    AjPFile     datafile    = NULL;      /* GNUPLOT class output data file                 */
    AjPFile     ssdatafile  = NULL;      /* GNUPLOT sensi/speci output data file           */
    AjPFile     sigalignfile = NULL;     /* sigscan alignment file                         */
    AjPFile     alignfile   = NULL;      /* Alignment file for input                       */
    AjPFile     matrixout   = NULL;      /* output file for id matrix                      */
    
    AjPStr     	hitdir      = NULL;      /* Location of hits files for input               */
    AjPStr      hitextn     = NULL;      /* File extension of hits files                   */	
    AjPStr     	aligndir    = NULL;      /* Location of alignment files for inp        */
    AjPStr      alignextn   = NULL;      /* File extension of alignment files          */	
    AjPStr     	outdir      = NULL;      /* Location of gnuplot data files for output      */


    ajint	vali_TN     = NULL;      /* ajint for storing validation information       */
    ajint	vali_FN     = NULL;      /* ajint for storing validation information       */
    ajint	vali_true   = NULL;      /* ajint for storing validation information       */
    ajint	vali_r   = NULL;      /* ajint for storing validation information       */
    ajint	vali_nr   = NULL;      /* ajint for storing validation information       */
    ajint	redun       = NULL;      /* ajint for storing no. of redundant hits        */
    ajint	non_redun   = NULL;      /* ajint for storing no. of non-redundant hits    */
    ajint	nseqs	    = 0;         /* No. of sequences                               */
    ajint	x	    = 0;         /* Counter                                        */
    ajint	list_num    = 0;         /* Number of nodes on list                        */
/*    ajint      	num 	    = 0;*/         /* num                                    */
    AjPInt	truehits    = NULL;      /* Array of hits that are 'TRUE'                  */
    AjPInt	rank        = NULL;      /* Array of the rank of the 'TRUE' hits           */
    AjPInt2d	range       = NULL;      /* Array of range of seq-sig matches of 'True' hits */

    AjPFloat2d  prob_array  = NULL;      /* Array for probabilities of each classification */    
    AjPFloat    sensi_array = NULL;      /* Array for specificity data                     */ 
    AjPFloat    speci_array = NULL;      /* Array for sensitivity data                     */ 
    float       gapopen     = 0;         /* Gap opening penalty                            */	
    float       gapextn     = 0;         /* Gap extension penalty                          */		 
    float	prop	    = 0.0;       /* proportion of true family memebrs detected     */
    float	prop_r	    = 0.0;       /* proportion of redundant true family memebrs detected     */
    float	prop_nr	    = 0.0;       /* proportion of non-redundant true family memebrs detected     */
    float	roc_score   = 0.0;       /* ROCx score                                     */

    AjPScopdata data        = NULL;      /* Pointer to Scopdata structure                  */
    AjPScopalg  alg         = NULL;      /* Pointer to Scopalg structure                   */

    AjBool	seedcheck   = ajFalse;   /* bool for generating seed id's                  */
    AjBool	seedid      = ajFalse;   /* bool for generating seed id's                  */
    AjBool	done        = ajFalse;   /* bool                                           */
    AjBool	split_hit   = ajFalse;   /* bool for splitting true hits                   */
    AjPMatrixf  submat      = NULL;      /* subsitiution matirx for use in seed id         */
    AjPStr      *seed_array = NULL;      /* Arrays of seqs from seed alignment             */
    AjPList     seedlist    = NULL;      /* List to hold seed sequences                    */
    AjPList     hitlist     = NULL;      /* List to hold hit sequences                     */
    AjIList 	iter        = NULL;   	 /* A list iterator                                */
    AjIList 	iter2       = NULL;   	 /* A list iterator                                */
    AjPSeq 	seed_seq    = NULL;   	 /* A sequence object to hold the constructed sequence */
    AjPSeq 	hit_seq     = NULL;   	 /* A sequence object to hold the constructed sequence */
    ajint	len	    = 0;
    ajint	roc_val	    = 0;
    
    AjPStr	*codes      = NULL;
    AjPStr	*sig_seqs   = NULL;
    AjPStr	*temp_seqs  = NULL;
    AjPStr	temp	    = NULL;
    AjPStr	hitname	    = NULL;
    AjPStr	data1	    = NULL;
    AjPStr	data2	    = NULL;
    AjPStr	mat	    = NULL;
    AjPStr	alg_temp    = NULL;
    AjPStr *mode       = NULL;		/* Mode of operation from acd*/

    
    AjPList     list        = NULL;   /* Used to hold list of names of files in a directory */
    AjPList     mrglist     = NULL;   /* Holds hits from the signature hits files */
    AjPHitlist  tmphitlist  = NULL;   
    AjPHitlist  outhitlist  = NULL;   
    ajint z=0;
    AjPStr      tmpname     =NULL;
    AjPFile     tmpfile     =NULL;
    AjPHit      tmphit      =NULL;
    ajint       tmpvali_TN=0;
    ajint       tmpvali_FN=0;
    ajint       tmpvali_true=0;
    ajint       tmpvali_r=0;
    ajint       tmpvali_nr=0;
    
    

    ajNamInit("emboss");
    ajAcdInitP("sigplot", argc, argv, "DOMAINATRIX");

    
    /* Assign variables and strings */
    seedlist  = ajListNew();
    hitlist   = ajListNew();
    list      = ajListNew();  

    hitdir    = ajStrNew();
    outdir    = ajStrNew();
    data2     = ajStrNew();
    data1     = ajStrNew();
    mat       = ajStrNew();
    temp      = ajStrNew();
    hitextn   = ajStrNew();
/*    hitname   = ajStrNew();*/
    aligndir  = ajStrNew();
    alignextn = ajStrNew();
    alg_temp  = ajStrNew();

    /* GET VALUES FROM ACD */
    mode        = ajAcdGetList("mode");
    hitdir      = ajAcdGetString("hitdir");
    hitextn     = ajAcdGetString("hitextn");
    validatin   = ajAcdGetInfile("validatin");
    split_hit   = ajAcdGetBool("splithit");
    seedid      = ajAcdGetBool("seedid");
    roc_val	= ajAcdGetInt("rocval");
    outdir      = ajAcdGetString("outdir");

    /* Check hits and alignment directories */
    if(!ajFileDir(&hitdir))
        ajFatal("Could not open hits directory");

    if(!ajFileDir(&outdir))
        ajFatal("Could not open gnuplot data directory");
    

    /* Create list of files in hits directory */
    ajStrAssC(&temp, "*");      
    if((ajStrChar(hitextn, 0)=='.'))
        ajStrApp(&temp, hitextn);    
    else
    {
        ajStrAppC(&temp, ".");    
        ajStrApp(&temp, hitextn);    
    }

    /* Scan directory for files */
    ajFileScan(hitdir,temp,&list,ajFalse,ajFalse,NULL,NULL,ajFalse,NULL);

    list_num = ajListstrLength(list);
/*    printf("List length = %d\n", list_num); */
    

    /* if id matrix required then get parameters */
    if(seedid == ajTrue)
    {
	printf("............\n");
	fflush(stdout);
	
	
	alignfile    = ajAcdGetInfile("alignfile");
	submat       = ajAcdGetMatrixf("submat");
	gapopen      = ajAcdGetFloat("gapopen");
	gapextn      = ajAcdGetFloat("gapextn");
	aligndir    = ajAcdGetString("aligndir");
	alignextn   = ajAcdGetString("alignextn");
    }
    

    /* Check validation file */
    if(!validatin)
	ajFatal("Could not open validation file\n");
    else
	ajFmtPrint("Validation file read ok\n");
    

    /* Check seed id requirements */
    if(seedid == ajTrue)
    {
	if(!ajFileDir(&aligndir))
	    ajFatal("Could not open alignment directory");
	else
	    ajFmtPrint("Alignment file read ok\n");
    }

    

    if(ajStrChar(*mode,0)=='2')
    {
	/* Create merged list and hitlist for holding merged results*/
	mrglist = ajListNew();
	outhitlist = ajXyzHitlistNew(0);
	

	/* Read each signature hits file in turn */
	while(ajListPop(list,(void **)&hitname))
	{
	    /* Open hits file*/
	    if((hitsin = ajFileNewIn(hitname)) == NULL)
		ajFatal("Could not open for reading %S", hitname);
	    
	    /* Read hits file ... Get SCOP info.
	                      ... push hits onto merged list */
	    tmphitlist = ajXyzSignatureHitsRead(hitsin);
	    for(z=0;z<tmphitlist->N;z++)
		ajListPush(mrglist, tmphitlist->hits[z]);
	    tmphitlist->N=0;
	    ajXyzHitlistDel(&tmphitlist);

	    /* Write Scopdata object */
	    data = sigplot_ScopdataNew();
	    ajStrAssS(&data->Class, tmphitlist->Class);
	    ajStrAssS(&data->Fold, tmphitlist->Fold);
	    ajStrAssS(&data->Superfamily, tmphitlist->Superfamily);
	    ajStrAssS(&data->Family, tmphitlist->Family);
	    data->Sunid = tmphitlist->Sunid_Family;
	    
	    /* Close hits file */
	    ajFileClose(&hitsin);

	    
	    /* Call sigplot_ValidatRead to count number of hits for validation */
	    sigplot_ValidatRead(validatin, &data, &tmpvali_TN, &tmpvali_FN, 
				&tmpvali_true,&tmpvali_r, &tmpvali_nr);
	    sigplot_ScopdataDel(&data);
	    

	    /* Ammend total number of hits for validation */
	    vali_TN+=tmpvali_TN;
	    vali_FN+=tmpvali_FN;
	    vali_true+=tmpvali_true;
	    vali_r+=tmpvali_r;
	    vali_nr+=tmpvali_nr;
	    

	    /* Copy classification data to output hitlist, this will 
	       contain the classification data of the last individual
	       signature hits file read */
	    ajStrAssS(&outhitlist->Class, tmphitlist->Class);
	    ajStrAssS(&outhitlist->Fold, tmphitlist->Fold);
	    ajStrAssS(&outhitlist->Superfamily, tmphitlist->Superfamily);
	    ajStrAssS(&outhitlist->Family, tmphitlist->Family);
	    outhitlist->Sunid_Family = tmphitlist->Sunid_Family;
	    
	    ajStrDel(&hitname);
	}	

	/* Sort merged list of hits and create Hitlist for printing merged signature hits file */
	ajListSort(mrglist, ajXyzCompScore);
	outhitlist->N=ajListToArray(mrglist, (void ***)&(outhitlist->hits));	
	

	/* Create temporary file */
    tmpname = ajStrNew();
    ajRandomSeed();
    ajStrAssC(&tmpname, ajFileTempName(NULL));
    
    
    /* Write & close temporary file and push its name onto list */
    tmpfile = ajFileNewOut(tmpname);
    ajXyzSignatureHitsWriteHitlist(tmpfile, outhitlist, roc_val);
    

    ajListPush(list, tmpname);
    ajStrDel(&tmpname);
    ajFileClose(&tmpfile);
    
    /* Free merged list */
    while(ajListPop(mrglist, (void **)&tmphit))
	ajXyzHitDel(&tmphit);
    ajListDel(&mrglist);
    }
    
    

    

    /* Start of main application loop                     */   
    /* Pop hits files off list one at a time and generate */
    /* data files for each in turn 			  */
    while(ajListPop(list,(void **)&hitname))
    { 
	ajFmtPrint("PROCESSING %S\n", hitname);

        /* Open hits file*/
        if((hitsin = ajFileNewIn(hitname)) == NULL)
            ajFmtPrint("Could not open for reading %S", hitname);


	/* Open gnuplot data files                                    */
	/* take hitname and remove hitextn no. of characters from end */
	/* in order to name the two data files                        */
	len = ajStrLen(hitextn);
	ajStrClear(&temp);
	ajStrAssS(&temp, hitname);
	ajStrTrim(&temp, -len);
	len = ajStrLen(hitdir);
	ajStrTrim(&temp, len);
/*	ajFmtPrint("name = %S\n", temp); */

	/* Create gnuplot data and seq id output file names*/
	ajStrAssS(&data1, outdir);
	ajStrApp(&data1, temp);
	ajStrApp(&data1, hitextn);
	ajStrAppC(&data1, ".dat");



/*	ajFmtPrint("data1 = %S\n", data1); */

	/* Assign names to file pointers */
	datafile     = ajFileNewOut(data1);
	
	if(done == ajFalse)
	{
	    ajStrApp(&data2, temp);	
	    ajStrSub(&data2, 0, 4);
/*	    ajStrAppC(&data2, "_");*/
	    ajStrApp(&data2, hitextn);
	    ajStrAppC(&data2, ".dat2");
	    ajStrInsert(&data2, 0, outdir);


/*	    ajFmtPrint("data2 = %S\n", data2); */

	    ssdatafile   = ajFileNewOut(data2);
	    done = ajTrue;
	}
	

/*	ajFmtPrint("Calling counthits file = %S\n", ajFileGetName(hitsin)); */

	/* reset ints to zero and delete arrays ready for next file */
	/*
	printf("redun       = %d\n", redun);
	printf("non_redun   = %d\n", non_redun);
	*/
	non_redun = 0;
	redun     = 0;

	if(done == ajTrue)
	{
	    ajIntDel(&truehits);
	    ajIntDel(&rank);
	    ajInt2dDel(&range);
	    AJFREE(codes);
	}

	/* Call sigplot_CountHits                                        */	
	if(!sigplot_CountHits(hitsin, &data, &truehits, &range, &codes, &rank,
			  &redun, &non_redun, roc_val))
	{
	    /* tidy up */
	    AJFREE(seed_array);
	    AJFREE(sig_seqs);    
	    AJFREE(temp_seqs);    
	    AJFREE(codes);
	    AJFREE(data);
	    AJFREE(alg);
	

	    ajFileClose(&hitsin);
	    ajFileClose(&datafile);
	    ajFileClose(&ssdatafile);
	    ajFileClose(&validatin);
	    ajFloat2dDel(&prob_array);
	    ajFloatDel(&sensi_array);
	    ajFloatDel(&speci_array);
	    ajIntDel(&truehits);
	    ajIntDel(&rank);
	    ajInt2dDel(&range);
	    if(seedid)
		ajMatrixfDel(&submat);

	    ajListDel(&seedlist);
	    ajListDel(&hitlist);
	    ajSeqDel(&seed_seq);
	    ajSeqDel(&hit_seq);

	    ajStrDel(&hitdir);
	    ajStrDel(&outdir);
	    ajStrDel(&hitextn);
	    ajStrDel(&temp);
	    ajStrDel(&hitname);
	    ajStrDel(&data1);
	    ajStrDel(&data2);
	    ajStrDel(&mat);
	    ajStrDel(&alg_temp);

	    /* Return */
	    ajExit();
	    return 0;
	}
/*	ajFmtPrint("Number of hits in hits file = %d\n", (data)->num_hits);
	ajFmtPrint("redundant = %d, non-redundant = %d\n", redun, non_redun); */

	/* reset ints to zero */
	vali_TN   = 0;
	vali_FN   = 0;
	vali_true = 0;
	vali_r = 0;
	vali_nr = 0;
	
	/* Call sigplot_ValidatRead */
	if(ajStrChar(*mode,0)=='1')
	    sigplot_ValidatRead(validatin, &data, &vali_TN, &vali_FN, 
				&vali_true,&vali_r, &vali_nr);
	/*
	printf("vali_TN   = %d\n", vali_TN);
	printf("vali_FN   = %d\n", vali_FN);
	printf("vali_true = %d\n", vali_true);
	printf("done validatread\n");
	*/

	/* Reset arrays and ints */
	if(done == ajTrue)
	{
	    ajFloat2dDel(&prob_array);
	    ajFloatDel(&sensi_array);
	    ajFloatDel(&speci_array);
	    prop = 0.0;
	    prop_r = 0.0;
	    prop_nr = 0.0;
	}
	
	/* Call sigplot_HitProportion */
	sigplot_HitProportion(hitsin, &data, &prob_array, &sensi_array, &speci_array,
			  vali_TN, vali_FN, vali_true, vali_r, vali_nr, 
			      split_hit, &prop, &prop_r, &prop_nr, roc_val, &roc_score);
    
/*	printf("done hit proportion ROC%d = %.2f\n", roc_val, roc_score); */

	/* Call sigplot_DataWrite */
	sigplot_DataWrite(datafile, ssdatafile, data, prob_array, sensi_array, speci_array,
			  split_hit, prop, prop_r, prop_nr, list_num, temp, roc_score, outdir);
    
/*	printf("done datawrite\n");*/
   	
    
	if(seedid == ajTrue)
	{

	    if(seedcheck != ajFalse)
	    {
		seedlist  = ajListNew();
		hitlist   = ajListNew();

		mat       = ajStrNew();
		alg_temp  = ajStrNew();
		
	    }
	    


/*	    printf("\n\n\nGenerating Seedid matrix \n"); */
	    /* Get name of seq id output file */
	    ajStrAssS(&mat, outdir);
	    ajStrApp(&mat, temp);
	    ajStrApp(&mat, hitextn);
	    ajStrAppC(&mat, ".mat");


	    ajFmtPrint("mat = %S\n", mat);
	    

	    /* Assign name to file pointer */
	    if((matrixout = ajFileNewOut(mat)) == NULL)
		ajFatal("Terminal file problem");
	    

	    /*matrixout     = ajFileNewOut(mat);*/


	    /* Get name of signature alignment file */
	    ajStrAss(&alg_temp, aligndir);
	    ajStrApp(&alg_temp, temp);
	    ajStrApp(&alg_temp, alignextn);
/*	    ajFmtPrint("sigalignfile = %S\n", alg_temp); */
	    
	    /* Open signature alignment file */
	    if((sigalignfile=ajFileNewIn(alg_temp))==NULL)
	    {
		ajWarn("Could not open signature alignment file!!");
		continue;           
	    }   
/*	    ajFmtPrint("Sigalign = %S\n", ajFileGetName(sigalignfile)); */
/*	    printf("calling alignseqextract\n"); */
	    /* Call sigplot_AlignSeqExtract */
	    sigplot_AlignSeqExtract(sigalignfile, truehits, range, &sig_seqs, &temp_seqs, 
				    data->num_hits, data->num_true, data->file_hitnum); 
	    
/*	    printf("done sigplot_AlignSeqExtract\n"); */
	    /* Section for generating AjPSeq lists     */
	    /* to pass to seq id calculating functions */
	    
	    /* Reset file pointer */
            ajFileSeek(alignfile, 0, 0);


/*	    ajFmtPrint("alignfile = %S\n", ajFileGetName(alignfile)); */
	    
	    /* Read alignment file, write Scopalgn structure */ 
	    ajXyzScopalgRead(alignfile, &alg);
/*	    printf("done ajXyzScopalgRead\n"); */

	    /* Extract sequences from alignment */
	    nseqs=ajXyzScopalgGetseqs(alg, &seed_array);
	 
	    
	    /* Push seed sequences onto list */
	    for(x=0;x<nseqs;x++)
	    {
		seed_seq = ajSeqNew();	
		ajStrAssS(&seed_seq->Seq, seed_array[x]);
		ajListPushApp(seedlist, seed_seq); 
	    }

	    /* Push hit sequences onto list */
	    for(x=0;x<data->num_true;x++)
	    {
		hit_seq = ajSeqNew();	
		ajStrAssS(&hit_seq->Seq, sig_seqs[x]);
		ajListPushApp(hitlist, hit_seq); 
	    }

	    /* Call sigplot_SeedIdCalc */
	    sigplot_SeedIdCalc(seedlist, alg, matrixout, submat, gapopen, gapextn); 

/*	    printf("done sigplot_SeedIdCalc\n"); */

	    /* Call sigplot_HitIdCalc */
	    sigplot_HitIdCalc(seedlist, hitlist, alg, matrixout, submat, gapopen, gapextn,
			      &codes, rank);

/*	    printf("done sigplot_HitIdCalc\n"); */

	    /* Tidy up */

	    /* Delete string arrays and pointers */
	    for(x=0;x<alg->N;x++)
		ajStrDel(&seed_array[x]);	
	    AJFREE(seed_array);
    
	    for(x=0;x<data->num_true;x++)
		ajStrDel(&sig_seqs[x]);	
	    AJFREE(sig_seqs);    

	    for(x=0;x<data->num_hits;x++)
		ajStrDel(&temp_seqs[x]);	
	    AJFREE(temp_seqs);    


	    ajFileClose(&sigalignfile);
	    ajFileClose(&matrixout);
	    ajXyzScopalgDel(&alg);
	    alg = NULL;
	    

	    /*delete and clean up seedlist */
	    iter=ajListIter(seedlist);
	    iter2=ajListIter(hitlist);
	    while((seed_seq=(AjPSeq)ajListIterNext(iter)))
		ajSeqDel(&seed_seq);
	    while((hit_seq=(AjPSeq)ajListIterNext(iter2)))
		ajSeqDel(&hit_seq);
	    ajListIterFree(iter);
	    ajListIterFree(iter2);
	    ajListDel(&seedlist);
	    ajListDel(&hitlist);
	    ajSeqDel(&seed_seq);
	    ajSeqDel(&hit_seq);
	    ajStrDel(&mat);	    
	    ajStrDel(&alg_temp);

	    
	    /* Set seed check to AjTrue so that next time all */
	    /* deleted variable will be re-instated           */
	    seedcheck = ajTrue;
	}
	
	else if(seedid == ajFalse)
	{
	    AJFREE(seed_array);
	    AJFREE(sig_seqs);    
	    AJFREE(temp_seqs);    
	    ajListDel(&seedlist);
	    ajListDel(&hitlist);
	    ajSeqDel(&seed_seq);
	    ajSeqDel(&hit_seq);
	}
	
    }
	

    /* Tidy up the rest */
    if(ajStrChar(*mode,0)=='2')
    {
	/* Delete temporary file */
	ajSysUnlink(&tmpname);
    }
    
    
	    



    for(x=0;x<data->num_hits;x++)
	ajStrDel(&codes[x]);	
    AJFREE(codes);


    sigplot_ScopdataDel(&data);
    ajFileClose(&hitsin);
    ajFileClose(&datafile);
    ajFileClose(&ssdatafile);
    ajFileClose(&validatin);
    ajFloat2dDel(&prob_array);
    ajFloatDel(&sensi_array);
    ajFloatDel(&speci_array);
    ajIntDel(&truehits);
    ajIntDel(&rank);
    ajInt2dDel(&range);

    ajListDel(&list);

    ajStrDel(&hitdir);
    ajStrDel(&outdir);
    ajStrDel(&hitextn);
    ajStrDel(&temp);
    ajStrDel(&hitname);
    ajStrDel(&data1);
    ajStrDel(&data2);
    ajStrDel(&mat);
    ajStrDel(&aligndir);
    ajStrDel(&alignextn);
    

    /* Delete these only once at very end */
    if(seedid == ajTrue)
    {
	ajFileClose(&alignfile);
	ajMatrixfDel(&submat);
    }
    


/*    printf("Sigplot finished successfully\n"); */

    /* Return */
    ajExit();
    return 0;


}


/* @funcstatic sigplot_CountHits  *****************************************
 **
 ** Read signature hits file and count the number of hits, by reading the 
 ** HI line and storing the value for the rank of the hit.
 **
 ** @param [r] hitsin   [AjPFile]      File pointer to signature hits file
 ** @param [w] data     [AjPScopdata*] Scopdata object pointer
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
AjBool   sigplot_CountHits(AjPFile hitsin, AjPScopdata *data, AjPInt *truehits,
			   AjPInt2d *range, AjPStr **codes, AjPInt *rank,
			   ajint *redun, ajint *non_redun, ajint roc_val)
{
    
    AjPStr   line           = NULL;	/* Line of text */    
    AjPStr   name           = NULL;     /* String for file name */
    AjPStr   second         = NULL;     /* String for secondary clasification */
    AjPStr   str            = NULL;     /* String */
    AjPStr   str2           = NULL;     /* String */
    AjPStr   str3           = NULL;     /* String */
    AjPStr   str4           = NULL;     /* String */
    AjPStr   code           = NULL;     /* String */
    AjPStr   type           = NULL;     /* String */
    ajint    num_hits       = 0;        /* Variable to hold no. of hits */
    static   AjPStr class   = NULL;     /* string to hold class             */
    static   AjPStr fold    = NULL;     /* string to hold fold              */
    static   AjPStr super   = NULL;     /* string to hold super             */
    static   AjPStr family  = NULL;     /* string to hold family            */
    ajint    sunid	    = 0;
    ajint    hi_cnt	    = 0;
    ajint	x = 0;
    ajint	y = 0;
    ajint	start	    = 0;
    ajint	end	    = 0;
    ajint	true_cnt    = 0;
    ajint	temp        = 0;
    ajint 	roc_false   = 0;
    ajint	all 	    = 0;

    /* initialize strings */
    name     = ajStrNew();
    line     = ajStrNew();    
    class    = ajStrNew();
    fold     = ajStrNew();
    super    = ajStrNew();
    family   = ajStrNew();
    second   = ajStrNew();
    str      = ajStrNew();
    str2     = ajStrNew();
    str3     = ajStrNew();
    str4     = ajStrNew();
    code     = ajStrNew();
    type     = ajStrNew();
    
    
/*    ajFmtPrint("in counthits, file = %S roc_val = %d\n", ajFileGetName(hitsin), roc_val); */
    

    ajStrAssC(&str, "TRUE");
    ajStrAssC(&str2, "CROSS");
    ajStrAssC(&str3, "FALSE");
    ajStrAssC(&str4, "UNKNOWN");

    /* Check signature hits file */
    if(!hitsin)
	ajFatal("Could not open signature hits file\n");


    /* Read files once and determine num_hits         */
    /* To make assigning arrays and strings lengths   */
    /* easier later on                                */
    while(ajFileReadLine(hitsin, &line) && !ajStrPrefixC(line,"//") &&
	  (roc_false != roc_val))
    {
	if(ajStrPrefixC(line,"DE"))
	    continue;

	else if(ajStrPrefixC(line,"SI"))
	{
	    ajFmtScanS(line, "%*s %d\n", &sunid);
	}
	
	else if(ajStrPrefixC(line,"CL"))
	    {
		ajStrAssC(&class,ajStrStr(line)+3);
		ajStrClean(&class);
	    }
	else if(ajStrPrefixC(line,"FO"))
	{
	    ajStrAssC(&fold,ajStrStr(line)+3);
	    while((ajFileReadLine(hitsin,&line)))
	    {
		if(ajStrPrefixC(line,"XX"))
		    break;
		ajStrAppC(&fold,ajStrStr(line)+3);
	    }
	    ajStrClean(&fold);
	}
	else if(ajStrPrefixC(line,"SF"))
	{
	    ajStrAssC(&super,ajStrStr(line)+3);
	    while((ajFileReadLine(hitsin,&line)))
	    {
		if(ajStrPrefixC(line,"XX"))
		    break;
		ajStrAppC(&super,ajStrStr(line)+3);
	    }
	    ajStrClean(&super);
	}
	else if(ajStrPrefixC(line,"FA"))
	{
	    ajStrAssC(&family,ajStrStr(line)+3);
	    while((ajFileReadLine(hitsin,&line)))
	    {
		if(ajStrPrefixC(line,"XX"))
		    break;
		ajStrAppC(&family,ajStrStr(line)+3);
	    }
	    ajStrClean(&family);
	}
	else if(ajStrPrefixC(line,"XX"))
	    continue;

	/* Start of loop to count number of hits */
	else if(ajStrPrefixC(line,"HI")) 
	{
	    ajFmtScanS(line, "%*s %d %*s %*d %*d %S %*s %S", &num_hits, &type, &second);
	    if((ajStrMatch(second, str)) || (ajStrMatch(second, str2)))
	    {    
		/* If classificaiton = TRUE then increment redun or non_redun counters */
		if(ajStrMatch(second, str))
		{
		    if(ajStrMatchC(type, "NON_REDUNDANT"))
		    {
			(*non_redun)++;
			/*ajFmtPrint("num_hits %4d non_redun = %2d ", num_hits, *non_redun);*/
		    }
		    
		    else if(ajStrMatchC(type, "REDUNDANT"))
		    {
			(*redun)++;
			/*ajFmtPrint("num_hits %4d       redun = %2d ", num_hits, *redun);*/
		    }
		    
		    /*ajFmtPrint("type                        = %S\n", type);*/
		    true_cnt++;
		}
		
		/* If classificaiton != TRUE then increment true_cnt ONLY!! */
		else if(ajStrMatch(second, str2))
		{
		    true_cnt++;
		}
		
	    }
	    
	    /* If classification = FALSE or UNKNOWN incremenent counter and check */
	    /* roc_val has not been reached					  */
/*	    else if(ajStrMatch(second, str3) || (ajStrMatch(second, str4)))*/
	    else if(ajStrMatch(second, str3))
	    {
		/* Increment ROC false counter */
		roc_false++;
		
		if(roc_false == roc_val)
		{
		    ajFatal("Error!! roc_val reached on first hit in hits file!!!");
		}
	    }
	    

	    /* loop through HI lines */
	    /* Read in and store the rank (no. of hits) */
	    /* from the HI line */
	    while((ajFileReadLine(hitsin, &line) && !ajStrPrefixC(line,"//")) ||
		  (ajFileReadLine(hitsin, &line) && (roc_false != roc_val)))	    
	    {
		ajFmtScanS(line, "%*s %d %*s %*d %*d %S %*s %S", &num_hits, &type, &second);
		if((ajStrMatch(second, str)) || (ajStrMatch(second, str2)))
		{
		    /* If classification = TRUE then increment redun or non_redun counters */
		    if(ajStrMatch(second, str))
		    {
			if(ajStrMatchC(type, "NON_REDUNDANT"))
			{
			    (*non_redun)++;
			    /*ajFmtPrint("num_hits %4d non_redun = %2d ", num_hits, *non_redun);*/
			}
			
			else if(ajStrMatchC(type, "REDUNDANT"))
			{
			    (*redun)++;
			    /*ajFmtPrint("num_hits %4d     redun = %2d ", num_hits, *redun);*/
			}
			
			/*ajFmtPrint("type                      = %S\n", type);*/
			true_cnt++;
		    }
		    
		    /* If classificaiton != TRUE then increment true_cnt ONLY!! */
		    else if(ajStrMatch(second, str2))
		    {
			true_cnt++;
		    }
		}
		
		/* If classification = FALSE of UNKNOWN incremenent counter and check */
		/* roc_val has not been reached					  */
		/*else if(ajStrMatch(second, str3) || (ajStrMatch(second, str4)))*/
		else if(ajStrMatch(second, str3))
		{
		    /* Increment ROC false counter */
		    roc_false++;
		    
		    if(roc_false == roc_val)
		    {
			/* Position in file where 50th false hit occurs = num_hits */
			/* fill arrays now and break to end section		       */
			printf("roc_val reached at hit number %d in hits file!!!\n", num_hits);
			
			/* Check if there are any true hits, if not then no point in continuing */
			if(true_cnt == 0)
			{
/*			    printf("No true hits found!!\n"); */
			    ajWarn("There are no true hits in hits file %S........exiting sigplot!",
				   ajFileGetName(hitsin));
			    /* tidy up */
			    ajStrDel(&line);
			    ajStrDel(&name);
			    ajStrDel(&class);
			    ajStrDel(&fold);
			    ajStrDel(&super);
			    ajStrDel(&second);
			    ajStrDel(&family);
			    ajStrDel(&str);
			    ajStrDel(&str2);
			    ajStrDel(&str3);
			    ajStrDel(&str4);
			    ajStrDel(&code);
			    ajStrDel(&type);
	
			    /* return ajFalse */
			    return ajFalse;
			}
			
/*			printf("filling arrays\n"); */
			/* Assign arrays and strings */
			*truehits = ajIntNewL(num_hits);
			*rank     = ajIntNewL(true_cnt);
			*range    = ajInt2dNewL(num_hits);
			*codes    = (AjPStr *) AJCALLOC0(num_hits, sizeof(AjPStr));
			
/*			printf("filling arrays 1\n"); */
			/* Fill truehits array */
			for(x=0;x<num_hits;x++)
			    ajIntPut(truehits,x,0);
			
			/* Assign strings in codes array */
			for(x=0;x<true_cnt;x++)    
			    (*codes)[x] = ajStrNew();
			
			/* Fill range array */
			for(x=0;x<num_hits;x++)
			    for(y=0;y<2;y++)
				ajInt2dPut(range, x, y, 0);
			
			
			/* reset posinter to start of file */
			ajFileSeek(hitsin, 0, 0);
			
			
/*			printf("filling arrays 2\n");			 */
			/* read file again and fill arrays and strings */
			/*while((ajFileReadLine(hitsin, &line) && !ajStrPrefixC(line,"//")) ||
			      (ajFileReadLine(hitsin, &line) && (roc_false != roc_val)))*/
			while((ajFileReadLine(hitsin, &line) && !ajStrPrefixC(line,"//")))
			{
			    if(ajStrPrefixC(line,"DE"))
				continue;
			    else if(ajStrPrefixC(line,"CL"))
				continue;
			    else if(ajStrPrefixC(line,"XX"))
				continue;
			    else if(ajStrPrefixC(line,"FO"))
				continue;
			    else if(ajStrPrefixC(line,"SF"))
				continue;
			    else if(ajStrPrefixC(line,"FA"))
				continue;
			    else if(ajStrPrefixC(line,"SI"))
				continue;
			    
			    
			    /* Start of loop to parse HI data */
			    else if(ajStrPrefixC(line,"HI")) 
			    {
				ajFmtScanS(line, "%*s %*d %S %d %d %*s %*s %S", 
					   &code, &start, &end, &second);
				if((ajStrMatch(second, str)) || (ajStrMatch(second, str2)))
				{
				    ajIntPut(truehits, hi_cnt, 1);
				    ajInt2dPut(range, hi_cnt, 0, start);
				    ajInt2dPut(range, hi_cnt, 1, end);		
				    ajStrAssS(&(*codes[temp]), code);
				    temp++;
				}
	    
				/* loop through HI lines */
				/* Read in and store the rank (no. of hits) */
				/* from the HI line */
/*				while((ajFileReadLine(hitsin, &line) && !ajStrPrefixC(line,"//")) ||
			      (ajFileReadLine(hitsin, &line) && (roc_false != roc_val)))	    */
				while((ajFileReadLine(hitsin, &line) && (hi_cnt < num_hits)))
				{
				    /*printf("loop %d\n", hi_cnt);*/
				    hi_cnt++;
				    ajFmtScanS(line, "%*s %*d %S %d %d %*s %*s %S", 
					       &code, &start, &end, &second);
				    if((ajStrMatch(second, str)) || (ajStrMatch(second, str2)))
				    {	
					ajIntPut(truehits, hi_cnt, 1);		
					ajInt2dPut(range, hi_cnt, 0, start);
					ajInt2dPut(range, hi_cnt, 1, end);		
					ajStrAssS(&(*codes)[temp], code);
					temp++;
				    }
				}
				while((ajFileReadLine(hitsin, &line) && !ajStrPrefixC(line,"//")))
				{
				    all++;
				}
/*				printf("all = %d num_hits = %d total = %d\n", 
				       all, num_hits, (num_hits + all)); */
				all += num_hits;
				break;
				
			    }
			}
			
			/* Allocate memory for Scopdata structure */
			(*data) = sigplot_ScopdataNew();
			
			/* Copy name of hits file to string name  */
			ajStrAssS(&name, ajFileGetName(hitsin));
			
			/* remove trailing '.hits' */
			ajStrSubstituteCC(&name, ".hits", "");
			
			
			
			/* Assign SCOP records */
			(*data)->num_hits = num_hits;
			(*data)->file_hitnum = all+1;
			ajStrAssS(&(*data)->file_name, name);
			ajStrAssS(&(*data)->Class,class);
			ajStrAssS(&(*data)->Fold,fold);
			ajStrAssS(&(*data)->Superfamily,super);
			ajStrAssS(&(*data)->Family,family); 
			(*data)->Sunid = sunid;
			(*data)->num_true = true_cnt;
			
			
			y=0;
			/* Process truehits array */
			for(x=0;x<num_hits;x++)
			{
			    if(ajIntGet((*truehits),x) == 1)
			    {
				ajIntPut(rank,y,x);
				y++;
			    }
	
			    else
				continue;
			}
			
			
			
			/* tidy up */
			ajStrDel(&line);
			ajStrDel(&name);
			ajStrDel(&class);
			ajStrDel(&fold);
			ajStrDel(&super);
			ajStrDel(&second);
			ajStrDel(&family);
			ajStrDel(&str);
			ajStrDel(&str2);
			ajStrDel(&str3);
			ajStrDel(&str4);
			ajStrDel(&code);
			ajStrDel(&type);
			

			
			/* return */
			return ajTrue;
		    }
		}
	    }
	}
    }

    ajWarn("Only %d false hits found in hits file %S", roc_false, ajFileGetName(hitsin));

    /* Check if there are any true hits, if not then no point in continuing */
    if(true_cnt == 0)
    {
/*	printf("No true hits found!!\n"); */
	ajWarn("There are no true hits in hits file %S........exiting sigplot!",
	       ajFileGetName(hitsin));
	/* tidy up */
	ajStrDel(&line);
	ajStrDel(&name);
	ajStrDel(&class);
	ajStrDel(&fold);
	ajStrDel(&super);
	ajStrDel(&second);
	ajStrDel(&family);
	ajStrDel(&str);
	ajStrDel(&str2);
	ajStrDel(&str3);
	ajStrDel(&str4);
	ajStrDel(&code);
	ajStrDel(&type);
	
	/* return ajFalse */
	return ajFalse;
    }
    

    /* Assign arrays and strings */
    *truehits = ajIntNewL(num_hits);
    *rank     = ajIntNewL(true_cnt);
    *range    = ajInt2dNewL(num_hits);
    *codes    = (AjPStr *) AJCALLOC0(num_hits, sizeof(AjPStr));


    /* Fill truehits array */
    for(x=0;x<num_hits;x++)
        ajIntPut(truehits,x,0);

    /* Assign strings in codes array */
    for(x=0;x<true_cnt;x++)    
	(*codes)[x] = ajStrNew();
    
    /* Fill range array */
    for(x=0;x<num_hits;x++)
        for(y=0;y<2;y++)
            ajInt2dPut(range, x, y, 0);


    /* reset posinter to start of file */
    ajFileSeek(hitsin, 0, 0);


    
    /* read file again and fill arrays and strings */
    while(ajFileReadLine(hitsin, &line) && !ajStrPrefixC(line,"//"))
    {
	if(ajStrPrefixC(line,"DE"))
	    continue;
	else if(ajStrPrefixC(line,"CL"))
	    continue;
	else if(ajStrPrefixC(line,"XX"))
	    continue;
	else if(ajStrPrefixC(line,"FO"))
	    continue;
	else if(ajStrPrefixC(line,"SF"))
	    continue;
	else if(ajStrPrefixC(line,"FA"))
	    continue;
	else if(ajStrPrefixC(line,"SI"))
	    continue;

	/* Start of loop to parse HI data */
	else if(ajStrPrefixC(line,"HI")) 
	{
	    ajFmtScanS(line, "%*s %*d %S %d %d %*s %*s %S", 
		       &code, &start, &end, &second);
	    if((ajStrMatch(second, str)) || (ajStrMatch(second, str2)))
	    {
		ajIntPut(truehits, hi_cnt, 1);
		ajInt2dPut(range, hi_cnt, 0, start);
		ajInt2dPut(range, hi_cnt, 1, end);		
		ajStrAssS(&(*codes[temp]), code);
		temp++;
	    }
	    
	    /* loop through HI lines */
	    /* Read in and store the rank (no. of hits) */
	    /* from the HI line */
	    while(ajFileReadLine(hitsin, &line) && !ajStrPrefixC(line,"//"))	    
	    {
		hi_cnt++;
		ajFmtScanS(line, "%*s %*d %S %d %d %*s %*s %S", 
		       &code, &start, &end, &second);
		if((ajStrMatch(second, str)) || (ajStrMatch(second, str2)))
		{	
		    ajIntPut(truehits, hi_cnt, 1);		
		    ajInt2dPut(range, hi_cnt, 0, start);
		    ajInt2dPut(range, hi_cnt, 1, end);		
		    ajStrAssS(&(*codes)[temp], code);
		    temp++;
		}
	    }
	}
    }


    /* Allocate memory for Scopdata structure */
    (*data) = sigplot_ScopdataNew();

    /* Copy name of hits file to string name  */
    ajStrAssS(&name, ajFileGetName(hitsin));

    /* remove trailing '.hits' */
    ajStrSubstituteCC(&name, ".hits", "");



    /* Assign SCOP records */
    (*data)->num_hits = num_hits;
    (*data)->file_hitnum = num_hits;
    ajStrAssS(&(*data)->file_name, name);
    ajStrAssS(&(*data)->Class,class);
    ajStrAssS(&(*data)->Fold,fold);
    ajStrAssS(&(*data)->Superfamily,super);
    ajStrAssS(&(*data)->Family,family); 
    (*data)->Sunid = sunid;
    (*data)->num_true = true_cnt;
    

    y=0;
    /* Process truehits array */
    for(x=0;x<num_hits;x++)
    {
	if(ajIntGet((*truehits),x) == 1)
	{
	    ajIntPut(rank,y,x);
	    y++;
	}
	
	else
	    continue;
    }



    /* tidy up */
    ajStrDel(&line);
    ajStrDel(&name);
    ajStrDel(&class);
    ajStrDel(&fold);
    ajStrDel(&super);
    ajStrDel(&second);
    ajStrDel(&family);
    ajStrDel(&str);
    ajStrDel(&str2);
    ajStrDel(&str3);
    ajStrDel(&str4);
    ajStrDel(&code);
    ajStrDel(&type);


    /* return */
    return ajTrue;
}



/* @funcstatic sigplot_ValidatRead  *****************************************
 **
 ** Read validation file and count the number of sequences classified as
 ** seed, other and hit for the family of the signature in question and 
 ** also the number in different folds. 
 **
 ** @param [r] validatin     [AjPFile]      File pointer to signature hits file
 ** @param [r] data          [AjPScopdata*] Scopdata object pointer
 ** @param [w] vali_TN       [ajint]        ajint for number in different fold
 ** @param [w] vali_FN       [ajint]        ajint for number in family
 ** 
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
AjBool	sigplot_ValidatRead(AjPFile validatin, AjPScopdata *data, ajint *vali_TN,
			    ajint *vali_FN, ajint *vali_true,ajint *vali_r, 
			    ajint *vali_nr)
{

    ajint	tn_temp		= 0;
    ajint	fn_temp		= 0;
    
    AjPStr	line		= NULL;
    AjPStr	string		= NULL;
    AjPStr	fold	        = NULL;
    AjPStr	family	        = NULL;
    
    AjBool	done		= ajFalse;


    line   = ajStrNew();
    string = ajStrNew();
    fold   = ajStrNew();
    family   = ajStrNew();
    

    /* Check args */	
    if(!validatin)
	return ajFalse;

    /* reset posinter to start of file */
    ajFileSeek(validatin, 0, 0);



    /* Determine vali_FN */
    /* i.e. count no. of hits in SAME family */
/*
    while(ajFileReadLine(validatin, &line))
    {
	if(ajStrPrefixC(line,"XX"))
	    continue;
	else if(ajStrPrefixC(line,"CL"))
	    continue;
	else if(ajStrPrefixC(line,"FO"))
	    continue;
	else if(ajStrPrefixC(line,"SF"))
	    continue;
	else if(ajStrPrefixC(line,"FA"))
	    continue;
	else if(ajStrPrefixC(line,"NS"))
	    continue;
	else if(ajStrPrefixC(line,"NN"))
	    continue;
	else if(ajStrPrefixC(line,"AC"))
	    continue;
	else if(ajStrPrefixC(line,"TY"))
	    continue;
	else if(ajStrPrefixC(line,"RA"))
	    continue;
	else if(ajStrPrefixC(line,"SQ"))
	    continue;

	else if(ajStrPrefixC(line,"SI"))
	{*/
	    /* copy SI value to si_temp */
    /*   ajFmtScanS(line, "%*s %d\n", &si_temp);
	    ajFmtPrint("si_temp = %d Sunid = %d\n", si_temp, (*data)->Sunid);
	    if(si_temp == (*data)->Sunid)
	    {
		printf("matched SI %d = %d\n", si_temp, (*data)->Sunid); 
		while(ajFileReadLine(validatin, &line) && !ajStrPrefixC(line,"//"))
		{
		    if(ajStrPrefixC(line,"NS"))
		    {
			printf("found NS\n");*/
    /* copy NS value to vali_TN */
    /*ajFmtScanS(line, "%*s %d\n", &ns_temp);
			(*vali_FN) = ns_temp;
		    }
		    else continue;
		}
	    }
	    else continue;
	}
    }
    */



    /* Determine vali_TN and vali_FN */
    /* i.e. count no. of hits in DIFFERENT fold */
    while(ajFileReadLine(validatin, &line))
    {
	if(ajStrPrefixC(line,"XX"))
	    continue;
	else if(ajStrPrefixC(line,"CL"))
	    continue;
	else if(ajStrPrefixC(line,"SF"))
	    continue;
	else if(ajStrPrefixC(line,"FA"))
	    continue;
	else if(ajStrPrefixC(line,"NS"))
	    continue;
	else if(ajStrPrefixC(line,"NN"))
	    continue;
	else if(ajStrPrefixC(line,"AC"))
	    continue;
	else if(ajStrPrefixC(line,"TY"))
	    continue;
	else if(ajStrPrefixC(line,"RA"))
	    continue;
	else if(ajStrPrefixC(line,"SQ"))
	    continue;
	else if(ajStrPrefixC(line,"SI"))
	    continue;

	else if(ajStrPrefixC(line,"FO"))
	{
	    ajStrAssS(&fold,line);
	    ajStrTrim(&fold, +5);

	    if(!ajStrMatch(fold, (*data)->Fold))
	    {
		while(ajFileReadLine(validatin, &line) && !ajStrPrefixC(line,"//"))
		{
		    if(ajStrPrefixC(line,"NS"))
		    {
			ajFmtScanS(line, "%*s %d\n", &tn_temp);
			(*vali_TN) += tn_temp;
		    }
		}
	    }
	    else if(ajStrMatch(fold, (*data)->Fold))
	    {
		/* reset bool */
		done = ajFalse;
		
		while(ajFileReadLine(validatin, &line) && !ajStrPrefixC(line,"//"))
		{
		    /* If line is FAmily line */
		    if((ajStrPrefixC(line, "FA")))
		    {
			/* Extract and clean up family line */
			ajStrAssS(&family,line);
			ajStrTrim(&family, +5);
			/*ajFmtPrint("%S\n", family);*/

			/* Assign true so family is checked later */
			done = ajTrue;
		    }

		    /* If line is NS line */
		    if(ajStrPrefixC(line,"NS"))
		    {
			/* Scan line and assign int */
			ajFmtScanS(line, "%*s %d\n", &fn_temp);
			(*vali_FN) += fn_temp;

			/* If FAmily has been read in above and family == data->Family */
			if((done == ajTrue) && (ajStrMatch(family, (*data)->Family)))
			{
			    /*ajFmtPrint("%S = %S\n", family, (*data)->Family);
			    printf("NS = %d\n", fn_temp);*/
			    (*vali_true) += fn_temp;
			    /*ajFmtPrint("%d\n", *vali_true);*/

			    while(ajFileReadLine(validatin, &line) && !ajStrPrefixC(line,"//"))
			    {
				if(ajStrPrefixC(line,"GP   NON_REDUNDANT"))
				    (*vali_nr)++;
				else if(ajStrPrefixC(line,"GP   REDUNDANT"))
				    (*vali_r)++;
			    } 
			}
		    }
		}
	    }		 
	}
    }
    

    /*ajFmtPrint("vali_FN = %d vali_TN = %d vali_true = %d\n", *vali_FN, *vali_TN, *vali_true);*/
    ajStrDel(&line);
    ajStrDel(&string);
    ajStrDel(&fold);
    ajStrDel(&family);


    /* return */
    return ajTrue;
    
}



/* @funcstatic sigplot_HitProportion  *****************************************
 **
 ** Read signature hits file and count the number of hits, by reading the 
 ** HI line and storing the value for the rank of the hit.
 **
 ** @param [r] hitsin     [AjPFile]      File pointer to signature hits file
 ** @param [r] data       [AjPScopdata*] Scopdata object pointer
 ** @param [w] prob_array [AjPInt2d]     Probability of four classifications
 ** 
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
AjBool	sigplot_HitProportion(AjPFile hitsin, AjPScopdata *data, AjPFloat2d *prob_array,
			      AjPFloat *sensi_array, AjPFloat *speci_array, ajint vali_TN,
			      ajint vali_FN, ajint vali_true, ajint vali_r, ajint vali_nr, 
			      AjBool split_hit, float *prop, float *prop_r, float *prop_nr, 
			      ajint roc_val, float *roc_score)
{

    AjPStr   line           = NULL;     /* Line of text                     */
    AjPStr   temp           = NULL;     /* temp variable for classification */
    AjPStr   type           = NULL;     /* temp variable for redundancy     */
    ajint    x              = 0;
    ajint    y              = 0;
    ajint    true	    = 0;        /* Counter for no. of true classifications    */
    ajint    false	    = 0;        /* Counter for no. of false classifications   */
    ajint    cross	    = 0;        /* Counter for no. of cross classifications   */
    ajint    unknown	    = 0;        /* Counter for no. of unknown classifications */
    ajint    rank           = 0;
    ajint    non	    = 0;
    ajint    red	    = 0;
    ajint    FP  	    = 0;   /* No. of FALSE hits from hits file                      */
    ajint    TP             = 0;   /* No. of CROSS and TRUE hits from hits file             */
    ajint    TN             = 0;   /* (vali_TN - FP)                                        */
    ajint    FN             = 0;   /* (vali_FN - TP)                                        */
    float    sensi_temp     = 0;
    float    speci_temp     = 0;
    ajint    combi	    = 0;
    ajint    all            = 0;
    float    calc	    = 0.0;
    
    /* Check args */	
    if(!hitsin)
	return ajFalse;
    

    /* reset posinter to start of file */
    ajFileSeek(hitsin, 0, 0);


    /* Allocate memory for the probability array */
    *prob_array = ajFloat2dNewL((*data)->file_hitnum);
    *sensi_array = ajFloatNewL((*data)->file_hitnum);
    *speci_array = ajFloatNewL((*data)->file_hitnum);
    

    /* Set reserved size */
    for(x=0; x<6; x++)
	for(y=0;y<(*data)->file_hitnum;y++)
	    ajFloat2dPut(prob_array, x, y, (ajint)0);

    /* assign arrays to zero */
    for(x=0; x<(*data)->file_hitnum; x++)
    {
	ajFloatPut(sensi_array, x, (ajint)0);
	ajFloatPut(speci_array, x, (ajint)0);
    }
    

    /* assign strings */
    line    = ajStrNew();
    temp    = ajStrNew();
    type    = ajStrNew();



    /* Read through the file */
    while(ajFileReadLine(hitsin, &line) && !ajStrPrefixC(line,"//"))
    {
	if(ajStrPrefixC(line,"XX"))
	    continue;

	else if(ajStrPrefixC(line,"CL"))
	    continue;

	else if(ajStrPrefixC(line,"FO"))
	    continue;
	
	else if(ajStrPrefixC(line,"SF"))
	    continue;

	else if(ajStrPrefixC(line,"FA"))
	    continue;

	else if(ajStrPrefixC(line,"DE"))
	    continue;

	else if(ajStrPrefixC(line,"SI"))
	    continue;

	else if(ajStrPrefixC(line,"HI"))
	{
	    /* perform calculation on first line of HI */
	    ajFmtScanS(line, "%*s %d %*s %*d %*d %S %*s %S", &rank, &type, &temp);	      
	    
	    /* If classification = true, determine the                */
	    /* proportion of each classification and write into array */
	    if(ajStrPrefixC(temp, "TRUE"))
	    {
		true++;
		ajFloat2dPut(prob_array, 0, rank-1, (float)((float)true/(float)rank));
		ajFloat2dPut(prob_array, 1, rank-1, (float)((float)false/(float)rank));
		ajFloat2dPut(prob_array, 2, rank-1, (float)((float)cross/(float)rank));
		ajFloat2dPut(prob_array, 3, rank-1, (float)((float)unknown/(float)rank));
		
		if(split_hit == ajTrue)
		{
		    /* If hit = redundant fill array */
		    if(ajStrMatchC(type, "REDUNDANT"))
		    {
			/*printf("redun\n");*/
			/* increment no. of redundants counter */
			red++;
			
			/* determine proportion of 'rank' hits that are (non)redundant */
			ajFloat2dPut(prob_array, 4, rank-1, 
				     (float)((float)red/(float)rank));
			ajFloat2dPut(prob_array, 5, rank-1, 
				     (float)((float)non/(float)rank));
		    }	

		    /* In hit = redundant fill array */
		    else if(ajStrMatchC(type, "NON_REDUNDANT"))
		    {
			/*printf("non-redun\n");*/
			/* increment no. of non_redundants counter */
			non++;
			
			/* determine proportion of 'rank' hits that are (non)redundant */
			ajFloat2dPut(prob_array, 5, rank-1, 
				     (float)((float)non/(float)rank));
			ajFloat2dPut(prob_array, 4, rank-1, 
				     (float)((float)red/(float)rank));
		    }	
		}	
	    }
	    
	    /* If classification = false, determine the */
	    /* proportion of each classification and write value into array */
	    else if(ajStrPrefixC(temp, "FALSE"))
	    {
		false++;
		ajFloat2dPut(prob_array, 0, rank-1, (float)((float)true/(float)rank));
		ajFloat2dPut(prob_array, 1, rank-1, (float)((float)false/(float)rank));
		ajFloat2dPut(prob_array, 2, rank-1, (float)((float)cross/(float)rank));
		ajFloat2dPut(prob_array, 3, rank-1, (float)((float)unknown/(float)rank));


		
			ajFloat2dPut(prob_array, 4, rank-1, 
				     (float)((float)red/(float)rank));
			ajFloat2dPut(prob_array, 5, rank-1, 
				     (float)((float)non/(float)rank));
		 	

		combi++;
		all += true;
/*		printf("got false @ rank %d true = %d all = %d\n", rank, true, all);*/
		if(combi == 50)
		{
/*		    printf("Reached 50th false hit at rank %d\n", rank);
		    printf("T     = %d\n", vali_true);
		    printf("ROC   = %d\n", roc_val); */
		    calc = ((float)1 / ((float)(vali_true*roc_val)));
/*		    printf("1/nT  = %f\n", calc);
		    printf("ROC%d = %f\n", roc_val, (float)(calc * (float)all));  */
		    (*roc_score) = (float)(calc * (float)all); 
		}
		
	    }
	    
	    /* If classification = cross, determine the */
	    /* proportion of each classification and write value into array */
	    else if(ajStrPrefixC(temp, "CROSS"))
	    {
		cross++;
		ajFloat2dPut(prob_array, 0, rank-1, (float)((float)true/(float)rank));
		ajFloat2dPut(prob_array, 1, rank-1, (float)((float)false/(float)rank));
		ajFloat2dPut(prob_array, 2, rank-1, (float)((float)cross/(float)rank));
		ajFloat2dPut(prob_array, 3, rank-1, (float)((float)unknown/(float)rank));


		
			
			/* determine proportion of 'rank' hits that are (non)redundant */
			ajFloat2dPut(prob_array, 4, rank-1, 
				     (float)((float)red/(float)rank));
			ajFloat2dPut(prob_array, 5, rank-1, 
				     (float)((float)non/(float)rank));
		 
			

		/*combi++;
		all += true;
		printf("got cross @ rank %d true = %d all = %d\n", rank, true, all); 
		if(combi == 50)
		{
		    printf("Reached 50th false hit at rank %d\n", rank);
		    printf("T     = %d\n", vali_true);
		    printf("ROC   = %d\n", roc_val);
		    calc = ((float)1 / ((float)(vali_true*roc_val)));
		    printf("1/nT  = %f\n", calc);
		    printf("ROC%d = %f\n", roc_val, (float)(calc * (float)all)); 
		    (*roc_score) = (float)(calc * (float)all); 
		}	*/
	    }
	    
	    /* If classification = unknown, determine the */
	    /* proportion of each classification and write value into array */
	    else if(ajStrPrefixC(temp, "UNKNOWN"))
	    {
		unknown++;
		ajFloat2dPut(prob_array, 0, rank-1, (float)((float)true/(float)rank));
		ajFloat2dPut(prob_array, 1, rank-1, (float)((float)false/(float)rank));
		ajFloat2dPut(prob_array, 2, rank-1, (float)((float)cross/(float)rank));
		ajFloat2dPut(prob_array, 3, rank-1, (float)((float)unknown/(float)rank));

		
			
			/* determine proportion of 'rank' hits that are (non)redundant */
			ajFloat2dPut(prob_array, 4, rank-1, 
				     (float)((float)red/(float)rank));
			ajFloat2dPut(prob_array, 5, rank-1, 
				     (float)((float)non/(float)rank));
		

		/*combi++;
		all += true;
		printf("got unknown @ rank %d true = %d all = %d\n", rank, true, all);
		if(combi == 50)
		{
		    printf("Reached 50th false hit at rank %d\n", rank);
		    printf("T     = %d\n", vali_true);
		    printf("ROC   = %d\n", roc_val);
		    calc = ((float)1 / ((float)(vali_true*roc_val)));
		    printf("1/nT  = %f\n", calc);
		    printf("ROC%d = %f\n", roc_val, (float)(calc * (float)all)); 
		    (*roc_score) = (float)(calc * (float)all); 
		}*/

	    }
	    /* calculate specificity and sensitivity values */
	    
	    /* Determine and assign true positives */
	    
	    /*TP = (true + cross); MJB 26/6/02*/
	    TP = true;
	    /*printf("TP = %d\n", TP);*/
	    
	    /* Determine and assign false positives */
	    FP = false;
	    /*printf("FP = %d\n", FP);*/
	    
	    /* Determine and assign true negatives */
	    TN = (vali_TN - FP);
	    /*printf("TN = %d\n", TN);*/
	    
	    /* Determine and assign false negatives */
	    /*FN = (vali_FN - TP); MJB 26/6/02 */
	    FN = (vali_true - TP);
	    /*printf("FN = %d\n", FN);*/
	    
	    /* Perform calculations and assign to arrays */
	    /* Sensitivity */
	    /*sensi_temp =  (float)(((float)TP)/((float)TP+(float)FN));*/

	    sensi_temp =  (float)(((float)TP)/((float)vali_true));

	    /*printf("sensi = %f\n", sensi_temp);*/
	    
	    ajFloatPut(sensi_array, rank-1, sensi_temp); 
	    
	    /* Specificity */
/*	    speci_temp =  (float)(((float)TN)/((float)TN+(float)FP));*/

	    speci_temp =  (float)(((float)TP)/((float)((float)rank - ((float)cross + (float)unknown))));
	
/*	    printf("speci = %f\n", speci_temp);*/

	    ajFloatPut(speci_array, rank-1, (float)((float)1 - speci_temp)); 
	


	    /* Start of loop for calculating      */
	    /* proportion of each classification  */
	    /* and sensitivity/specificity values */
	    while(ajFileReadLine(hitsin, &line) && !ajStrPrefixC(line,"XX"))	    
	    {
		/* Scan rank and secondary classification into variables */
		ajFmtScanS(line, "%*s %d %*s %*d %*d %S %*s %S", &rank, &type, &temp);	      


		/* If classification = true, determine the */
		/* proportion of each classification and write value into array */
		if(ajStrPrefixC(temp, "TRUE"))
		{
		    true++;
		    ajFloat2dPut(prob_array, 0, rank-1, (float)((float)true/(float)rank));
		    ajFloat2dPut(prob_array, 1, rank-1, (float)((float)false/(float)rank));
		    ajFloat2dPut(prob_array, 2, rank-1, (float)((float)cross/(float)rank));
		    ajFloat2dPut(prob_array, 3, rank-1, (float)((float)unknown/(float)rank));

		    if(split_hit == ajTrue)
		    {
			/* In hit = redundant fill array */
			if(ajStrMatchC(type, "REDUNDANT"))
			{
			    /*printf("redun\n");*/
			    /* increment no. of redundants counter */
			    red++;
			
			    /* determine proportion of 'rank' hits that are redundant */
			    ajFloat2dPut(prob_array, 4, rank-1, 
				     (float)((float)red/(float)rank));
			    ajFloat2dPut(prob_array, 5, rank-1, 
				     (float)((float)non/(float)rank));
			}	

			/* In hit = redundant fill array */
			else if(ajStrMatchC(type, "NON_REDUNDANT"))
			{
			    /*printf("non-redun\n");*/
			    /* increment no. of non_redundants counter */
			    non++;
			    
			    /* determine proportion of 'rank' hits that are redundant */
			    ajFloat2dPut(prob_array, 5, rank-1, 
					 (float)((float)non/(float)rank));
			    ajFloat2dPut(prob_array, 4, rank-1, 
					 (float)((float)red/(float)rank));
			}		
		    }
		}

		/* If classification = false, determine the */
		/* proportion of each classification and write value into array */
		else if(ajStrPrefixC(temp, "FALSE"))
		{
		    false++;
		    ajFloat2dPut(prob_array, 0, rank-1, (float)((float)true/(float)rank));
		    ajFloat2dPut(prob_array, 1, rank-1, (float)((float)false/(float)rank));
		    ajFloat2dPut(prob_array, 2, rank-1, (float)((float)cross/(float)rank));
		    ajFloat2dPut(prob_array, 3, rank-1, (float)((float)unknown/(float)rank));
		    

			    /* determine proportion of 'rank' hits that are redundant */
			    ajFloat2dPut(prob_array, 4, rank-1, 
				     (float)((float)red/(float)rank));
			    ajFloat2dPut(prob_array, 5, rank-1, 
				     (float)((float)non/(float)rank));
			


		    combi++;
		    all += true;
		    /* printf("got false @ rank %d true = %d all = %d\n", rank, true, all); */
		    if(combi == 50)
		    {
/*			printf("Reached 50th false hit at rank %d\n", rank);
			printf("T     = %d\n", vali_true);
			printf("ROC   = %d\n", roc_val); */
			calc = ((float)1 / ((float)(vali_true*roc_val)));
/*			printf("1/nT  = %f\n", calc);
			printf("ROC%d = %f\n", roc_val, (float)(calc * (float)all));  */
			(*roc_score) = (float)(calc * (float)all); 
		    }

		}

		/* If classification = cross, determine the */
		/* proportion of each classification and write value into array */
		else if(ajStrPrefixC(temp, "CROSS"))
		{
		    cross++;
		    ajFloat2dPut(prob_array, 0, rank-1, (float)((float)true/(float)rank));
		    ajFloat2dPut(prob_array, 1, rank-1, (float)((float)false/(float)rank));
		    ajFloat2dPut(prob_array, 2, rank-1, (float)((float)cross/(float)rank));
		    ajFloat2dPut(prob_array, 3, rank-1, (float)((float)unknown/(float)rank));


			    /* determine proportion of 'rank' hits that are redundant */
			    ajFloat2dPut(prob_array, 4, rank-1, 
				     (float)((float)red/(float)rank));
			    ajFloat2dPut(prob_array, 5, rank-1, 
				     (float)((float)non/(float)rank));
			


		    /*combi++;
		    all += true;
		    printf("got cross @ rank %d true = %d all = %d\n", rank, true, all);
		    if(combi == 50)
		    {
			printf("Reached 50th false hit at rank %d\n", rank);
			printf("T     = %d\n", vali_true);
			printf("ROC   = %d\n", roc_val);
			calc = ((float)1 / ((float)(vali_true*roc_val)));
			printf("1/nT  = %f\n", calc);
			printf("ROC%d = %f\n", roc_val, (float)(calc * (float)all)); 
			(*roc_score) = (float)(calc * (float)all); 
		    }*/

		}	

		/* If classification = unknown, determine the */
		/* proportion of each classification and write value into array */
		else if(ajStrPrefixC(temp, "UNKNOWN"))
		{
		    unknown++;	
		    ajFloat2dPut(prob_array, 0, rank-1, (float)((float)true/(float)rank));
		    ajFloat2dPut(prob_array, 1, rank-1, (float)((float)false/(float)rank));
		    ajFloat2dPut(prob_array, 2, rank-1, (float)((float)cross/(float)rank));
		    ajFloat2dPut(prob_array, 3, rank-1, (float)((float)unknown/(float)rank));


			    /* determine proportion of 'rank' hits that are redundant */
			    ajFloat2dPut(prob_array, 4, rank-1, 
				     (float)((float)red/(float)rank));
			    ajFloat2dPut(prob_array, 5, rank-1, 
				     (float)((float)non/(float)rank));
			


		    /*combi++;
		    all += true;
		    printf("got unknown @ rank %d true = %d all = %d\n", rank, true, all);
		    if(combi == 50)
		    {
			printf("Reached 50th false hit at rank %d\n", rank);
			printf("T     = %d\n", vali_true);
			printf("ROC   = %d\n", roc_val);
			calc = ((float)1 / ((float)(vali_true*roc_val)));
			printf("1/nT  = %f\n", calc);
			printf("ROC%d = %f\n", roc_val, (float)(calc * (float)all)); 
			(*roc_score) = (float)(calc * (float)all); 
		    }*/
		}
		
		/* calculate specificity and sensitivity values */

		/* Determine and assign true positives */
		/*TP = (true + cross); MJB 26/6/02 */
		TP = true;
		/*printf("rank = %4d TP = %4d\n", rank, TP);*/
		
		/* Determine and assign false positives */
		FP = false;
		/*printf("rank = %4d FP = %4d\n", rank,FP);*/
		
		/* Determine and assign true negatives */
		TN = (vali_TN - FP);
		/*printf("rank = %4d TN = %4d\n", rank,TN);*/
		
		/* Determine and assign false negatives */
		/*FN = (vali_FN - TP); MJB 26/6/-2 */
		FN = (vali_true - TP);
		/*printf("rank = %4d FN = %4d\n", rank,FN);*/

		/* Perform calculations and assign to arrays */
		/* Sensitivity */
		/*sensi_temp =  (float)(((float)TP)/((float)TP+(float)FN));*/

		sensi_temp =  (float)(((float)TP)/((float)vali_true));

		/*printf("sensi = %f\n", sensi_temp);*/
		
		ajFloatPut(sensi_array, rank-1, sensi_temp); 

		/* Specificity */
		/*speci_temp =  (float)(((float)TN)/((float)TN+(float)FP));*/
		
		speci_temp =  (float)(((float)TP)/((float)((float)rank - ((float)cross + (float)unknown))));
		    		
/*		printf("speci = %f\n", speci_temp);*/

		ajFloatPut(speci_array, rank-1, (float)((float)1 - speci_temp)); 
	    }
	}
    }

    /*for(x=0;x<(*data)->file_hitnum;x++)
	    {
		ajFmtPrint("%f ", ajFloat2dGet((*prob_array), 0, x));
		ajFmtPrint("%f ", ajFloat2dGet((*prob_array), 1, x));
		ajFmtPrint("%f ", ajFloat2dGet((*prob_array), 2, x));
		ajFmtPrint("%f ", ajFloat2dGet((*prob_array), 3, x));
		ajFmtPrint("%f ", ajFloat2dGet((*prob_array), 4, x));
		ajFmtPrint("%f \n", ajFloat2dGet((*prob_array), 5, x));
	    }*/

/*    ajFmtPrint("Total true detected = %d\n", true);
    ajFmtPrint("Proportion of total family members detected = %.2f\n", 
	       (((float)true/(float)vali_true)*100));  */

    (*prop)    = (((float)true/(float)vali_true)*100);  
    (*prop_r)  = (((float)red/(float)vali_r)*100);  
    (*prop_nr) = (((float)non/(float)vali_nr)*100);  
    

    /* Tidy up */
    ajStrDel(&line);
    ajStrDel(&temp);
    ajStrDel(&type);


    /* return */
    return ajTrue;
    
}






/* @funcstatic sigplot_DataWrite  *****************************************
 **
 ** Read prob_array and Scopdata structure, and write a data file suitable
 ** for plotting using the application GNUPLOT
 **
 ** @param [w] datafile    [AjPFile]     File pointer to output datafile
 ** @param [r] data        [AjPScopdata] Scopdata object pointer
 ** @param [r] prob_array  [AjPInt2d]    Array of probability of four classifications
 ** @param [r] sensi_array [AjPInt]      Array of sensitivity values
 ** @param [r] speci_array [AjPInt]      Array of specificity values
 ** @param [r] outdir      [AjPStr]      Path for output files
 **
 ** @return [AjBool] True on succcess
 ** @@
 *****************************************************************************/
AjBool  sigplot_DataWrite(AjPFile datafile, AjPFile ssdatafile, AjPScopdata data, 
			  AjPFloat2d prob_array, AjPFloat sensi_array, AjPFloat speci_array,
			  AjBool split_hit, float prop, float prop_r, float prop_nr, 
			  ajint list_num, AjPStr temp, float roc_score, AjPStr outdir)
{
    
    ajint	x	   = 0;     /* Loop counter                                */
    AjPFile     truePtr    = NULL;  /* Pointer to true data file                   */
    AjPFile     crossPtr   = NULL;  /* Pointer to cross data file                  */
    AjPFile     falsePtr   = NULL;  /* Pointer to false data file                  */
    AjPFile     unknownPtr = NULL;  /* Pointer to unknown data file                */
    AjPFile     nonPtr     = NULL;  /* Pointer to true non-redundant data file     */
    AjPFile     redPtr     = NULL;  /* Pointer to true redundant data file         */
    AjPFile     sensiPtr   = NULL;  /* Pointer to sensitivity data file            */
    AjPFile     speciPtr   = NULL;  /* Pointer to specificity data file            */

    AjPStr      true       = NULL;  /* String of output data file name             */
    AjPStr      cross      = NULL;  /* String of output data file name             */
    AjPStr      false      = NULL;  /* String of output data file name             */
    AjPStr      unknown    = NULL;  /* String of output data file name             */
    AjPStr      red        = NULL;  /* String of output data file name             */
    AjPStr      non        = NULL;  /* String of output data file name             */

    AjPStr      true_nopath       = NULL;  /* String of output data file name             */
    AjPStr      cross_nopath      = NULL;  /* String of output data file name             */
    AjPStr      false_nopath      = NULL;  /* String of output data file name             */
    AjPStr      unknown_nopath   = NULL;  /* String of output data file name             */
    AjPStr      red_nopath        = NULL;  /* String of output data file name             */
    AjPStr      non_nopath        = NULL;  /* String of output data file name             */

    AjPStr      sensi      = NULL;  /* String of sensitivity output data file name */
    AjPStr      sensi_nopath      = NULL;  /* String of sensitivity output data file name */
    AjPStr      speci      = NULL;  /* String of specificity output data file name */
    static ajint  file_cnt   = 0;     /* counter for the hits files                  */
    
    AjPStr    name=NULL;  /*Used for naming files */

    
    /* initialize strings */
    true    = ajStrNew();
    cross   = ajStrNew();
    false   = ajStrNew(); 
    unknown = ajStrNew();
    red     = ajStrNew();
    non     = ajStrNew();   

    true_nopath    = ajStrNew();
    cross_nopath   = ajStrNew();
    false_nopath   = ajStrNew(); 
    unknown_nopath = ajStrNew();
    red_nopath     = ajStrNew();
    non_nopath     = ajStrNew();   

    sensi   = ajStrNew();
    sensi_nopath   = ajStrNew();
    speci   = ajStrNew();
    name    = ajStrNew();

    
    for(x=MAJSTRLEN(data->file_name)-1;x>=0; x--)
	if(ajStrChar(data->file_name, x)=='/')
	    {
		ajStrAssSub(&name, data->file_name, x+1, -1);
		break;
	    }
    ajStrInsert(&name, 0, outdir);
    

/*    printf("list_num = %d file_cnt = %d\n", list_num, file_cnt);*/


    /* Assign name to filename string               */
    /* Append 'classification'.dat to end of string */ 
    if(split_hit == ajTrue)
    {
/*	ajStrAssS(&non, data->file_name); */
	ajStrAssS(&non, name);
	ajStrAppC(&non, "_non.dat");
/*	ajStrAssS(&red, data->file_name); */
	ajStrAssS(&red, name);
	ajStrAppC(&red, "_red.dat");
    }
    
    else if(split_hit == ajFalse)
    {
/*    	ajStrAssS(&true, data->file_name); */
    	ajStrAssS(&true, name);
	ajStrAppC(&true, "_true.dat");
    }   
 
/*    ajStrAssS(&cross, data->file_name); */
    ajStrAssS(&cross, name);
    ajStrAppC(&cross, "_cross.dat");
/*    ajStrAssS(&false, data->file_name); */
    ajStrAssS(&false, name);
    ajStrAppC(&false, "_false.dat");
/*    ajStrAssS(&unknown, data->file_name); */
    ajStrAssS(&unknown, name);
    ajStrAppC(&unknown, "_unknown.dat");

/*    ajStrAssS(&sensi, data->file_name); */
    ajStrAssS(&sensi, name);
    ajStrAppC(&sensi, "_sensi.dat");
/*    ajStrAssS(&speci, data->file_name); */
    ajStrAssS(&speci, name);
    ajStrAppC(&speci, "_speci.dat");

    
    /* Assign file pointers */
    if(split_hit == ajTrue)
    {
/*	ajFmtPrint("red = %S\n", red);
	fflush(stdout); */

	if((redPtr = ajFileNewOut(red))==NULL)
	    ajFatal("Could not open file");
	

/*	ajFmtPrint("non = %S\n", non);
	fflush(stdout); */

	if((nonPtr = ajFileNewOut(non))==NULL)
	    ajFatal("Could not open file");
    }

    else if(split_hit == ajFalse)
    {	
/*	ajFmtPrint("true = %S\n", true);
	fflush(stdout); */

	truePtr    = ajFileNewOut(true);
	ajFmtPrint("redPtr NOT opened\n");
	fflush(stdout);
    }

/*    ajFmtPrint("cross = %S\n", cross);
    fflush(stdout); */

    if((crossPtr   = ajFileNewOut(cross))==NULL)
	ajFatal("Could not open file");

/*    ajFmtPrint("false = %S\n", false);
    fflush(stdout); */

    if((falsePtr   = ajFileNewOut(false))==NULL)
	ajFatal("Could not open file");

/*    ajFmtPrint("unknown = %S\n", unknown);
    fflush(stdout); */

    if((unknownPtr = ajFileNewOut(unknown))==NULL)
	ajFatal("Could not open file");
    
/*    ajFmtPrint("sensi = %S\n", sensi);
    fflush(stdout); */

    if((sensiPtr = ajFileNewOut(sensi))==NULL)
	ajFatal("Could not open file");

/*    ajFmtPrint("speci = %S\n", speci);
    fflush(stdout); */

    if((speciPtr = ajFileNewOut(speci))==NULL)
	ajFatal("Could not open file");

    /* Print probabilities from array to data files */
    for(x = 0; x <(data)->num_hits; x++)
    {
	if(split_hit == ajTrue)
	{
	    ajFmtPrintF(redPtr,     "%d    %4f\n", x, ajFloat2dGet(prob_array, 4, x));
	    ajFmtPrintF(nonPtr,     "%d    %4f\n", x, ajFloat2dGet(prob_array, 5, x));
	}
	    
	else if(split_hit == ajFalse)
	    ajFmtPrintF(truePtr,    "%d    %4f\n", x, ajFloat2dGet(prob_array, 0, x));
	
	ajFmtPrintF(falsePtr,   "%d    %4f\n", x, ajFloat2dGet(prob_array, 1, x));
	ajFmtPrintF(crossPtr,   "%d    %4f\n", x, ajFloat2dGet(prob_array, 2, x));
	ajFmtPrintF(unknownPtr, "%d    %4f\n", x, ajFloat2dGet(prob_array, 3, x));
	ajFmtPrintF(sensiPtr,   "%4f    %4f\n", ajFloatGet(speci_array, x), 
		    ajFloatGet(sensi_array, x));
	/*ajFmtPrintF(speciPtr,   "%d    %4f\n", x, ajFloatGet(speci_array, x));*/
    }



    /* Write main .dat file */
    ajFmtPrintF(datafile,    "#  GNUPLOT data file suitable for plotting signature performance\n");
    ajFmtPrintF(datafile,    "#\n");
    ajFmtPrintF(datafile,    "#\n");
    ajFmtPrintF(datafile,    "#  %S\n", data->Class);
    ajFmtPrintF(datafile,    "#  XX\n");
    ajFmtPrintF(datafile,    "#  %S\n", data->Fold);
    ajFmtPrintF(datafile,    "#  XX\n");
    ajFmtPrintF(datafile,    "#  %S\n", data->Superfamily);
    ajFmtPrintF(datafile,    "#  XX\n");
    ajFmtPrintF(datafile,    "#  %S\n", data->Family);
    ajFmtPrintF(datafile,    "#  XX\n");
    ajFmtPrintF(datafile,    "#  %d\n", data->Sunid);
    ajFmtPrintF(datafile,    "#  XX\n");

    if(split_hit == ajTrue)
    {
        ajFmtPrintF(datafile,    "set title \"Performance of %d Family Signature (%.2f r, %.2f nr)\"\n", 
		    data->Sunid, prop_r, prop_nr);
    }
    else
        ajFmtPrintF(datafile,    "set title \"Performance of %d Family Signature (%.2f)\"\n", data->Sunid, prop);

    ajFmtPrintF(datafile,    "set xlabel \"Number of Hits\"\n");
    ajFmtPrintF(datafile,    "set ylabel \"Proportion of total hits\"\n");
    ajFmtPrintF(datafile,    "set nokey\n");
    ajFmtPrintF(datafile,    "set key top outside title \"Legend\" box 3 \n");
    ajFmtPrintF(datafile,    "set data style points\n");
    ajFmtPrintF(datafile,    "set pointsize 0.45\n");
    /* Execute plot command to plot data files */

    for(x=MAJSTRLEN(true)-1;x>=0; x--)
	if(ajStrChar(true, x)=='/')
	    {
		ajStrAssSub(&true_nopath, true, x+1, -1);
		break;
	    }
    

    for(x=MAJSTRLEN(red)-1;x>=0; x--)
	if(ajStrChar(red, x)=='/')
	    {
		ajStrAssSub(&red_nopath, red, x+1, -1);
		break;
	    }
    

    for(x=MAJSTRLEN(non)-1;x>=0; x--)
	if(ajStrChar(non, x)=='/')
	    {
		ajStrAssSub(&non_nopath, non, x+1, -1);
		break;
	    }
    

    for(x=MAJSTRLEN(cross)-1;x>=0; x--)
	if(ajStrChar(cross, x)=='/')
	    {
		ajStrAssSub(&cross_nopath, cross, x+1, -1);
		break;
	    }
    

    for(x=MAJSTRLEN(false)-1;x>=0; x--)
	if(ajStrChar(false, x)=='/')
	    {
		ajStrAssSub(&false_nopath, false, x+1, -1);
		break;
	    }
    

    for(x=MAJSTRLEN(unknown)-1;x>=0; x--)
	if(ajStrChar(unknown, x)=='/')
	    {
		ajStrAssSub(&unknown_nopath, unknown, x+1, -1);
		break;
	    }
    

    for(x=MAJSTRLEN(sensi)-1;x>=0; x--)
	if(ajStrChar(sensi, x)=='/')
	    {
		ajStrAssSub(&sensi_nopath, sensi, x+1, -1);
		break;
	    }
    



    if(split_hit == ajTrue)
    {
	ajFmtPrintF(datafile,    "plot \"%S\" smooth bezier title \"Redun Hits\", \"%S\" smooth bezier title \"Non Hits\",\"%S\" smooth bezier title \"Cross Hits\", \"%S\" smooth bezier title \"False Hits\", \"%S\" smooth bezier title \"Unknown Hits\"\n", red_nopath, non_nopath, cross_nopath, false_nopath, unknown_nopath);
    }
    
    else if(split_hit == ajFalse)
	ajFmtPrintF(datafile,    "plot \"%S\" smooth bezier title \"True Hits\", \"%S\" smooth bezier title \"Cross Hits\", \"%S\" smooth bezier title \"False Hits\", \"%S\" smooth bezier title \"Unknown Hits\"\n", true_nopath, cross_nopath, false_nopath, unknown_nopath);
 
   
    /* Only write ROC data file if on last hits file */
    /* i.e. file_cnt == list_num                     */
    
    if(file_cnt == 0)
    {
	/* Write specificity and sensitivity .dat file */
	ajFmtPrintF(ssdatafile,    "#  GNUPLOT data file suitable for plotting signature sensitivity and specificity\n");
	ajFmtPrintF(ssdatafile,    "#\n");
	ajFmtPrintF(ssdatafile,    "#\n");
	ajFmtPrintF(ssdatafile,    "#  %S\n", data->Class);
	ajFmtPrintF(ssdatafile,    "#  XX\n");
	ajFmtPrintF(ssdatafile,    "#  %S\n", data->Fold);
	ajFmtPrintF(ssdatafile,    "#  XX\n");
	ajFmtPrintF(ssdatafile,    "#  %S\n", data->Superfamily);
	ajFmtPrintF(ssdatafile,    "#  XX\n");
	ajFmtPrintF(ssdatafile,    "#  %S\n", data->Family);
	ajFmtPrintF(ssdatafile,    "#  XX\n");
	ajFmtPrintF(ssdatafile,    "#  %d\n", data->Sunid);
	ajFmtPrintF(ssdatafile,    "#  XX\n");
	ajFmtPrintF(ssdatafile,    "set title \"ROC Curves of Signature Performance\"\n");
	ajFmtPrintF(ssdatafile,    "set xlabel \"1 - Specificity\"\n");
	ajFmtPrintF(ssdatafile,    "set ylabel \"Sensitivity\"\n");
	ajFmtPrintF(ssdatafile,    "set nokey\n");
	ajFmtPrintF(ssdatafile,    "set noautoscale\n");
	ajFmtPrintF(ssdatafile,    "set xrange [0:1]\n");
	ajFmtPrintF(ssdatafile,    "set yrange [0:1]\n");
	ajFmtPrintF(ssdatafile,    "set key top outside title \"Legend\" box 3 \n");
	ajFmtPrintF(ssdatafile,    "set data style points\n");
	ajFmtPrintF(ssdatafile,    "set pointsize 0.45\n");
	/* Execute plot command to plot data files */
	ajFmtPrintF(ssdatafile,    "plot \"%S\" smooth bezier title \"%S(%f)\", ", sensi_nopath, temp, roc_score);
    }
    

    /* Execute plot command to plot data files */
    if((file_cnt != 0) && (file_cnt != list_num-1))
	ajFmtPrintF(ssdatafile, "\"%S\" smooth bezier title \"%S(%f)\", ", sensi_nopath, temp, roc_score);
    
    else if(file_cnt == list_num-1)
	ajFmtPrintF(ssdatafile, "\"%S\" smooth bezier title \"%S(%f)\"\n", sensi_nopath, temp, roc_score);
    

    /* Increment hits file_cnt */
    file_cnt++;
    

    

    /* Close files */

    if(split_hit == ajTrue)
    {
	ajFileClose(&redPtr);
	ajFileClose(&nonPtr);
    }

    else if(split_hit == ajFalse)
        ajFileClose(&truePtr);

    ajFileClose(&crossPtr);
    ajFileClose(&falsePtr);
    ajFileClose(&unknownPtr);
    ajFileClose(&sensiPtr);
    ajFileClose(&speciPtr);


    /* Tidy up */
    ajStrDel(&true);
    ajStrDel(&cross);
    ajStrDel(&false);
    ajStrDel(&unknown);
    ajStrDel(&red);
    ajStrDel(&non);
    ajStrDel(&sensi);
    ajStrDel(&speci);
    ajStrDel(&name);
    
    ajStrDel(&true_nopath);
    ajStrDel(&cross_nopath);
    ajStrDel(&false_nopath);
    ajStrDel(&unknown_nopath);
    ajStrDel(&red_nopath);
    ajStrDel(&non_nopath);
    ajStrDel(&sensi_nopath);


    /* Return */
    return ajTrue;
    

}






/* @func sigplot_AlignSeqExtract **********************************************
**
** @param [r] alignfile   [AjPFile]     File pointer to alignment file
** @param [r] submat      [AjPMatrixf]  Pointer to subsitiution matrix
** @param [r] gapopen     [float]       Gap opening penalty
** @param [r] gapextn     [float]       Gap extension penalty
** @param [r] matrixout   [AjPFile]     Pointer to output file for %id matrix
** 
** @return [AjBool] 
** @@
******************************************************************************/
AjBool	sigplot_AlignSeqExtract(AjPFile sigalignfile, AjPInt truehits, AjPInt2d range, 
				AjPStr **sig_seqs, AjPStr **temp_seqs, ajint num, 
				ajint num_true, ajint file_hitnum) 
{

    AjPStr		seq		= NULL;
    AjPStr		line		= NULL;
    AjPStr		check		= NULL;


    ajint 		x 		= 0;
    ajint 		y 		= 0;
    ajint		cnt 		= 0;
    ajint		sigcnt          = 0;
    
    

    

    /* check args */
    if(!sigalignfile || !truehits || !range || !sig_seqs)
    {
	printf("Bad arguments passed to sigplot_AlignSeqExtract...... exiting\n");
	return ajFalse;	
    }    
    

    /* Assign Strings */
    seq = ajStrNew();
    line = ajStrNew();
    check = ajStrNew();


    /* Allocate memory and Strings */
    *temp_seqs = (AjPStr *) AJCALLOC0(file_hitnum, sizeof(AjPStr));
    *sig_seqs = (AjPStr *) AJCALLOC0(num_true, sizeof(AjPStr));

    for(x=0;x<file_hitnum;x++)
	(*temp_seqs)[x] = ajStrNew();

    for(x=0;x<num_true;x++)
	(*sig_seqs)[x] = ajStrNew();



    /* Start of main application loop */
    while((ajFileReadLine(sigalignfile,&line) && (!ajStrPrefixC(line,"//"))))
    {
	/* Ignore 'Number' lines */
	if(ajStrPrefixC(line,"CL"))
	    continue;
	else if(ajStrPrefixC(line,"FO"))
	    continue;
	else if(ajStrPrefixC(line,"SF"))
	    continue;
	else if(ajStrPrefixC(line,"FA"))
	    continue;
	else if(ajStrPrefixC(line,"XX"))
	    continue;
	else if(ajStrPrefixC(line,"SI"))
	{
	    /* Read in XX line after SI line */
	    ajFileReadLine(sigalignfile,&line);
	    /* read first block of data */
	    while((ajFileReadLine(sigalignfile,&line) && (!ajStrPrefixC(line,"XX"))))
	    {
		ajFmtScanS(line, "%S%*s%S", &check, &seq);
		if(!ajStrMatchC(check, "SIGNATURE"))
		    {
			ajStrAssS(&(*temp_seqs)[cnt], seq);
			cnt++;
		    }
		else
		    continue;
		y++;
		
	    }


	    /* First block read, reset block line counter */
	    cnt = 0;


	    /* Read rest of sig/seq data lines */
	    while(ajFileReadLine(sigalignfile,&line) && (!ajStrPrefixC(line,"//")))	    
	    {
		/* If line = XX, i.e. end of block, reset cnt */
		if(ajStrPrefixC(line,"XX"))
		    cnt = 0;

		/* Else still in block so deal with line */
		else
		{
		    ajFmtScanS(line, "%S%*s%S", &check, &seq);
		    /* Check if sig/seq data for that line is completed */
		    if(!ajStrMatchC(check, "SIGNATURE"))
		    {
			if(!ajStrMatchC(seq, "."))
			{
			    /*ajFmtPrint("\nprev %S\n", (*temp_seqs)[cnt]);*/
			    ajStrApp(&(*temp_seqs)[cnt], seq);
			    /*ajFmtPrint("now  %S\n\n", (*temp_seqs)[cnt]);*/
			    cnt++;
			}
			else
			{
			    cnt++;
			    continue;
			}
			
		    }
		    
		    else
			continue;
		}
	    }
	}		    
    }
    



    /* Code section to extract range of sequence corresponding */
    /* to the sequence-signature alignment		       */
    for(x=0;x<num;x++)
    {
	/* Check if hit is a 'TRUE' hit */
	if(ajIntGet(truehits, x) == 1)
	{
/*	    ajFmtPrint("\nFound true hit at pos %3d (%d) range = %3d-%3d\n", 
		       x, ajIntGet(truehits,x), ajInt2dGet(range,x, 0), ajInt2dGet(range, x, 1));
	    ajFmtPrint("Sequence at rank   =  %S\n", (*temp_seqs)[x]);*/

	    /* Assign sub-sequence to array */
	    ajStrAssSub(&(*sig_seqs)[sigcnt], (*temp_seqs)[x],
			(ajInt2dGet(range, x, 0)-1), (ajInt2dGet(range, x, 1)-1));
	    /*ajFmtPrint("range              =  %S\n", (*sig_seqs)[sigcnt]);*/
	    sigcnt++;
	}
	else
	{
	    /*printf("\nNo hit found at pos %3d (%d)\n", x, ajIntGet(truehits,x)); */
	    continue;
	}
    }
    
    /*for(x=0;x<num_true;x++)
	  ajFmtPrint("Extracted range =  %S\n", (*sig_seqs)[x]);*/





    ajStrDel(&seq);    
    ajStrDel(&line);    
    ajStrDel(&check);    
    

    /* return */
    return ajTrue;
    


}




/* @func sigplot_SeedIdCalc***************************************************
**
** @param [r] alignfile   [AjPFile]     File pointer to alignment file
** @param [r] submat      [AjPMatrixf]  Pointer to subsitiutionmatrix
** @param [r] gapopen     [float]       Gap opening penalty
** @param [r] gapextn     [float]       Gap extension penalty
** @param [r] matrixout   [AjPFile]     Pointer to output file for %id matrix
** 
** @return [AjBool] 
** @@
******************************************************************************/
AjBool  sigplot_SeedIdCalc(AjPList seedlist,  AjPScopalg alg, AjPFile matrixout,
			   AjPMatrixf submat, float gapopen, float gapextn) 
{
    ajint       start1  	= 0;  	/*Start of seq 1, passed as arg but not used*/
    ajint       start2  	= 0;  	/*Start of seq 2, passed as arg but not used*/
    ajint  	maxarr  	= 300; 	/*Initial size for matrix*/
    ajint 	len;
    ajint     	x;			/*Counter for seq 1*/
    ajint    	y;			/*Counter for seq 2*/ 
    ajint   	nin;			/*Number of sequences in input list*/
    ajint     	*compass;

    char       	*p;
    char       	*q;

    float     **sub;
    float       id       	= 0.; 	/*Passed as arg but not used here*/
    float       sim      	= 0.;   
    float       idx      	= 0.;  	/*Passed as arg but not used here*/
    float       simx     	= 0.;  	/*Passed as arg but not used here*/
    float      *path;
    float      	av_temp		= 0.0;

    AjPStr      m 		= NULL;	/*Passed as arg but not used here*/
    AjPStr      n 		= NULL;	/*Passed as arg but not used here*/

    AjPSeq      *inseqs  	= NULL;	/*Array containing input sequences*/
    AjPInt      lens     	= NULL;	/*1: Lengths of sequences* in input list*/
    AjPFloat2d  scores  	= NULL;
    AjPSeqCvt   cvt      	= 0;
    AjBool      show     	= ajFalse; /*Passed as arg but not used here*/





    /*Intitialise variables*/
    AJCNEW(path, maxarr);
    AJCNEW(compass, maxarr);
    m = ajStrNew();    
    n = ajStrNew();    
    gapopen   = ajRoundF(gapopen,8);
    gapextn = ajRoundF(gapextn,8);
    sub = ajMatrixfArray(submat);
    cvt = ajMatrixfCvt(submat);

    
    /*Convert the AjPList to an array of AjPseq*/
    if(!(nin=ajListToArray(seedlist,(void ***)&inseqs)))
    {
	ajWarn("In sigplot_SeedIdCalc zero sized list of sequences passed into SeqsetNR");
	AJFREE(compass);
	AJFREE(path);
	ajStrDel(&m);
	ajStrDel(&n);
	return ajFalse;
    }

  
    /*Create an ajint array to hold lengths of sequences*/
    lens = ajIntNewL(nin);     
    for(x=0; x<nin; x++)
	ajIntPut(&lens,x,ajSeqLen(inseqs[x]));


    /*Create a 2d float array to hold the similarity scores*/
    scores = ajFloat2dNew();   


    /* Assign array values to zero */
    for(x=0;x<nin;x++)
	for(y=0;y<nin;y++)
	    ajFloat2dPut(&scores, x, y, 0.0);



    /*Start of main application loop*/
    for(x=0; x<nin; x++)       
    { 
	for(y=x+1; y<nin; y++) 
	{
	    /*Process w/o alignment identical sequences*/       
	    if(ajStrMatch(inseqs[x]->Seq, inseqs[y]->Seq))
	    {
		ajFloat2dPut(&scores,x,y,(float)100.0);
		ajFloat2dPut(&scores,y,x,(float)100.0);
		continue;
	    } 
	    
	    
	    /* Intitialise variables for use by alignment functions*/       
	    len = ajIntGet(lens,x)*ajIntGet(lens,y);

	    if(len>maxarr)
	    {
		AJCRESIZE(path,len);
		AJCRESIZE(compass,len);
		maxarr=len;
	    }
                                       
	    p = ajSeqChar(inseqs[x]); 
	    q = ajSeqChar(inseqs[y]); 

	    ajStrAssC(&m,"");
	    ajStrAssC(&n,"");


	    /* Check that no sequence length is 0 */
	    if((ajIntGet(lens,x)==0)||(ajIntGet(lens,y)==0))
	    {
		ajWarn("In sigplot_SeedIdCalc zero length sequence in SeqsetNR");
		AJFREE(compass);
		AJFREE(path);
		ajStrDel(&m);
		ajStrDel(&n);
		ajFloat2dDel(&scores);
		ajIntDel(&lens);
		AJFREE(inseqs);
                                           
		return ajFalse;
	    }

	    /* Call alignment functions */
	    embAlignPathCalc(p,q,ajIntGet(lens,x),ajIntGet(lens,y), gapopen,
			     gapextn,path,sub,cvt,compass,show);

	    embAlignScoreNWMatrix(path,inseqs[x],inseqs[y],sub,cvt,
				  ajIntGet(lens,x), ajIntGet(lens,y),gapopen,
				  compass,gapextn,&start1,&start2);

	    embAlignWalkNWMatrix(path,inseqs[x],inseqs[y],&m,&n,
				 ajIntGet(lens,x),ajIntGet(lens,y),
				 &start1,&start2,gapopen,gapextn,cvt,
				 compass,sub);

	    embAlignCalcSimilarity(m,n,sub,cvt,ajIntGet(lens,x),
				   ajIntGet(lens,y),&id,&sim,&idx, &simx);
	    
	    /* Write array with score*/
	    ajFloat2dPut(&scores,x,y,sim);
	    ajFloat2dPut(&scores,y,x,sim);
	    /*ajFmtPrint("%8.3f%8.3f%8.3f%8.3f\n", id, idx, sim, simx);*/
	}
    }

    /* Write output file */


/*    ajFmtPrint("%S\n", alg->Class);*/

/*    ajFmtPrintF(matrixout, "CL   %S\n", alg->Class);
    printf("seedidcalc 8b x = %d\n", x);
    ajFmtPrintF(matrixout, "XX\n");
    ajFmtPrintF(matrixout, "FO   %S\n", alg->Fold);
    ajFmtPrintF(matrixout, "XX\n");
    ajFmtPrintF(matrixout, "SF   %S\n", alg->Superfamily);
    ajFmtPrintF(matrixout, "XX\n");
    ajFmtPrintF(matrixout, "FA   %S\n", alg->Family);
    ajFmtPrintF(matrixout, "XX\n");
    ajFmtPrintF(matrixout, "SI   %d\n", alg->Sunid_Family);
    ajFmtPrintF(matrixout, "XX\n");
    ajFmtPrintF(matrixout, "------------\n");
    ajFmtPrintF(matrixout, "Seed Id Data\n");
    ajFmtPrintF(matrixout, "------------\n");
    
    printf("seedidcalc 9 x = %d\n", x);
    ajFmtPrintF(matrixout, "      "); 

    for(x=0;x<nin;x++)
	ajFmtPrintF(matrixout, "%8S", alg->Codes[x]);

    ajFmtPrintF(matrixout, "\n");
    */


    for(x=0;x<nin;x++)
    {
	ajFmtPrintF(matrixout, "%7S", alg->Codes[x]);
	for(y=0;y<nin;y++)
	{
	    if(y == 0)
		ajFmtPrintF(matrixout,"%6.2f", ajFloat2dGet(scores, x, y));
	    else
		ajFmtPrintF(matrixout,"%8.2f", ajFloat2dGet(scores, x, y));
	}
	ajFmtPrintF(matrixout, "\n");
    }

    /* Write line to file */
    for(x=0;x<(6+(nin * 8));x++)
	ajFmtPrintF(matrixout, "-");

    ajFmtPrintF(matrixout, "\n");


    /* Calculate individual average */
    for(x=0;x<nin;x++)
    {
	av_temp = 0.0;
	for(y=0;y<nin;y++)
	{
	    av_temp += ajFloat2dGet(scores, x, y); 
	}
	if(x == 0)
	{
	    ajFmtPrintF(matrixout, "av.id");
	    ajFmtPrintF(matrixout, "%8.2f", (av_temp/(float)(nin - 1))); 	    
	}
	else
	    ajFmtPrintF(matrixout, "%8.2f", (av_temp/(float)(nin - 1))); 
    }    

    ajFmtPrintF(matrixout, "\n");

    /* Write line to file */	
    for(x=0;x<(6+(nin * 8));x++)
	ajFmtPrintF(matrixout, "-");

    ajFmtPrintF(matrixout, "\n");

    
    av_temp = 0.0;
    
    /* Calculate overall average */
    for(x=0;x<nin;x++)
	for(y=0;y<nin;y++)
	    av_temp += ajFloat2dGet(scores, x, y); 

    ajFmtPrintF(matrixout, "overall average id = %.2f\n", (av_temp/(float)((nin * nin) - nin))); 	    
  
                               
    /* Tidy up */
    AJFREE(compass);
    AJFREE(path);
    ajStrDel(&m);
    ajStrDel(&n);
    ajFloat2dDel(&scores);
    ajIntDel(&lens);
    AJFREE(inseqs);
    
                               
    /* Bye Bye */
    return ajTrue;
}    




/* @func sigplot_HitIdCalc***************************************************
**
** @param [r] alignfile   [AjPFile]     File pointer to alignment file
** @param [r] submat      [AjPMatrixf]  Pointer to subsitiutionmatrix
** @param [r] gapopen     [float]       Gap opening penalty
** @param [r] gapextn     [float]       Gap extension penalty
** @param [r] matrixout   [AjPFile]     Pointer to output file for %id matrix
** 
** @return [AjBool] 
** @@
******************************************************************************/
AjBool  sigplot_HitIdCalc(AjPList seedlist, AjPList hitlist, AjPScopalg alg, 
			  AjPFile matrixout, AjPMatrixf submat, float gapopen, 
			  float gapextn, AjPStr **codes, AjPInt rank) 
{
    ajint       start1  	= 0;  	/*Start of seq 1, passed as arg but not used*/
    ajint       start2  	= 0;  	/*Start of seq 2, passed as arg but not used*/
    ajint  	maxarr  	= 300; 	/*Initial size for matrix*/
    ajint 	len;
    ajint     	x;			/*Counter for seq 1*/
    ajint    	y;			/*Counter for seq 2*/ 
    ajint   	nin;			/*Number of sequences in input list*/
    ajint	hitn;
    ajint     	*compass;
    ajint	num		= 0;
    

    char       	*p;
    char       	*q;

    float     **sub;
    float       id       	= 0.; 	/*Passed as arg but not used here*/
    float       sim      	= 0.;   
    float       idx      	= 0.;  	/*Passed as arg but not used here*/
    float       simx     	= 0.;  	/*Passed as arg but not used here*/
    float      *path;
    float      	av_temp		= 0.0;

    AjPStr      m 		= NULL;	/*Passed as arg but not used here*/
    AjPStr      n 		= NULL;	/*Passed as arg but not used here*/

    AjPSeq      *seedseqs  	= NULL;	/*Array containing input sequences*/
    AjPSeq      *hitseqs  	= NULL;	/*Array containing input sequences*/
    AjPInt      seedlens     	= NULL;	/*1: Lengths of sequences* in input list*/
    AjPInt      hitlens     	= NULL;	/*1: Lengths of sequences* in input list*/
    AjPFloat2d  scores  	= NULL;
    AjPSeqCvt   cvt      	= 0;
    AjBool      show     	= ajFalse; /*Passed as arg but not used here*/




    /*Intitialise variables*/
    AJCNEW(path, maxarr);
    AJCNEW(compass, maxarr);
    m = ajStrNew();    
    n = ajStrNew();    
    gapopen   = ajRoundF(gapopen,8);
    gapextn = ajRoundF(gapextn,8);
    sub = ajMatrixfArray(submat);
    cvt = ajMatrixfCvt(submat);

    
    /*Convert the AjPList to an array of AjPseq*/
    if(!(nin=ajListToArray(seedlist,(void ***)&seedseqs)))
    {
	ajWarn("1 In sigplot_HitIdCalc zero sized list of sequences passed into SeqsetNR");
	AJFREE(compass);
	AJFREE(path);
	ajStrDel(&m);
	ajStrDel(&n);
	return ajFalse;
    }

    /*Convert the AjPList to an array of AjPseq*/
    if(!(hitn=ajListToArray(hitlist,(void ***)&hitseqs)))
    {
	ajWarn("2 In sigplot_HitIdCalc zero sized list of sequences passed into SeqsetNR");
	AJFREE(compass);
	AJFREE(path);
	ajStrDel(&m);
	ajStrDel(&n);
	return ajFalse;
    }

                               
    /*Create an ajint array to hold lengths of sequences*/
    seedlens = ajIntNewL(nin);     
    for(x=0; x<nin; x++)
	ajIntPut(&seedlens,x,ajSeqLen(seedseqs[x]));

    /*Create an ajint array to hold lengths of sequences*/
    hitlens = ajIntNewL(hitn);     
    for(x=0; x<hitn; x++)
	ajIntPut(&hitlens,x,ajSeqLen(hitseqs[x]));


    /*Create a 2d float array to hold the similarity scores*/
    scores = ajFloat2dNew();   

    /* Assign array values to zero */
    for(x=0;x<hitn;x++)
	for(y=0;y<nin;y++)
	    ajFloat2dPut(&scores, x, y, 0.0);

    


    /*Start of main application loop*/
    for(x=0; x<hitn; x++)       
    { 
	num++;
	for(y=0; y<nin; y++) 
	{
	    /* Process identical sequences */       
	    if(ajStrMatch(hitseqs[x]->Seq, seedseqs[y]->Seq))
	    {
		ajFloat2dPut(&scores,x,y,(float)100.0);
		/*ajFloat2dPut(&scores,y,x,(float)100.0);*/
		continue;
	    } 

	    /* Intitialise variables for use by alignment functions*/       
	    len = ajIntGet(hitlens,x)*ajIntGet(seedlens,y);

	    if(len>maxarr)
	    {
		AJCRESIZE(path,len);
		AJCRESIZE(compass,len);
		maxarr=len;
	    }
                                       
	    p = ajSeqChar(hitseqs[x]); 
	    q = ajSeqChar(seedseqs[y]); 

	    ajStrAssC(&m,"");
	    ajStrAssC(&n,"");

/*	    ajFmtPrint("%S = %S\n", (*codes)[x], hitseqs[x]->Seq);*/

	    /* Check that no sequence length is 0 */
	    if((ajIntGet(hitlens,x)==0)||(ajIntGet(seedlens,y)==0))
	    {
		/*ajFmtPrint("hitlens[%d] = %d, seedlens[%d] = %d\n", x, ajIntGet(hitlens, x),
			   y, ajIntGet(seedlens, y));*/

		ajWarn("3 In sigplot_HitIdCalc zero length sequence in SeqsetNR hit");
		AJFREE(compass);
		AJFREE(path);
		ajStrDel(&m);
		ajStrDel(&n);
		ajFloat2dDel(&scores);
		ajIntDel(&seedlens);
		ajIntDel(&hitlens);
		AJFREE(seedseqs);
		AJFREE(hitseqs);
                                           
		return ajFalse;
	    }


	    /* Call alignment functions */
	    embAlignPathCalc(p,q,ajIntGet(hitlens,x),ajIntGet(seedlens,y), gapopen,
			     gapextn,path,sub,cvt,compass,show);

	    embAlignScoreNWMatrix(path,hitseqs[x],seedseqs[y],sub,cvt,
				  ajIntGet(hitlens,x), ajIntGet(seedlens,y),gapopen,
				  compass,gapextn,&start1,&start2);

	    embAlignWalkNWMatrix(path,hitseqs[x],seedseqs[y],&m,&n,
				 ajIntGet(hitlens,x),ajIntGet(seedlens,y),
				 &start1,&start2,gapopen,gapextn,cvt,
				 compass,sub);

	    embAlignCalcSimilarity(m,n,sub,cvt,ajIntGet(hitlens,x),
				   ajIntGet(seedlens,y),&id,&sim,&idx, &simx);
	    
	    
	    /* Write score to array */
	    ajFloat2dPut(&scores,x,y,sim);
	    /*ajFmtPrint("%8.3f%8.3f%8.3f%8.3f\n", id, idx, sim, simx);*/
	}
    }


    /* Write output file */

    ajFmtPrintF(matrixout, "//\n-------------------------\n");
    ajFmtPrintF(matrixout, "True Hit and Seed Id Data\n");
    ajFmtPrintF(matrixout, "-------------------------\n");
    ajFmtPrintF(matrixout, "            ");
    for(x=0;x<nin;x++)
	ajFmtPrintF(matrixout, "%8S", alg->Codes[x]);
    ajFmtPrintF(matrixout, "  av. id\n");
    

    for(x=0;x<hitn;x++)
    {
	av_temp = 0.0;
	
	ajFmtPrintF(matrixout, "%S%5d", (*codes)[x], (ajIntGet(rank,x)+1));
	for(y=0;y<nin;y++)
	{
	    ajFmtPrintF(matrixout,"%8.2f", ajFloat2dGet(scores, x, y));
	    av_temp += ajFloat2dGet(scores, x, y); 
	}
	
	/* Print average id of hit to all seeds to output file */
	ajFmtPrintF(matrixout, "%8.2f\n", (av_temp) / (float)nin);
    }

    ajFmtPrintF(matrixout, "//");
    
                               
    /* Tidy up */
    AJFREE(compass);
    AJFREE(path);
    ajStrDel(&m);
    ajStrDel(&n);
    ajFloat2dDel(&scores);
    ajIntDel(&seedlens);
    ajIntDel(&hitlens);

    AJFREE(seedseqs);
    AJFREE(hitseqs);
                               
    /* Bye Bye */
    return ajTrue;
}    




/* @func sigplot_ScopdataNew ***********************************************************
**
** Scopdata object constructor.
**
** 
** @return [AjPScopdata] Pointer to a Scopdata object
** @@
******************************************************************************/
AjPScopdata  sigplot_ScopdataNew()
{
    AjPScopdata ret = NULL;
    

    AJNEW0(ret);
    ret->Class=ajStrNew();
    ret->Fold=ajStrNew();
    ret->Superfamily=ajStrNew();
    ret->Family=ajStrNew();
    ret->file_name=ajStrNew();
    ret->Sunid = 0;
    ret->num_true = 0;
    ret->file_hitnum = 0;
    return ret;
}


/* @func sigplot_ScopdataDel *******************************************************
**
** Destructor for Scopdata object.
**
** @param [w] pthis [AjPScopdata*] Scopdata object pointer
**
** @return [void]
** @@
******************************************************************************/
void sigplot_ScopdataDel(AjPScopdata *pthis)
{

    ajStrDel(&(*pthis)->Class);
    ajStrDel(&(*pthis)->Fold);
    ajStrDel(&(*pthis)->Superfamily);
    ajStrDel(&(*pthis)->Family);
    ajStrDel(&(*pthis)->file_name);

    
    AJFREE(*pthis);
    *pthis=NULL;
    
    /* return */
    return;
}



 















