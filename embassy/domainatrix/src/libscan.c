/* @source libscan application
 **
 ** Scans each signature, profile or HMM in a directory against 
 ** swissprot and writes a signature hits file for each one. Or 
 ** scans sequences against such a library of discriminating 
 ** elements and writes a library scan file for each one.
 **
 ** @author: Copyright (C) Ranjeeva Ranasinghe (rranasin@hgmp.mrc.ac.uk)
 ** @author: Copyright (C) Jon Ison (jison@hgmp.mrc.ac.uk)
 ** @@
 **
 ** This program is free software; you can redistribute it and/or
 ** modify it under the terms of the GNU General Public License
 ** as published by the Free Software Foundation; either version 2
 ** of the License, or (at your option) any later version.
 ** 
 ** This program is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU General Public License for more details.
 ** 
 ** You should have received a copy of the GNU General Public License
 ** along with this program; if not, write to the Free Software
 ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 **
 **/

/******************************************************************************
**  Application name
**  libscan
**  
**  
**  
**  Summary
**  Scans each signature, profile or HMM in a directory against a sequence 
**  database and writes a signature hits file for each one. Or scans sequences 
**  against such a library of discriminating elements and writes a library scan 
**  file for each one.
** 
**  
**   
**  Input and Output
**  libscan runs in one of two modes either (i) database search mode or (ii) 
**  library screen mode. In database search mode libscan reads one or more
**  directories each containing a single type of discriminating element, the
**  permitted types are sparse sequence signature, Gribskov profile, Henikoff
**  profile or hidden Markov model.  Each directory must contain a 
**  discriminating element for each of one or more scop families; files for
**  indivdual families should have the same name (possibly with different file
**  extensions) in the different directories, e.g. the scop family with the
**  identifier 46445 might be represented by files 46445.hmm, 46445.sig, 
**  46445.gribs and 46445.henik in their respective directories.  libscan scans
**  each discriminating element against a sequence set that must also be 
**  provided by the user and generates a signature hits file (of scored hits 
**  to sequences in the set) for each individual discriminating element.  In 
**  mode (i), the user must also provide a scop validation file so that a 
**  classification of hits can be given in the signature hits files.  The user
**  specifies a maximum number of false hits that are written to the signature
**  hits files.
**  In library screen mode, libscan
**  reads a sequence set, screens each sequence against the library 
**  (directories of discriminating elements) and writes a library scan file
**  (of top-scoring families) for each sequence.  In either mode, a scop 
**  classification file is required as a source of family classification data.
**  The paths and extensions of the sequence set and scop classification files
**  (input) different types of discriminating elements (input), and paths and
**  extension of signature hits files or library scan file (output) are 
**  specified by the user.
** 
**  
**
**  Sister applications
**  Hidden Markov models can be generated for scop families by using hmmgen 
**  which uses the HMMER package.
**  Simple frequency matrices, Gribskov profiles and Hennikoff profiles can be 
**  generated for scop families by using profgen.
**  A 'signature file' contains a sparse sequence signature.  The files are 
**  generated by siggen.
**  A 'signature hits file' contains the results of a search of a 
**  discriminating element (one of protein signature, hidden Markov model, 
**  simple frequency matrix, Gribskov profile or Hennikoff profile) against a 
**  sequence database.  The files are generated by sigscan and modelscan.
**  A 'library scan file' holds the results of a search of a sequence against a
**  library of discriminating elements for scop families (one directory for 
**  each type of element, e.g. sparse sequence signatures, profiles or HMMs). 
**  The library scan file contains, for each invividual type of discriminating
**  element and for the combination of the elements, classification and other 
**  data for each of a user-defined number of top-scoring families 
**  (discriminators) from the scop database.
**  A 'scop classification file' contains classification and other data for 
**  domains from the scop database.  The file is in embl-like format and is 
**  generated by scopparse.  Domain sequence information can be added to the 
**  file by using scopseqs.
**  A 'scop validation file' contains sequence relatives (hits) for each of a
**  number of different scop families, superfamilies and folds.  The file 
**  contains the collated results from psiblast searches of a sequence database
**  for the indvidual scop families; hits of unambiguous family assignment are
**  listed under their respective family, otherwise a hit is assigned as 
**  relatives to a scop superfamily or fold instead.  The scop validation file
**  is generated by seqnr and is in embl-like format.
**  
**  
**  
**  Notes
**  
**  
**  
**  Known bugs & warnings
**  The score distributions and therefore p-values are calculated only from the
**  data that libscan is provided.  Therefore, meaningful p-values are only 
**  guaranteed if the sequence set (database search mode) or number of families 
**  (library screeen mode) is sufficiently large.
**  
**  
**  
**  Description
**  This program is part of a suite of EMBOSS applications that directly or 
**  indirectly make use of the protein structure databases pdb and scop.  
**  This program is part of an experimental analysis pipeline described in an
**  accompanying document.  We provide the software in the hope that it will
**  be useful.  The applications were designed for specific research purposes
**  and may not be useful or reliable in contexts other than the described 
**  pipeline.  The development of the suite was coordinated by Jon Ison to
**  whom enquiries and bug reports should be sent (email jison@hgmp.mrc.ac.uk).
**  
**  The advantage of screening a relatively small library of discriminating 
**  elements with a sequence is that it is sufficient for the sequence to 
**  detect its true family (discriminator) in the first rank for an effective
**  prediction.  This is in contrast to searching a larger sequence database to
**  identify homology, where biologically significant hits may achieve 
**  statistically insignificant scores and therefore be missed.  A library 
**  might help the detection of such proteins because they may still score 
**  their true discriminator higher than the others in the library regardless
**  of statistical estimates.  Further improvements to predictions are gained
**  when multiple sources of evidence, in this case the different types of
**  discriminating element, are considered.  
**  The libscan application allows a protein sequence or sequences to be 
**  screened against the library of discriminating elements.  The results of a
**  screen are returned to the user in a library scan file containing a list 
**  of top-scoring SCOP domains rank-ordered by p-value for each individual 
**  type of discriminator, and also for all of the discriminator types in 
**  combination (combined prediction).  For the combined prediction, the 
**  p-value is derived from an empirically derived distribution of the product
**  of the p-values of the individual methods.  
**  
**  
**  
**  Algorithm
**  The approach for calculating p-values for individual discriminator-sequence
**  matches is the same irrespective of which mode libscan is run in and is
**  summarised as follows: (i) Each discriminating element is scanned (scored)
**  against each sequence.  (ii) The ditribution of scores is generated for 
**  each different type of element.  (iii) Using these distributions, a p-value
**  is calculated for each discriminator-sequence match.  
**  The approach for calculating the 'combined p-value' for each individual 
**  sequence is as follows: (i) p-values of the matches for the different types
**  of discriminator versus a sequence are multiplied to yield the 'product of
**  p-values'.  (ii) A distribution of 'product of p-values' is generated for
**  each individual sequence.  (iii) Using these distributions, a so-called 
**  'combined p-value', reflecting the overall significance of the matches of
**  the sequence to the different types of discriminators, is generated. 
**  Importantly, two (or more) p-values are only ever multiplied together if 
**  corresponding hit is to the same region of the protein.  'Same' is defined
**  as two hits overlapping by a user-defined number of residues.
**
**  
**  
**  Usage 
**  An example of interactive use of XXXXXXXX is shown below.
**  Unix % 
**  Unix % libscan
**  Scans a database with a set of models that represents a family
**  The scanning modes
**           1 : Database search mode
**           2 : Library screen mode
**  Select mode of operation [1]: 2
**  File containing sequences to search or screen [/libscan/MHC_Ig.seqs]: 
**  Use Gribskov profile [Y]: 
**  Use Henikoff profile [Y]: 
**  Use HMM profile [Y]: 
**  Use signature [Y]: 
**  Location of HMM profile files (input) [/libscan/hmm]: 
**  Extension of HMM profile files (input) [.hmm]: 
**  Location of signature hits/library scan files for hmm searches (output) [/libscan/hmmout]: 
**  Extension of signature hits/library scan files for hmm searches (output) [.hmmout]: 
**  Location of Gribskov profile files (input) [/libscan/grib]: 
**  Extension of Gribskov profile files (input) [.gribs]: 
**  Gap insertion penalty [1.0]: 
**  Gap extension penalty [1.0]: 
**  Location of signature hits/library scan files for Gribskov profile searches (output) [/libscan/gribout]: 
**  Extension of signature hits/library scan files for Gribskov profile searches (output) [.gribout]: 
**  Location of Hennikoff profile files (input) [/libscan/henik]: 
**  Extension of Hennikoff profile files (input) [.henik]: 
**  Gap insertion penalty [1.0]: 
**  Gap extension penalty [1.0]: 
**  Location of signature hits/library scan files for Henikoff profile searches (output) [/libscan/henikout]: 
**  Extension of signature hits/library scan files for Henikoff profile searches (output) [.henikout]: 
**  Location of signature files (input) [/libscan/sig]: 
**  Extension of signature files (input) [.sig]: 
**  N-terminal matching options
**           1 : Align anywhere and allow only complete signature-sequence fit
**           2 : Align anywhere and allow partial signature-sequence fit
**           3 : Use empirical gaps only
**  Select number [1]: 
**  Residue substitution matrix [EBLOSUM62]: 
**  Gap insertion penalty [10.0]: 
**  Gap extension penalty [0.5]: 
**  Location of signature hits/library scan files for signature searches (output) [/libscan/sigout]: 
**  Extension for signature hits/library scan files for signature searches (output) [.sigout]: 
**  SCOP classification file (input) [/libscan/scop_classification]: 
**  The maximum number of hits to be written to the signature hits file. [50]: 
**  Location of signature hits / library scan files for merged results (output) [/libscan/mrgout/]: 
**  Extension for signature hits / library scan files for merged results (output) [.mrgout]: 
**  
**  Gapped alignment for profiles
**  Gapped alignment for profiles
**  Gapped alignment for profiles
**  Gapped alignment for profiles
**  Gapped alignment for profiles
**  Gapped alignment for profiles
**  Gapped alignment for profiles
**  Gapped alignment for profiles
**  Signature file read ok
**  Signature compiled ok
**  Signature file read ok
**  Signature compiled ok
**  Signature file read ok
**  Signature compiled ok
**  Signature file read ok
**  Signature compiled ok
**  Unix % 
**  
**  
**  The following command line would achieve the same result.
**  libscan -mode 2 -db /libscan/MHC_Ig.seqs -grib -henik -hmm -sig -hmmpath 
**  /libscan/hmm -hmmextn .hmm -hmmoutpath /libscan/hmmout -hmmoutextn .hmmout
**  -gbvpath /libscan/grib -gbvextn .gribs -gbvgapo 1 -gbvgape 1 -gbvoutpath 
**  /libscan/gribout -gbvoutextn .gribout -hnfpath /libscan/henik -hnfextn 
**  .henik -hnfgapo 1 -hnfgape 1 -hnfoutpath /libscan/henikout -hnfoutextn 
**  .henikout -nterm 1 -sub EBLOSUM62 -sigpath /libscan/sig -sigextn .sig 
**  -siggapo 10 -siggape 0.5 -sigoutpath /libscan/sigout -sigoutextn .sigout
**  -scopf /libscan/scop_classification -overlap 10 -mrgoutpath /libscan/mrgout 
**  -mrgoutextn .mrgout
**
**  libscan was run in library screen mode and screened each sequence in the 
**  sequence database /libscan/MHC_Ig.seqs against a library of models 
**  comprising sparse sequence signatures, Gribskov profiles, Henikoff 
**  profiles and hidden Markov model.  The appropriate files were kept in the
**  directories /libscan/sig, /libscan/grib, /libscan/henik and /libscan/hmm 
**  and had the file extensions .sig, .gribs, .henik and .hmm respectively.
**  The library scan files were written to the directories /libscan/sigout, 
**  /libscan/gribout, /libscan/henikout and /libscan/hmmout and had the file
**  extensions .sigout, .gribout, .henikout and .hmmout respectively.  The 
**  gap insertion and extension penalties for matches of Gribskov profiles 
**  to sequences were both 1.0.   The gap insertion and extension penalties
**  for matches of sparse sequence signatures to sequences were 10.0 and 0.5 
**  respectively, the EBLOSUM62 residue substitution matrix was used.  The 
**  N-terminal matching option was set to 1 meaning that the N-terminal 
**  signature position could be aligned anywhere without penalty and that 
**  only complete signature-sequence fits are allowed.  SCOP family 
**  classification data were taken from the SCOP classification file 
**  /libscan/scop_classification.  Library scan files representing the merged
**  results of the different types of discriminating elements were written to
**  the directory /libscan/mrgout and had the file extension .mrgout.
**  
**  
**  
**  Input file format
**  The format of the scop classification file is described in scopparse.c
**  The format of the signature files is explained in siggen.c
**  The format of the profile and hmm files is explained in documentation for 
**  the propechy application and the hmmer package respectively.
**  
**  
**  
**  Output file format
**  The format of the signature hits file is described in sigscan.c 
**  
**  
**  
**  Data files
**  libscan requires a residue substitution matrix. 
**  
**  
**  
**  Diagnostic error messages
**  
**  
**  
**  Authors
**  Ranjeeva Ranasinghe (rranasin@hgmp.mrc.ac.uk)  
**  Jon Ison (jison@hgmp.mrc.ac.uk)
**  
**  
**  
**  References
**  Please cite the authors.
**  Related references are given below.
**  
**  
**  
******************************************************************************/




#include "emboss.h"


/* @data LibscanPCoord *******************************************************
**
** Undocumented
**
** @alias LibscanOCoord
** @alias LibscanSCoord
**
******************************************************************************/

typedef struct LibscanSCoord
{
    AjPStr   Class;        /* SCOP class */
    AjPStr   Fold;         /* SCOP fold */
    AjPStr   Superfamily;  /* SCOP superfamily */
    AjPStr   Family;       /* SCOP family */
    ajint    Sunid_Family; /* the sun_id for a given SCOP family */
    AjPStr   Model_Type;   /* The type of model used to generate the scores */
    AjPStr   Acc;          /* Accession number of sequence entry  */
    AjPStr   Spr;          /* Swissprot code of sequence entry */
    ajint    x;            /* The score interval */
    ajint    y;            /* Frequency of scores */
} LibscanOCoord, *LibscanPCoord;


static ajint libscan_CoordBinSearchScore(float score, LibscanPCoord *arr,
					 ajint siz);
static float libscan_ScoreToPvalue (float score, AjPList list);
static AjBool libscan_SunidToScopInfo (ajint sunid, AjPStr *family,
				       AjPStr *superfamily, AjPStr *fold,
				       AjPStr *klass, AjPList list);
static void libscan_CoordDel(LibscanPCoord *pthis);
static LibscanPCoord libscan_CoordNew(void);

static AjBool libscan_HmmSearch(AjPSeqset db, AjPStr hmmfile,
				AjPList targetlist, AjPStr family,
				AjPStr superfamily, AjPStr fold, AjPStr class,
				ajint sun_id, ajint overlap, ajint maxhits,
				AjPStr model, AjPFile outf, AjPList* mrglist);
static AjBool libscan_ProfileSearch(AjPSeqset db, AjPStr profile,
				    float gapopen, float gapextn,
				    AjPList targetlist, AjPStr family,
				    AjPStr superfamily, AjPStr fold,
				    AjPStr class, ajint sun_id, ajint overlap, 
				    ajint maxhits, AjPStr model, AjPFile outf,
				    AjPList* mrglist);
static AjBool libscan_SignatureSearch(AjPSeqset db, AjPStr sigfile,
				      AjPMatrixf sub, float gapo, float gape,
				      ajint ntop, AjPList targetlist,
				      AjPStr family, AjPStr superfamily,
				      AjPStr fold, AjPStr class, 
				      ajint sun_id, ajint overlap,
				      ajint maxhits, AjPStr model,
				      AjPFile outf, AjPList* mrglist);

static AjBool libscan_ProfileLibScan(AjPSeq seq, AjPStr path, AjPStr extn,
				     float gapopen, float gapextn,
				     AjPList scoplist, AjPStr model,
				     AjPStr profoutpath, AjPStr profoutextn,
				     AjPList* mrglist);
static AjBool libscan_SignatureLibScan(AjPSeq seq, AjPStr path, AjPStr extn,
				       float gapopen,float gapextn,
				       AjPMatrixf sub,ajint ntopt, 
				       AjPList scoplist, AjPStr model,
				       AjPStr sigoutpath, AjPStr sigoutextn,
				       AjPList* mrglist);
static AjBool libscan_HmmLibScan(AjPSeq seq, AjPStr hmmpath, AjPStr hmmextn,
				 AjPList scoplist, AjPStr model,
				 AjPStr hmmoutpath, 
				 AjPStr hmmoutextn,AjPList* mrglist);

static AjBool libscan_RunHmmsearch(AjPStr filename, AjPStr db,
				   AjPStr outfname);
static AjBool libscan_RunProphet(AjPStr profile, AjPStr db,
				 float gapopen, float gapextend,
				 AjPStr outfname);

static AjPList libscan_GetLibrary(AjPStr path, AjPStr extn);

static AjBool libscan_CombineScophitsPvalues(ajint mode, AjPStr outpath,
					     AjPStr outextn,
					     AjPList targetlist,
					     AjPList mrglist, ajint overlap,
					     ajint maxhits, ajint n);


static AjPList libscan_CalcDistribution(AjPList listhits, AjPStr class,
					AjPStr fold, AjPStr superfamily,
					AjPStr family, ajint sun_id);




static AjBool libscan_RunHmmerInModeOne(AjPSeqset db, AjPStr hmmpath,
					AjPStr hmmextn, AjPStr *mode,
					ajint overlap, ajint maxhits,
					AjPStr model, AjPList targetlist,
					AjPList scoplist, AjPStr hmmoutpath,
					AjPStr hmmoutextn, AjPList* mrglist);
static AjBool libscan_RunHmmerInModeTwo(AjPSeqset db, AjPStr hmmpath,
					AjPStr hmmextn, AjPStr *mode,
					AjPList scoplist, AjPStr model, 
					AjPStr hmmoutpath, AjPStr hmmoutextn,
					AjPList* mrglist);

static AjBool libscan_RunProphetInModeOne(AjPSeqset db, AjPStr profpath,
					  AjPStr profextn, float gapo,
					  float gape, AjPStr *mode,
					  ajint overlap, ajint maxhits, 
					  AjPStr model, AjPList targetlist,
					  AjPList scoplist,AjPStr profoutpath,
					  AjPStr profoutextn,
					  AjPList* mrglist);
static AjBool libscan_RunProphetInModeTwo(AjPSeqset db, AjPStr profpath,
					  AjPStr profextn, float gapo,
					  float gape, AjPStr *mode,
					  AjPList scoplist, 
					  AjPStr model, AjPStr profoutpath,
					  AjPStr profoutextn,
					  AjPList* mrglist);

static AjBool libscan_RunSignatureInModeOne(AjPSeqset db, AjPStr sigpath,
					    AjPStr sigextn, float gapo,
					    float gape, AjPMatrixf sub,
					    ajint ntopt, AjPStr *mode,
					    ajint overlap, ajint maxhits,
					    AjPStr model, AjPList targetlist,
					    AjPList scoplist,
					    AjPStr sigoutpath, 
					    AjPStr sigoutextn,
					    AjPList* mrglist);
static AjBool libscan_RunSignatureInModeTwo(AjPSeqset db, AjPStr sigpathpath,
					    AjPStr sigextn, float gapo,
					    float gape, AjPMatrixf sub,
					    ajint ntopt, AjPStr *mode,
					    AjPList scoplist, AjPStr model,
					    AjPStr sigoutpath,
					    AjPStr sigoutextn,
					    AjPList* mrglist);

static AjPList libscan_CalcLibscanDistribution(AjPList scophits);



int main(int argc, char **argv)
{
    AjPStr hmmpath     = NULL;		/* Directory of hmm models. */
    AjPStr hmmextn     = NULL;		/* File extension of models. */

    AjPStr gbvpath     = NULL;		/* Directory of gribskov profile models.  */
    AjPStr gbvextn     = NULL;		/* File extension of models. */

    AjPStr hnfpath     = NULL;		/* Directory of henikoff profile models.*/
    AjPStr hnfextn     = NULL;		/* File extension of models. */

    AjPStr sigpath     = NULL;		/* Directory of signatures.*/
    AjPStr sigextn     = NULL;		/* File extension of signatures */

    AjPStr hmmoutpath  = NULL;
    AjPStr gbvoutpath  = NULL;
    AjPStr hnfoutpath  = NULL;
    AjPStr sigoutpath  = NULL;
    AjPStr mrgoutpath  = NULL;
    AjPStr outpath     = NULL;
    

    AjPStr hmmoutextn  = NULL;
    AjPStr gbvoutextn  = NULL;
    AjPStr hnfoutextn  = NULL;
    AjPStr sigoutextn  = NULL;
    AjPStr mrgoutextn  = NULL;
    AjPStr outextn     = NULL;
    
    AjPStr model       = NULL;		/* the model type for the Model Record */
  
    AjPStr *nterm      = NULL;		/* Holds N-terminal matching options from acd */
  
    AjPFile scopf      = NULL;
    AjPFile targetf    = NULL;		/* file pointer to validation file */

    AjPSeqset db       = NULL;		/* The database to search */
  
    ajint ntopt    = 0;
    ajint overlap  = 0;
    ajint maxhits  = 0;
    ajint cnt      = 0;			/* keep a track of the model types used */

    float gbvgapo  = 0.0;
    float gbvgape  = 0.0;
    float hnfgapo  = 0.0;
    float hnfgape  = 0.0;
    float siggapo  = 0.0;
    float siggape  = 0.0;
   
    AjPMatrixf sub = NULL;		/* Residue substitution matrix*/

    AjPList scoplist = NULL;		/* List of scop objects. */
    AjPList mrglist  = NULL;

  
    AjPScop entry = NULL;		/* scop object to put on to list */

    AjPScophit delscophit = NULL;
  
    AjIList iter = NULL;

    AjPStr *mode       = NULL;		/* Mode of operation from acd*/

    AjBool  do_grib    = ajFalse;
    AjBool  do_henik   = ajFalse;
    AjBool  do_hmm     = ajFalse;
    AjBool  do_sig     = ajFalse;

    AjPList targetlist = NULL;		/* list of hits in the validation file */
    AjPHitlist targets = NULL;		/* hitlist to hold each family in the validation file */
  

    ajNamInit("emboss");

    ajAcdInitP("libscan",argc,argv,"DOMAINATRIX");
  
    mode        = ajAcdGetList("mode");
    db          = ajAcdGetSeqset("db");
    do_grib     = ajAcdGetBool("grib");
    do_henik    = ajAcdGetBool("henik");
    do_hmm      = ajAcdGetBool("hmm");
    do_sig      = ajAcdGetBool("sig");


    if(do_hmm)
    {
	cnt++;
      
	hmmpath    = ajAcdGetString("hmmpath");
	hmmextn    = ajAcdGetString("hmmextn");
	hmmoutpath = ajAcdGetString("hmmoutpath"); 
	hmmoutextn = ajAcdGetString("hmmoutextn");

	if(ajStrChar(*mode,0)=='1')
	{
	    if((!ajFileDir(&hmmoutpath)))
		ajFatal("Could not open directory");    
	}
    }	

    if(do_grib)
    {
	cnt++;
      
	gbvpath    = ajAcdGetString("gbvpath");

	if((!ajFileDir(&gbvpath)))
	    ajFatal("Could not open directory");    

	gbvextn    = ajAcdGetString("gbvextn");
	gbvgapo    = ajAcdGetFloat("gbvgapo");
	gbvgape    = ajAcdGetFloat("gbvgape");
	gbvoutpath = ajAcdGetString("gbvoutpath");
	gbvoutextn = ajAcdGetString("gbvoutextn");
 
	if(ajStrChar(*mode,0)=='1')
	{
	    if((!ajFileDir(&gbvoutpath)))
		ajFatal("Could not open directory");    
	}
    }

    if(do_henik)
    {
	cnt++;
      
	hnfpath    = ajAcdGetString("hnfpath");
	if((!ajFileDir(&hnfpath)))
	    ajFatal("Could not open directory");    
	hnfextn    = ajAcdGetString("hnfextn");
	hnfgapo    = ajAcdGetFloat("hnfgapo");
	hnfgape    = ajAcdGetFloat("hnfgape");
	hnfoutpath = ajAcdGetString("hnfoutpath"); 
	hnfoutextn = ajAcdGetString("hnfoutextn");

	if(ajStrChar(*mode,0)=='1')
	{
	    if((!ajFileDir(&hnfoutpath)))
		ajFatal("Could not open directory");    
	}
    }

    if(do_sig)
    {
	cnt++;
      
	sigpath    = ajAcdGetString("sigpath");
	if((!ajFileDir(&sigpath)))
	    ajFatal("Could not open directory");    
	sigextn    = ajAcdGetString("sigextn");
	siggapo    = ajAcdGetFloat("siggapo");
	siggape    = ajAcdGetFloat("siggape");
	sub        = ajAcdGetMatrixf("sub");
	nterm      = ajAcdGetList("nterm");
	sigoutpath = ajAcdGetString("sigoutpath"); 
	sigoutextn = ajAcdGetString("sigoutextn");

	/*Assign N-terminal matching option */
	ajFmtScanS(nterm[0], "%d", &ntopt);

	if(ajStrChar(*mode,0)=='1')
	{
	    if((!ajFileDir(&sigoutpath)))
		ajFatal("Could not open directory");    
	}
    }


    if(ajStrChar(*mode,0)=='1')
    {
	targetf = ajAcdGetInfile("targetf");
	maxhits = ajAcdGetInt("maxhits");
    }
    


    mrgoutpath = ajAcdGetString("mrgoutpath"); 
    if((!ajFileDir(&mrgoutpath)))
	ajFatal("Could not open directory");    
    mrgoutextn = ajAcdGetString("mrgoutextn");

  
    overlap     = ajAcdGetInt("overlap");
    scopf       = ajAcdGetInfile("scopf");


    mrglist     = ajListNew();
    scoplist    = ajListNew();

  
    /* create the scop list */
    while((entry = (ajScopReadCNew(scopf, "*"))))
	ajListPushApp(scoplist,(AjPScop)entry); 
    ajFileClose(&scopf);
  
    /*sort scoplist by Sunid_Family prior to binary search*/
    ajListSort(scoplist,ajScopMatchSunid);

    /* Create the target list */
    if(ajStrChar(*mode,0)=='1')
    {
	targetlist = ajListNew();
	while((targets=embHitlistRead(targetf)))
	    ajListPush(targetlist, (AjPHitlist) targets);
	ajFmtPrint("Targets read ok\n");
	ajFileClose(&targetf); 
    }



    model = ajStrNew();

    if(do_hmm)
    {
	ajStrAssC(&model,"HMM");
      
	if(!scoplist)
	    ajFatal("scoplist not good !\n");
      
	if(ajStrChar(*mode,0)=='1')
	    libscan_RunHmmerInModeOne(db,hmmpath,hmmextn,mode,overlap,maxhits,model,targetlist,scoplist,hmmoutpath,hmmoutextn,&mrglist);
	else
	    libscan_RunHmmerInModeTwo(db,hmmpath,hmmextn,mode,scoplist,model,hmmoutpath,hmmoutextn,&mrglist);
    }

    if(do_grib)
    {
	ajStrAssC(&model,"GRIBSKOV");

	if(ajStrChar(*mode,0)=='1')
	    libscan_RunProphetInModeOne(db,gbvpath,gbvextn,gbvgapo,gbvgape,mode,overlap,maxhits,model,targetlist,scoplist,
				     gbvoutpath,gbvoutextn,&mrglist);
	else
	    libscan_RunProphetInModeTwo(db,gbvpath,gbvextn,gbvgapo,gbvgape,mode,scoplist,model,gbvoutpath,gbvoutextn,&mrglist);
    }

    if(do_henik)
    {
	ajStrAssC(&model,"HENNIKOFF");

	if(ajStrChar(*mode,0)=='1')
	    libscan_RunProphetInModeOne(db,hnfpath,hnfextn,hnfgapo,hnfgape,mode,overlap,maxhits,model,targetlist,scoplist,
				     hnfoutpath,hnfoutextn,&mrglist);
	else
	    libscan_RunProphetInModeTwo(db,hnfpath,hnfextn,hnfgapo,hnfgape,mode,scoplist,model,hnfoutpath,hnfoutextn,&mrglist);
    }

    if(do_sig)
    {
	ajStrAssC(&model,"SIGNATURE");

	if(ajStrChar(*mode,0)=='1')
	    libscan_RunSignatureInModeOne(db,sigpath,sigextn,siggapo,siggape,sub,ntopt,mode,overlap,maxhits,model,targetlist, 
				       scoplist,sigoutpath,sigoutextn,&mrglist);
	else
	    libscan_RunSignatureInModeTwo(db,sigpath,sigextn,siggapo,siggape,sub,ntopt,mode,scoplist,model,sigoutpath,
				       sigoutextn,&mrglist);
    }


    if(cnt > 1)
    {
      
	if(ajStrChar(*mode,0)=='1')
	    /* Signature hits files will be written */
	    libscan_CombineScophitsPvalues(1, mrgoutpath, mrgoutextn,
					   targetlist, mrglist, overlap,
					   maxhits, cnt);
	else
	    /*Library scan files will be written */
	    libscan_CombineScophitsPvalues(2, mrgoutpath, mrgoutextn,
					   NULL, mrglist, overlap,
					   maxhits, cnt);

    }
  
    /* clean up the target list */
    if(ajStrChar(*mode,0)=='1')
    {    
	while(ajListPop(targetlist, (void *) &targets))
	    embHitlistDel(&targets);
	ajListDel(&targetlist); 
    }

    /* clean up scoplist */
    iter = ajListIter(scoplist);
    while((entry = (AjPScop)ajListIterNext(iter)))
	ajScopDel(&entry);
    ajListDel(&scoplist);
    ajListIterFree(iter);

    /* clean up mrglist */
    iter = ajListIter(mrglist);
    while((delscophit = (AjPScophit)ajListIterNext(iter)))
	ajDmxScophitDel(&delscophit);
    ajListDel(&mrglist);
    ajListIterFree(iter);


    /* clean up variables */
    if(do_hmm)
    {
	ajStrDel(&hmmpath);
	ajStrDel(&hmmextn);
	if(ajStrChar(*mode,0)=='1')
	{
	    ajStrDel(&hmmoutpath);
	    ajStrDel(&hmmoutextn);
	}
    }
    if(do_grib)
    {
	ajStrDel(&gbvpath);
	ajStrDel(&gbvextn);
	if(ajStrChar(*mode,0)=='1')
	{
	    ajStrDel(&gbvoutpath);
	    ajStrDel(&gbvoutextn);        
	}
    }
    if(do_henik)
    {
	ajStrDel(&hnfpath);
	ajStrDel(&hnfextn);    
	if(ajStrChar(*mode,0)=='1')
	{
	    ajStrDel(&hnfoutpath);
	    ajStrDel(&hnfoutextn);
	}  
    }
    if(do_sig)
    {
	ajStrDel(&sigpath);      
	ajStrDel(&sigextn);      
	if(ajStrChar(*mode,0)=='1')
	{
	    ajStrDel(&sigoutpath);
	    ajStrDel(&sigoutextn);
	}
    }

    if(ajStrChar(*mode,0)=='1')
    {
	ajStrDel(&mrgoutpath);
	ajStrDel(&mrgoutextn);
    }

    if(ajStrChar(*mode,0)=='2')
    {
	ajStrDel(&outpath);
	ajStrDel(&outextn);
    }
  
    ajSeqsetDel(&db);  

/*CORRECTION*/    if(do_sig)
      ajMatrixfDel(&sub);


/*CORRECTION*/    ajStrDel(&model);
    
  
    return 0;
    ajExit();
}



/* @funcstatic libscan_HmmSearch ********************************************
 **
 ** Runs hmmsearch at the command line and writes the results to a specified
 ** file.
 
 **
 ** @param [r] filename  [AjPStr]  Name of file containing the hmm.
 ** @paran [r] db        [AjPStr]  The database to be searched.
 ** @param [r] outfname  [AjPStr]  Name of output file for search results.
 **
 ** @return [AjBool] Returns true on completion.
 
 ** @@
 ** 
 *****************************************************************************/
static AjBool libscan_HmmSearch(AjPSeqset db, AjPStr hmmfile,
				AjPList targetlist, AjPStr family,
				AjPStr superfamily, AjPStr fold,
				AjPStr class, ajint sun_id, ajint overlap, 
				ajint maxhits, AjPStr model, AjPFile outf,
				AjPList* mrglist)
{
    ajint cnt           = 0;
    ajint nhits         = 0;
    ajint nhits2        = 0;
    
    ajint i;
    
    AjPStr tmp          = NULL; 
    AjPStr line         = NULL;         /* the next line in a file */
    AjPStr hmminfname   = NULL;         /* name of the hmmer input file */
    AjPStr hmmoutfname  = NULL;         /* name of the hmmer output file */

    AjPFile inf         = NULL;
    AjPFile hmminf      = NULL;         /* file pointer for the hmmer input file */
  
    AjPRegexp rexp1     = NULL;
    AjPRegexp rexp2     = NULL;
    AjPRegexp rexp3     = NULL;
    AjPRegexp rexp4     = NULL;
    AjPRegexp rexp5     = NULL;
  
    AjPStr  id          = NULL;         /* Hit identifier */
    AjPStr  startfrag   = NULL;         /* from regualr expression */
    ajint   start       = 0;            /* start of hit */
  
    AjPStr  endfrag     = NULL;         /* from the regular expression */
    ajint   end         = 0;            /* end of hit */
  
    AjPStr  scorefrag   = NULL;         /* from the regular expression */
    float   score       = 0.0;          /* score for alignment */
  
    AjPStr seqfrag      = NULL;
    AjPStr sequence     = NULL;


    float pvalue        = 0.0;
  
    AjPHit hit          = NULL;         /* hit that gets constructed in the first parse */
    AjPHit mhit         = NULL;         /* the hits that gets pushed on to the merge list */    
    AjPHit* hits        = NULL;

    AjPScophit scop     = NULL;
    AjPScophit newscop  = NULL;
    
    AjPHitlist hitlist  = NULL;
    AjPHitlist sechitlist = NULL;
    
    AjPList listhits    = NULL;         /* the list of hits */
    AjPList pointlist   = NULL;
    AjPList scophits    = NULL;
    AjPList tmplist     = NULL;
    
    AjIList iter        = NULL;         /* list iterator */
  
    LibscanPCoord  delpoint  = NULL;
  
    if(!db || !hmmfile || !outf)
    {
        ajWarn("Bad arguments passed to libscan_HmmSearch\n");
        return ajFalse;
    }
  
    rexp1  = ajRegCompC("(^[0-9a-zA-Z_]+)");
    rexp2  = ajRegCompC("(from [0-9]+)");
    rexp3  = ajRegCompC("(to [0-9]+)");
    rexp4  = ajRegCompC("(score [0-9.-]+)");
    rexp5  = ajRegCompC("(E = )([0-9.e-]+)");
  
    line        = ajStrNew();
    tmp         = ajStrNew();
    hmminfname  = ajStrNew();
    hmmoutfname = ajStrNew();
    startfrag   = ajStrNew();
    endfrag     = ajStrNew();
    scorefrag   = ajStrNew();
    id          = ajStrNew();
    seqfrag     = ajStrNew();
    sequence    = ajStrNew();
    
    listhits    = ajListNew();
    scophits    = ajListNew();
    tmplist     = ajListNew();    

    /* CREAT TEMPERARY FILE NAMES */
    /* create the filename for the hmmersearch output file */
    ajRandomSeed();
    ajStrAssC(&tmp, ajFileTempName(NULL));
    
    ajStrAssS(&hmminfname,tmp);
    ajStrAppC(&hmminfname, ".hmminf");
  
    ajStrAssS(&hmmoutfname,tmp);
    ajStrAppC(&hmmoutfname, ".hmmoutf");
    
    /* GET SCORES FOR EACH SEQUENCE IN THE DATABASE */
    /* run hmmsearch and construct a scophit list with e-values */
    for(cnt = 0; cnt<db->Size;cnt++)
    { 
        hmminf = ajFileNewOut(hmminfname);

        ajFmtPrintF(hmminf,">%S\n%S\n",db->Seq[cnt]->Name,db->Seq[cnt]->Seq);
        ajFileClose(&hmminf);
    
        /* RUN HMMSEARCH */
        libscan_RunHmmsearch(hmmfile, hmminfname, hmmoutfname);
    

        inf = ajFileNewIn(hmmoutfname);
    
        /* GET ALL INFOMATION ASSOCIATED WITH A MATCH */
        while(ajFileReadLine(inf,&line))
        {
            if(ajStrFindC(line,"Alignments of top-scoring domains:")>=0)
            {
                while(ajFileReadLine(inf,&line))
                {
                    if(ajRegExec(rexp1,line) && ajRegExec(rexp2,line) && ajRegExec(rexp3,line)&& 
                       ajRegExec(rexp4,line) && ajRegExec(rexp5,line))
                    {

                        /* Get the header for the current entry */ 
                        ajFmtScanS(line,"%S ",&id);
                        ajRegSubI(rexp1,1,&id);
            
                        ajRegSubI(rexp2,1,&startfrag);
                        ajFmtScanS(startfrag,"%*s %d",&start);
			
                        ajRegSubI(rexp3,1,&endfrag);
                        ajFmtScanS(endfrag,"%*s %d",&end);
            
                        ajRegSubI(rexp4,1,&scorefrag);
                        ajFmtScanS(scorefrag,"%*s %f",&score);
                    }
            
                    /* Get the sequence for the current entry */
                    else if(((ajStrFind(line,id))>=0))
                    {
                        ajFmtScanS(line,"%*s %*d %S %*d",&seqfrag);
                        ajStrSubstituteCC(&seqfrag,"-","");
                        ajStrApp(&sequence,seqfrag);
                    }
            
                    /* Print the sequence for the last entry */
                    else if((ajStrFindC(line,"Histogram of all scores:")>=0))
                    {
                        /* construct the last  hit */ 
                        hit = embHitNew();
            
                        /* construct the hit */
                        ajStrAssS(&hit->Acc,id);
                        ajStrAssS(&hit->Model,model);
                        hit->Start = start;
                        hit->End   = end;
                        hit->Score = score;
                        ajStrAssS(&hit->Seq,sequence);
            
                        ajListPushApp(listhits,hit);
                        ajStrAssC(&sequence,"");

                        break;
                    }
          
                    else
                        continue;
                }
            }
      
            else
                continue; 
        }
    
        ajFileClose(&inf);
        ajSysUnlink(&hmmoutfname);
        ajSysUnlink(&hmminfname); 
    
    }

    /* CONSTRUCT THE HITLIST*/
    hitlist = embHitlistNew(0); 
   
    /* write hit structure */
    ajStrAssS(&hitlist->Class,class);
    ajStrAssS(&hitlist->Fold,fold);
    ajStrAssS(&hitlist->Superfamily,superfamily);
    ajStrAssS(&hitlist->Family,family);
    ajStrAssS(&hitlist->Model,model);
    hitlist->Sunid_Family = sun_id;   

    /* Convert list to array within Hitlist object */
    nhits=ajListToArray(listhits,(void ***)&hitlist->hits);
    hitlist->N = nhits;

    if(!(hitlist->N))
	ajFatal("hitlist->N==0 in libscan_HmmSearch\n");
    

    /* CLASSIFY THE HITS ACCORDING TO THE SCOP FAMILIES FILE */
    if(embHitlistClassify(&hitlist, targetlist, overlap))
        ajFmtPrint("Hit classified ok\n");
    else
        ajFmtPrint("Program crashed!, Check embHitlistClassify\n");

    /* convert the hitlist to scophits so the related hits can be
       targetted for removal in order to calculate an unbiased
       distribution */
    ajListPushApp(tmplist,hitlist);
    embDmxHitlistToScophits(tmplist,&scophits);
    

    /* target for removal hits that have a "TRUE" or "CROSS" classification */
    iter = ajListIter(scophits);
    while((scop = (AjPScophit)ajListIterNext(iter)))
    {   
        if(ajStrMatchC(scop->Typesbj,"TRUE") ||
	   ajStrMatchC(scop->Typesbj,"CROSS"))
            ajDmxScophitTarget(&scop);  
    }
    ajListIterFree(iter);
    

    /* need garbage collection here - CORRECTION BY RAND 
       ajListGarbageCollect(scophits, ajDmxScophitDelWrap,
       (const void *) ajDmxScophitCheckTarget); */


    /* CALCULATE THE DISTRIBUTION WITH THE TRUE HITS AND CROSS HITS
       REMOVED FROM THE LIST */
    pointlist = libscan_CalcDistribution(scophits, class, fold, superfamily,
					 family, sun_id);

    /* convert the original list of hits  to an array for convenience */
    nhits = ajListToArray(listhits,(void ***)&hits);
    
    /* DO A SECOND PARSE THROUGH THE HITS FILE AND CALCULATE THE P-VALUES */
    for(i=0;i<nhits;i++)
    {
        pvalue = libscan_ScoreToPvalue(hits[i]->Score,pointlist);
        hits[i]->Pval = pvalue;
    }

    /* NOW RECONSTRUCT THE HIT LIST FOR PRINTING */
    sechitlist = embHitlistNew(0); 
   
    /* write hit structure */
    ajStrAssS(&sechitlist->Class,class);
    ajStrAssS(&sechitlist->Fold,fold);
    ajStrAssS(&sechitlist->Superfamily,superfamily);
    ajStrAssS(&sechitlist->Family,family);
    ajStrAssS(&sechitlist->Model,model);
    sechitlist->Sunid_Family = sun_id;   

    /* Convert list to array within Hitlist object */
    nhits2=ajListToArray(listhits,(void ***)&sechitlist->hits);
    sechitlist->N = nhits2;

    if(!(sechitlist->N))
	ajFatal("hitlist->N==0 in libscan_HmmSearch\n");
    
    
    /* WRITE HITS CLASSIFICATION OUTPUT FILE FOR SIGPLOT. The hits
       will be sorted according to scorebut this doesn't matter since
       the rank is the important thing. Also the subsequent p-value
       calculations will reflect this i.e. high scores will have low
       p-values and low scores will have high (less significant)
       p-values */
    
    if(embDmxHitsWrite(outf,sechitlist,maxhits))
        ajFmtPrint("Hits file written ok\n");
    else
        ajFmtPrint("Program crashed!, Check embHitsWrite\n");
    

    /* push on to the merge list the SCOPHITS  with the p-values calculated */
    iter = ajListIter(listhits);
    while((mhit = (AjPHit)ajListIterNext(iter)))
    {
        newscop = ajDmxScophitNew();

	ajStrAssS(&newscop->Class,class);
        ajStrAssS(&newscop->Fold,fold);
        ajStrAssS(&newscop->Superfamily,superfamily);
        ajStrAssS(&newscop->Family,family);
        newscop->Sunid_Family = sun_id;
        ajStrAssS(&newscop->Acc,mhit->Acc);
        ajStrAssS(&newscop->Model,mhit->Model);
        newscop->Start = mhit->Start;
        newscop->End   = mhit->End;
        newscop->Score = mhit->Score;
        newscop->Pval  = mhit->Pval;
        ajStrAssS(&newscop->Seq,mhit->Seq);

        ajListPushApp(*mrglist,(AjPScophit) newscop);

    }
    ajListIterFree(iter); 

    /* clean up tmplist / hitlist */
    /* Set N to zero so that the nodes in the list are not freed, 
       the structure itself will be freed though */
    hitlist->N=0;
    embHitlistDel(&hitlist);

/* CORRECTION */ sechitlist->N=0;
/* CORRECTION */    embHitlistDel(&sechitlist);
    ajListDel(&tmplist);

    /* clean up scophits */
    iter = ajListIter(scophits);
    while((scop = (AjPScophit)ajListIterNext(iter)))
        ajDmxScophitDel(&scop);
    ajListDel(&scophits);
    ajListIterFree(iter);

    /* Clean up listhits */
    iter = ajListIter(listhits);
    while((hit = (AjPHit)ajListIterNext(iter)))
        embHitDel(&hit);
    ajListDel(&listhits);
    ajListIterFree(iter);

    /* Clean up hits array */
    AJFREE(hits);

    /* clean up pointlist */
    iter = ajListIter(pointlist);
    while((delpoint = (LibscanPCoord)ajListIterNext(iter)))
        libscan_CoordDel(&delpoint);
    ajListDel(&pointlist);
    ajListIterFree(iter);

   
    /* clean up variables */
    ajRegFree(& rexp1);
    ajRegFree(& rexp2);
    ajRegFree(& rexp3);
    ajRegFree(& rexp4);
    ajRegFree(& rexp5);

    ajStrDel(&tmp );
    ajStrDel(&hmminfname);
    ajStrDel(&hmmoutfname);
    ajStrDel(&id);
    ajStrDel(&startfrag);
    ajStrDel(& endfrag);
    ajStrDel(&scorefrag);
    ajStrDel(&seqfrag);
    ajStrDel(&sequence);
    ajStrDel(&line);

    return ajTrue;
   
}


/* @funcstatic libscan_ProfileSearch ******************************************
**
** Runs prohet at the command line with a profile and writes the results to 
** a specified file.
**
** @param [r] filename  [AjPStr]  Name of file containing the gribskov profile.
** 
** @paran [r] db        [AjPStr]  The database to be searched.
** @param [r] outfname  [AjPStr]  Name of output file for search results.
**
** @return [AjBool] Returns true on completion.
** @@
** 
******************************************************************************/

static AjBool libscan_ProfileSearch(AjPSeqset db, AjPStr profile,
				    float gapopen, float gapextn, 
				    AjPList targetlist, AjPStr family,
				    AjPStr superfamily, AjPStr fold, 
				    AjPStr class, ajint sun_id,
				    ajint overlap, ajint maxhits,
				    AjPStr model, 
				    AjPFile outf, AjPList* mrglist)
{
    ajint cnt           = 0;
    ajint nhits         = 0;
    ajint nhits2        = 0;
    
    ajint i;
    
  
    AjPStr tmp          = NULL; 
    AjPStr line         = NULL;         /* the next line in a file */
    AjPStr profoutname  = NULL;  
    AjPStr profinfname  = NULL;         /* name of the gribskov input file */
    AjPStr profoutfname = NULL;         /* name of the gribskov output file */

    AjPFile inf         = NULL;
    AjPFile profinf     = NULL;         /* file pointer for the gribskov input file */
  
    AjPStr  id          = NULL;         /* Hit identifier */

    ajint   tmpstart    = 0;
    ajint   start       = 0;            /* start of hit */  
    ajint   end         = 0;            /* end of hit */
  
    float   score       = 0.0;          /* score for alignment */
  
    AjPStr seqfrag      = NULL;
    AjPStr sequence     = NULL;

    float pvalue        = 0.0;
  
    AjPHit hit          = NULL;
    AjPHit mhit         = NULL;
    AjPHit* hits        = NULL;

    AjPScophit scop     = NULL;
    AjPScophit newscop  = NULL;
    
    AjPHitlist hitlist  = NULL;
    AjPHitlist sechitlist = NULL;
    
    AjPList listhits    = NULL;         /* the list of hits */
    AjPList pointlist   = NULL;
    AjPList scophits    = NULL;
    AjPList tmplist     = NULL;
    
    AjIList iter        = NULL;         /* list iterator */
  
    LibscanPCoord  delpoint  = NULL;
  

    if(! db || !profile || !outf)
    {
        ajWarn("Bad arguments passed to libscan_HmmSearch\n");
        return ajFalse;
    }
  
    line         = ajStrNew();
    tmp          = ajStrNew();
    profinfname  = ajStrNew();
    profoutfname = ajStrNew();
    profoutname  = ajStrNew();
    id           = ajStrNew();
    seqfrag      = ajStrNew();
    sequence     = ajStrNew();
    
    listhits     = ajListNew();
    scophits     = ajListNew();
    tmplist      = ajListNew();

    /* CREAT TEMPERARY FILE NAMES */
    /* create the filename for the prophet output file */
    ajRandomSeed();
    ajStrAssC(&tmp, ajFileTempName(NULL));
  
    ajStrAssS(&profoutname,tmp);
    ajStrAppC(&profoutname, ".profoutname");
  
    ajStrAssS(&profinfname,tmp);
    ajStrAppC(&profinfname, ".profinf");
  
    ajStrAssS(&profoutfname,tmp);
    ajStrAppC(&profoutfname, ".profoutf");
    
    /* GET SCORES FOR EACH SEQUENCE IN THE DATABASE */
    /* run prophet and construct a scophit list with e-values */
    for(cnt = 0; cnt<db->Size;cnt++)
    { 
        profinf = ajFileNewOut(profinfname);
        ajFmtPrintF(profinf,">%S\n%S\n",db->Seq[cnt]->Name,db->Seq[cnt]->Seq);
        ajFileClose(&profinf);
    
        /* RUN PROPHET */
        libscan_RunProphet(profile, profinfname, gapopen, gapextn, profoutfname);
    
        inf = ajFileNewIn(profoutfname);
    
        /* GET ALL INFOMATION ASSOCIATED WITH A MATCH */
        while(ajFileReadLine(inf,&line))
        {
            if((ajStrPrefixC(line,"Local:")))
            {
                /* GET THE ID */
                ajFmtScanS(line,"%*s %*s %*s %S",&id);
                ajStrAssC(&sequence,"");        
            }
      
            /* GET THE SCORE */
            else if(ajStrPrefixC(line,"Score:"))
                ajFmtScanS(line,"%*s %f",&score);
      
            /* GET THE SEQUENCE */
            else if(ajStrPrefix(line,id))
            {
                ajFmtScanS(line,"%*s %d %S %d",&tmpstart,&seqfrag,&end);

                /* get start position from the first seqfrag only */
                if(!ajStrCmpC(sequence,""))
                    start = tmpstart;
        
                ajStrSubstituteCC(&seqfrag,".","");
                ajStrApp(&sequence,seqfrag);
            }
      
            else
                continue;
        }
        
        /* create a new hit structure */ 
        hit = embHitNew();
    
        ajStrAssS(&hit->Acc,id);
        ajStrAssS(&hit->Model,model);
        hit->Start = start;
        hit->End   = end;
        hit->Score = score;
        ajStrAssS(&hit->Seq,sequence);
	/* ajFmtPrint("Acc: %S\n%S\n",id,sequence); */
	
        ajListPushApp(listhits,hit);
	/* ajListPushApp(*mrglist, (AjPHit) hit); */    

        nhits++;
        ajFileClose(&inf);
    
        ajSysUnlink(&profoutfname);
        ajSysUnlink(&profinfname);    
    }
  
    /* CONSTRUCT THE HITLIST*/
    /* hitlist = embHitlistNew(cnt); */
    hitlist = embHitlistNew(0);
    
    /* write hit structure */
    ajStrAssS(&hitlist->Class,class);
    ajStrAssS(&hitlist->Fold,fold);
    ajStrAssS(&hitlist->Superfamily,superfamily);
    ajStrAssS(&hitlist->Family,family);
    ajStrAssS(&hitlist->Model,model);
    hitlist->Sunid_Family = sun_id;
   

    /* Convert list to array within Hitlist object */
    nhits=ajListToArray(listhits,(void ***)&hitlist->hits);
    hitlist->N = nhits;


    /* CLASSIFY THE HITS ACCORDING TO THE SCOP FAMILIES FILE */
    if(embHitlistClassify(&hitlist, targetlist, overlap))
        ajFmtPrint("Hit classified ok\n");
    else
        ajFmtPrint("Program crashed!, Check embHitlistClassify\n");


    /* convert the hitlist to scophits so the related hits can be
       targetted for removal in order to calculate an unbiased
       distribution */
    ajListPushApp(tmplist,hitlist);
    embDmxHitlistToScophits(tmplist,&scophits);
    

    /* target for removal hits that have a "TRUE" or "CROSS" classification */
    iter = ajListIter(scophits);
    while((scop = (AjPScophit)ajListIterNext(iter)))
    {   
        if(ajStrMatchC(scop->Typesbj,"TRUE") ||
	   ajStrMatchC(scop->Typesbj,"CROSS")) 
            ajDmxScophitTarget(&scop);  
    }
    ajListIterFree(iter);

    /* need garbage collection here */
/*CORRECTION*/    ajListGarbageCollect(scophits, ajDmxScophitDelWrap,
                         (int(*)(const void*)) ajDmxScophitCheckTarget);

    /* CALCULATE THE DISTRIBUTION WITH THE TRUE HITS AND CROSS HITS
       REMOVED FROM THE LIST */
    pointlist = libscan_CalcDistribution(scophits, class, fold, superfamily,
					 family, sun_id);

    /* convert the original list of hits to an array for convenience */ 
    nhits = ajListToArray(listhits,(void ***)&hits);
   
    /* DO A SECOND PARSE THROUGH THE HITS FILE AND CALCULATE THE P-VALUES */
    for(i=0;i<nhits;i++)
    {
        pvalue = libscan_ScoreToPvalue(hits[i]->Score,pointlist);
        hits[i]->Pval = pvalue;
    }

 /* NOW RECONSTRUCT THE HIT LIST FOR PRINTING */
    sechitlist = embHitlistNew(0); 
   
    /* write hit structure */
     ajStrAssS(&sechitlist->Class,class);
    ajStrAssS(&sechitlist->Fold,fold);
    ajStrAssS(&sechitlist->Superfamily,superfamily);
    ajStrAssS(&sechitlist->Family,family);
    ajStrAssS(&sechitlist->Model,model);
    sechitlist->Sunid_Family = sun_id;   

    /* Convert list to array within Hitlist object */
    nhits2=ajListToArray(listhits,(void ***)&sechitlist->hits);
    sechitlist->N = nhits2;

    if(!(sechitlist->N))          
	ajFatal("hitlist->N==0 in ilbscan_HmmSearch\n");
    
    
    /*WRITE HITS CLASSIFICATION OUTPUT FILE FOR SIGPLOT. The hits will
      be sorted according to scorebut this doesn't matter since the
      rank is the important thing. Also the subsequent p-value
      calculations will reflect this i.e. high scores will have low
      p-values and low scores will have high (less significant)
      p-values*/
    if(embDmxHitsWrite(outf,sechitlist,maxhits))
        ajFmtPrint("Hits file written ok\n");
    else
        ajFmtPrint("Program crashed!, Check embDmxHitsWrite\n");




    /* push on to the merge list the SCOPHITS  with the p-values calculated */
    iter = ajListIter(listhits);
    while((mhit = (AjPHit)ajListIterNext(iter)))
    {
        newscop = ajDmxScophitNew();

	ajStrAssS(&newscop->Class,class);	
        ajStrAssS(&newscop->Fold,fold);
        ajStrAssS(&newscop->Superfamily,superfamily);
        ajStrAssS(&newscop->Family,family);
        newscop->Sunid_Family = sun_id;
        ajStrAssS(&newscop->Acc,mhit->Acc);
        ajStrAssS(&newscop->Model,mhit->Model);
        newscop->Start = mhit->Start;
        newscop->End   = mhit->End;
        newscop->Score = mhit->Score;
        newscop->Pval  = mhit->Pval;

        ajStrAssS(&newscop->Seq,mhit->Seq);

        ajListPushApp(*mrglist,(AjPScophit) newscop);
    }
    ajListIterFree(iter);


    /* Set N to zero so that the nodes in the list are not freed, 
       the structure itself will be freed though */
    hitlist->N=0;
    embHitlistDel(&hitlist);
    /* CORRECTION */ sechitlist->N = 0;
    /* CORRECTION */ embHitlistDel(&sechitlist);
    ajListDel(&tmplist);

    /* clean up scophits */
    iter = ajListIter(scophits);
    while((scop = (AjPScophit)ajListIterNext(iter)))
        ajDmxScophitDel(&scop);
    ajListDel(&scophits);
    ajListIterFree(iter);


    /* Free listhits nodes */
    iter = ajListIter(listhits);
    while((hit = (AjPHit)ajListIterNext(iter)))
	embHitDel(&hit);      
    ajListDel(&listhits);
    ajListIterFree(iter); 

    /* Clean up hits array */
    AJFREE(hits);

    /* clean up pointlist */
    iter = ajListIter(pointlist);
    while((delpoint = (LibscanPCoord)ajListIterNext(iter)))
        libscan_CoordDel(&delpoint);
    ajListDel(&pointlist);
    ajListIterFree(iter);

   
    /* clean up variables */
    ajStrDel(&tmp );
    ajStrDel(&profoutname);
    ajStrDel(&profinfname);
    ajStrDel(&profoutfname);
    ajStrDel(&id);
    ajStrDel(&seqfrag);
    ajStrDel(&sequence);
    ajStrDel(&line);

    return ajTrue;
   
}



/* @funcstatic libscan_SignatureSearch ****************************************
**
** Runs prohet at the command line with a profile and writes the results to 
** a specified file.
**
** @param [r] filename  [AjPStr]  Name of file containing the gribskov profile.
** @paran [r] db        [AjPStr]  The database to be searched.
** @param [r] outfname  [AjPStr]  Name of output file for search results.
**
** @return [AjBool] Returns true on completion.
** @@
** 
******************************************************************************/
static AjBool libscan_SignatureSearch(AjPSeqset db, AjPStr sigfile,
				      AjPMatrixf sub, float gapo, float gape,
				      ajint ntopt, AjPList targetlist,
				      AjPStr family, AjPStr superfamily, 
				      AjPStr fold, AjPStr class, ajint sun_id,
				      ajint overlap, ajint maxhits, 
				      AjPStr model, AjPFile outf,
				      AjPList* mrglist)
{
    AjPSignature sig      = NULL;       /* Signature data structure*/
    
    LibscanPCoord delpoint     = NULL;

    AjIList iter          = NULL;

    AjPList pointlist     = NULL;
    AjPList listhits      = NULL;
    AjPList scophits      = NULL;
    AjPList tmplist       = NULL;

    AjPFile sigin         = NULL;
    
    ajint cnt             = 0;
    ajint nhits           = 0;
    ajint nhits2          = 0;
    
    ajint i;

    float pvalue          = 0.0;
    
    AjPSeq seq            = NULL;
   
    AjPHit hit            = NULL;
    AjPHit mhit           = NULL;	/* the hits that gets pushed on to the merge list */    
    AjPHit* hits          = NULL;

    AjPScophit scop       = NULL;
    AjPScophit newscop    = NULL; 
    AjPHitlist hitlist    = NULL;
    AjPHitlist sechitlist = NULL;
    

    sigin  = ajFileNewIn(sigfile);

    listhits = ajListNew();
    tmplist  = ajListNew();
    scophits = ajListNew();
    

    /* READ SIGNATURE FILE */
    if(!(sig=embSignatureReadNew(sigin)))
    {   
        ajMatrixfDel(&sub);
        ajFileClose(&sigin);
        return ajFalse;
        ajFatal("Error reading signature file");
    }   
    else
        ajFmtPrint("Signature file read ok\n");
    

    /* COMPILE SIGNATURE */
    if(!embSignatureCompile(&sig, gapo, gape, sub))
    {  

	
        embSignatureDel(&sig);
        ajMatrixfDel(&sub);
        ajFileClose(&sigin);
        return ajFalse;
        ajFatal("Error compiling signature");
    }  
    else
        ajFmtPrint("Signature compiled ok\n");    
    

    /* SEARCH DATABASE AND GET SCORES FOR EACH SEQUENCE IN THE DATABASE */
    for(cnt = 0; cnt<db->Size;cnt++)
    {
        seq = ajSeqNew();
	
        ajStrAssS(&seq->Name,db->Seq[cnt]->Name);
	ajStrAssS(&seq->Acc,db->Seq[cnt]->Name);
        ajStrAssS(&seq->Seq,db->Seq[cnt]->Seq);
	
        /* Allocate memory for hit */
        hit = embHitNew();
      
        if(!embSignatureAlignSeq(sig, seq, &hit, ntopt))
        {       
            embHitDel(&hit);
	    ajSeqDel(&seq);
            continue;
        }

	/* CORRECTION */ ajSeqDel(&seq);

        ajStrAssS(&hit->Model,model);
        ajListPush(listhits,(AjPHit) hit);

    }

    /* CONSTRUCT THE HITLIST */
    hitlist = embHitlistNew(0);
    
    /* write hit structure */
    ajStrAssS(&hitlist->Class,class);
    ajStrAssS(&hitlist->Fold,fold);
    ajStrAssS(&hitlist->Superfamily,superfamily);
    ajStrAssS(&hitlist->Family,family);
    ajStrAssS(&hitlist->Model,model);
    hitlist->Sunid_Family = sun_id;
   
    /* Convert list to array within Hitlist object */
    nhits=ajListToArray(listhits,(void ***)&hitlist->hits);
    hitlist->N = nhits;

    /* CLASSIFY THE HITS ACCORDING TO THE SCOP FAMILIES FILE */
    if(embHitlistClassify(&hitlist, targetlist, overlap))
        ajFmtPrint("Hit classified ok\n");
    else
        ajFmtPrint("Program crashed!, Check embHitlistClassify\n");


    /* convert the hitlist to scophits so the related hits can be targetted for removal
       in order to calculate an unbiased distribution */
    ajListPushApp(tmplist,hitlist);
    embDmxHitlistToScophits(tmplist,&scophits);
    

    /* target for removal hits that have a "TRUE" or "CROSS" classification */
    iter = ajListIter(scophits);
    while((scop = (AjPScophit)ajListIterNext(iter)))
    {   
        if(ajStrMatchC(scop->Typesbj,"TRUE") ||
	   ajStrMatchC(scop->Typesbj,"CROSS")) 
            ajDmxScophitTarget(&scop);  
    }
    ajListIterFree(iter);


    /* need garbage collection here */
/*CORRECTION*/    ajListGarbageCollect(scophits, ajDmxScophitDelWrap,
                         (int(*)(const void*)) ajDmxScophitCheckTarget);


    /* CALCULATE THE DISTRIBUTION WITH THE TRUE HITS AND CROSS HITS
       REMOVED FROM THE LIST */
    pointlist = libscan_CalcDistribution(scophits, class, fold, superfamily,
					 family, sun_id);

    /* convert the original list of hits to an array for convenience */ 
    nhits = ajListToArray(listhits,(void ***)&hits);

   
    /* DO A SECOND PARSE THROUGH THE HITS FILE AND CALCULATE THE P-VALUES */
    for(i=0;i<nhits;i++)
    {
        pvalue = libscan_ScoreToPvalue(hits[i]->Score,pointlist);
        hits[i]->Pval = pvalue;
    }


    /* NOW RECONSTRUCT THE HIT LIST FOR PRINTING */
    sechitlist = embHitlistNew(0); 
   
    /* write hit structure */
    ajStrAssS(&sechitlist->Class,class);
    ajStrAssS(&sechitlist->Fold,fold);
    ajStrAssS(&sechitlist->Superfamily,superfamily);
    ajStrAssS(&sechitlist->Family,family);
    ajStrAssS(&sechitlist->Model,model);
    sechitlist->Sunid_Family = sun_id;   

    /* Convert list to array within Hitlist object */
    nhits2=ajListToArray(listhits,(void ***)&sechitlist->hits);
    sechitlist->N = nhits2;

    if(!(sechitlist->N))          
	ajFatal("hitlist->N==0 in libscan_HmmSearch\n");
    
    
    /*WRITE HITS CLASSIFICATION OUTPUT FILE FOR SIGPLOT. The hits will
      be sorted according to scorebut this doesn't matter since the
      rank is the important thing. Also the subsequent p-value
      calculations will reflect this i.e. high scores will have low
      p-values and low scores will have high (less significant)
      p-values*/
    if(embDmxHitsWrite(outf,sechitlist,maxhits))
        ajFmtPrint("Hits file written ok\n");
    else
        ajFmtPrint("Program crashed!, Check embDmxHitsWrite\n");


    /* push on to the merge list the SCOPHITS  with the p-values calculated */
    iter = ajListIter(listhits);
    while((mhit = (AjPHit)ajListIterNext(iter)))
    {

        newscop = ajDmxScophitNew();

	ajStrAssS(&newscop->Class,class);
        ajStrAssS(&newscop->Fold,fold);
        ajStrAssS(&newscop->Superfamily,superfamily);
        ajStrAssS(&newscop->Family,family);
        newscop->Sunid_Family = sun_id;
        ajStrAssS(&newscop->Acc,mhit->Acc);
        ajStrAssS(&newscop->Model,mhit->Model);
        newscop->Start = mhit->Start;
        newscop->End   = mhit->End;
        newscop->Score = mhit->Score;
        newscop->Pval  = mhit->Pval;
        ajStrAssS(&newscop->Seq,mhit->Seq);

        ajListPushApp(*mrglist,(AjPScophit) newscop);
    }
    ajListIterFree(iter); 
    
    /* clean up scophits */
    iter = ajListIter(scophits);
    while((scop = (AjPScophit)ajListIterNext(iter)))
        ajDmxScophitDel(&scop);
    ajListDel(&scophits);
    ajListIterFree(iter);


    /* Set N to zero so that the nodes in the list are not freed, 
       the structure itself will be freed though */
    hitlist->N=0;
    embHitlistDel(&hitlist);
    /* CORRECTION */ sechitlist->N = 0;
    /* CORRECTION */ embHitlistDel(&sechitlist);
    ajListDel(&tmplist);	

    /* Clean up listhits nodes */
    iter = ajListIter(listhits);
    while((hit = (AjPHit)ajListIterNext(iter)))
        embHitDel(&hit);	
    ajListDel(&listhits);
    ajListIterFree(iter); 

    /* Clean up hits array */
    AJFREE(hits);

    /* clean up pointlist */
    iter = ajListIter(pointlist);
    while((delpoint = (LibscanPCoord)ajListIterNext(iter)))
        libscan_CoordDel(&delpoint);
    ajListDel(&pointlist);
    ajListIterFree(iter);

    embSignatureDel(&sig);
    ajFileClose(&sigin);
    
    return ajTrue;   
}



/* @funcstatic libscan_RunHmmsearch ********************************************
 **
 ** Runs hmmsearch at the command line and writes the results to a specified
 ** file.
 **
 
 ** @param [r] filename  [AjPStr]  Name of file containing the hmm.
 ** @paran [r] db        [AjPStr]  The database to be searched.
 ** @param [r] outfname  [AjPStr]  Name of output file for search results.
 **
 ** @return [AjBool] Returns true on completion.
 ** @@
 ** 
 ******************************************************************************/
AjBool libscan_RunHmmsearch(AjPStr filename, AjPStr db, AjPStr outfname)
{
    AjPStr cmd  = NULL;                 /* the command line to be executed */
    
    if(!filename || !outfname)
    {
        ajWarn("Bad args passed to libscan_RunHmmsearch\n");
        return ajFalse;
    }

    cmd = ajStrNew();

    /* construct command line for hmmsearch */
    ajFmtPrintS(&cmd,"hmmsearch %S %S > %S",filename,db,outfname);

    /* execute the command line */
    system(ajStrStr(cmd));
  
    /* clean up */
    ajStrDel(&cmd);
  
    return ajTrue;
  
}


/* @funcstatic libscan_RunProphet **********************************************
 **
 ** Runs prophet at the command line and writes the results to a specified
 ** file.
 **
 ** @param [r] profile   [AjPStr]  Name of file containing the profile.
 ** @paran [r] db        [AjPStr]  The database to be searched.
 ** @param [r] gapopen   [ajint]   Gap open panelty 
 ** @param [r] gapextend [ajint]   Gap extension penalty
 ** @param [r] outfname  [AjPStr]  Name of output file for search results.
 **
 ** @return [AjBool] Returns true on completion.
 ** @@
 ** 
 ******************************************************************************/
AjBool libscan_RunProphet(AjPStr profile, AjPStr db, float gapopen, float gapextend, 
                       AjPStr outfname)
{
    AjPStr cmd  = NULL;                 /* the command line to be executed */

    if(!profile || !outfname)
    {
        ajWarn("Bad args passed to libscan_RunHmmsearch\n");
        return ajFalse;
    }

    cmd = ajStrNew();

    /* construct command line for hmmsearch */
    ajFmtPrintS(&cmd,"prophet -sequence %S -infile %S -gapopen %1f -gapextend %1f -outfile %S",
                db,profile,gapopen,gapextend,outfname);

    /* execute the command line */
    system(ajStrStr(cmd));

    /* clean up */
    ajStrDel(&cmd);

    return ajTrue;
  
}


/* @funcstatic libscan_GetLibrary *********************************************
**
** Given the directory where the models exist and a file extension of the 
** models, the routine returns a list of file names matching the user defined 
** file extension.
**
** @param [r]  path [AjPStr] Directory of models. 
** @param [r]  extn [AjPStr] File extension.
**
** @return [AjPList] a list of file names.
** @@
** 
******************************************************************************/
static AjPList libscan_GetLibrary(AjPStr path, AjPStr extn)
{
    AjPList list = NULL;                /* a list of filenames */
    
    AjPStr tmp   = NULL;
    
    
    list = ajListNew();
    
    /* Create list of files in the path */
    ajStrAssC(&tmp, "*");               /* assign a wildcard to tmp */

    if((ajStrChar(extn, 0)=='.')) /* checks if the file extension
				     starts with "." */
        ajStrApp(&tmp, extn);           /* assign the acd input file
  					   extension to tmp */
  
    /* this picks up situations where the user has specified an
       extension without a "." */
    else
    {
        ajStrAppC(&tmp, ".");           /* assign "." to tmp */  
        ajStrApp(&tmp, extn);           /* append tmp with a user
					   specified extension */
    }   
  

    /* all files containing hidden markov models will be in a list */
    ajFileScan(path, tmp, &list, ajFalse, ajFalse, NULL, NULL, ajFalse, NULL);
    
    ajStrDel(&tmp);

    return list;
}


/* @funcstatic libscan_CalcDistribution ***************************************
**
** Calculate the distribution from a list of hits.
**
** @param [r] listhits   [AjPList] List is hits 
** @param [r] fold        [AjPStr ] SCOP fold
** @param [r] superfamily [AjPStr ] SCOP superfamily
** @param [r] famly       [AjPStr ] SCOP family
** @param [r] sun_id      [ajint  ] SCOP family sunid
**
** @return [AjPList] A list of coordinates in a distribution.
** @@
******************************************************************************/
static AjPList libscan_CalcDistribution(AjPList scophits, AjPStr class,
					AjPStr fold, AjPStr superfamily,
					AjPStr family, ajint sun_id)
{
    AjPList pointlist = NULL;
    
    ajint i           = 0;
    ajint nhits       = 0;
    ajint high        = 0;
    ajint low         = 0;
    ajint freq        = 0;
    ajint interval    = 0;              /* the score interva, x-axis */

    LibscanPCoord  point   = NULL; /* a Datapoint object to hold
				      individual coordinates */

    AjPScophit* hits  = NULL;
    
    if(!scophits)
        ajFatal("No list of hits passed to libscan_CalcDistribution\n");
    

    pointlist = ajListNew();

    /* but only remove them inside the libscan_CalcDistribution sub-routine */
/*CORRECTION*/    ajListGarbageCollect(scophits, ajDmxScophitDelWrap,
                         (int(*)(const void*)) ajDmxScophitCheckTarget);

    /* sort the list according to score */
    ajListSort(scophits,ajDmxScophitCompScore);

    /* convert list to array for convenience */
    nhits = ajListToArray(scophits,(void ***)&hits);

    if(!nhits)
	ajFatal("No hits in libscan_CalcDistribution!");
    
    low  = (ajint)hits[0]->Score;

    high = (ajint)hits[nhits-1]->Score;
    freq = 0;
    
    /* only for testing purposes
       printf("1 = %f 2 = %f 3 = %f 4 = %f 5= %f 6= %f 7= %f\n",hits[0]->Score,
       hits[1]->Score,hits[2]->Score,hits[3]->Score,
       hits[4]->Score,hits[5]->Score,hits[6]->Score); */
  
    /* set the starting point */
    if(low > 0)
        interval = (low+1);
    else if(low < 0)
        interval = (low-1);
    
    for(i=0; i<nhits; i++)
    { 
        if(hits[i]->Score < (float)interval)
        {
            freq++;
       
            if(interval == (high+1))
            {
                point = libscan_CoordNew();
         
		ajStrAssS(&point->Class,class);
                ajStrAssS(&point->Fold,fold);
                ajStrAssS(&point->Superfamily,superfamily);
                ajStrAssS(&point->Family,family);
                point->Sunid_Family = sun_id;
                ajStrAssS(&point->Acc,hits[i]->Acc);
                point->x = interval;
                point->y = freq;
		
                ajListPushApp(pointlist,point);
            }
        }
     
        else if(hits[i]->Score > (float)interval)
        { 
            while((float)interval <= hits[i]->Score)
            {           
                point = libscan_CoordNew();
         
		ajStrAssS(&point->Class,class);
                ajStrAssS(&point->Fold,fold);
                ajStrAssS(&point->Superfamily,superfamily);
                ajStrAssS(&point->Family,family);
                point->Sunid_Family = sun_id;
                ajStrAssS(&point->Acc,hits[i]->Acc);
                point->x = interval;
                point->y = freq;
                
		ajListPushApp(pointlist,point);
                interval++;
        
            }

            freq++;
        }
    }


    AJFREE(hits);

    return pointlist;
}








/* @funcstatic libscan_HmmLibScan *********************************************
**
** Scan a protein sequence against a library of hidden markov models. The 
** models represents SCOP portein domain families. 
**
** @param [r] db       [AjPSeqset]  Name of sequence file. 
** @param [r] path     [AjPStr]     Directory of hmm models.
** @param [r] extn     [AjPStr]     File extension of models.
** @param [r] scoplist [AjPList]    List of scop objects.
**
** @return [AjPList] returns familyhits.
** @@
** 
******************************************************************************/
static AjBool libscan_HmmLibScan(AjPSeq seq, AjPStr hmmpath, AjPStr hmmextn,
				 AjPList scoplist, AjPStr model,
				 AjPStr hmmoutpath, AjPStr hmmoutextn,
				 AjPList* mrglist)
{
    AjPStr line        = NULL;		/* line from a file */
    
    AjPStr id          = NULL;		/* protein identification tag */
    
    AjPStr  startfrag  = NULL;		/* from regualr expression */
    ajint   start      = 0;		/* start of hit */
    
    AjPStr  endfrag    = NULL;		/* from the regular expression */
    ajint   end        = 0;		/* end of hit */
    
    AjPStr  scorefrag  = NULL;		/* from the regular expression */
    float   score      = 0.0;		/* score for alignment */
    
    AjPStr  seqfrag    = NULL;		/* the hit sequence fragment*/
    AjPStr  sequence   = NULL;		/* complete hit sequence */
    
    AjPStr hmmfile     = NULL;		/* Name of model file */

    AjPStr tmpname     = NULL;		/* Holds a randomly generated string */
    AjPStr sunidfrag   = NULL;		/* the Sunid_Family for bin search */
    
    AjPStr family      = NULL;		/* Name of scop family for a given entry*/
    AjPStr superfamily = NULL;		/* Name of scop superfamily for a given entry */
    AjPStr fold        = NULL;		/* Name of scop fold for a given entry */
    AjPStr class       = NULL;
    
    AjPStr outfile     = NULL;		/* Name of output file */
    
    AjPList modelnames = NULL;		/* A list of model names */
    AjPList familyhits = NULL;		/* A list of scophits structures corresponding to each SCOP family */
    AjPList pointlist  = NULL;
    AjPList tmplist    = NULL;
    
    
    AjPFile inf        = NULL;		/* input file pointer for hmmserach output file */
    AjPFile hmminf     = NULL;		/* file pointer for the hmmer input file */
    AjPFile hmmoutf    = NULL;
    
    AjPRegexp rexp1    = NULL;
    AjPRegexp rexp2    = NULL;
    AjPRegexp rexp3    = NULL;
    AjPRegexp rexp4    = NULL;
    AjPRegexp rexp5    = NULL;
    
    ajint posdash      = 0;
    ajint posdot       = 0;

    ajint sunid        = 0;
    
    ajint i            = 0;
    ajint nhits        = 0;
    
    float pvalue       = 0.0;
    
    LibscanPCoord delpoint  = NULL;
    
    AjPScophit* hits   = NULL;
    AjPScophit hit     = NULL;		/* Scophit structure to hold the scored family */
    AjPScophit scophit = NULL;
    AjPScophit mhit    = NULL;
    
    AjIList iter       = NULL;		/* list iterator */
    
    AjPStr hmminfname   = NULL;		/* name of the hmmer input file */
    AjPStr hmmoutfname  = NULL;		/* name of the hmmer output file */
    
    
    line         = ajStrNew();
    id           = ajStrNew();
    hmmfile      = ajStrNew();
    tmpname      = ajStrNew();
    startfrag    = ajStrNew();
    endfrag      = ajStrNew();
    scorefrag    = ajStrNew();
    seqfrag      = ajStrNew();
    sequence     = ajStrNew();
    sunidfrag    = ajStrNew();
    hmminfname   = ajStrNew();
    hmmoutfname  = ajStrNew();
    outfile      = ajStrNew();
    
    family      = ajStrNew();
    superfamily = ajStrNew();
    fold        = ajStrNew();
    class       = ajStrNew();
    

    rexp1  = ajRegCompC("(^[0-9a-zA-Z_]+)");
    rexp2  = ajRegCompC("(from [0-9]+)");
    rexp3  = ajRegCompC("(to [0-9]+)");
    rexp4  = ajRegCompC("(score [0-9.-]+)");
    rexp5  = ajRegCompC("(E = )([0-9.e-]+)");
    
    if(!hmmpath || !seq || !hmmextn || !scoplist)
    {
        ajWarn("Bad arguments passed to libscan_HmmLibScan\n");
        return ajFalse;
    }

    /* get the models */
    modelnames = libscan_GetLibrary(hmmpath,hmmextn);
    
    tmplist  = ajListNew();
    
    /* Initialise random number generator for naming of temp. files
       and create hmmer output file */
    ajRandomSeed();
    ajStrAssC(&tmpname, ajFileTempName(NULL));
    
    ajStrAssS(&hmminfname, tmpname);
    ajStrAppC(&hmminfname, ".hmminf");
    
    hmminf = ajFileNewOut(hmminfname);
    ajFmtPrintF(hmminf,">%S\n%S\n",seq->Name,seq->Seq);
    ajFileClose(&hmminf);

    ajStrAssS(&outfile,seq->Name);
    ajStrApp(&outfile,hmmoutextn);  
    
    iter = ajListIter(modelnames);
    /*Start of main application loop*/   
    while((hmmfile = (AjPStr)ajListIterNext(iter)))
    {     
        /* get the Sunid_Family from the hmmfile. THIS WILL NEED TO BE CHANGED */
        posdash = ajStrRFindC(hmmfile, "/");
        posdot  = ajStrRFindC(hmmfile, ".");
    
        if(posdash >= posdot)
            ajWarn("Could not create filename. Email rranasin@hgmp.mrc.ac.uk");
        else
        {
            ajStrAssSub(&sunidfrag, hmmfile, posdash+1, posdot-1);
            ajStrToInt(sunidfrag,&sunid);
        }
      
        /* do a binary search on scoplist to find the relavent entry */
        if(!(libscan_SunidToScopInfo(sunid,&family,&superfamily,
				     &fold,&class, scoplist)))
            ajFatal("libscan_SunidToScopInfo failed in libscan_HmmLibScan. "
		    "email rranasin@hgmp.mrc.ac.uk\n");
      
        ajRandomSeed();
        ajStrAssC(&tmpname, ajFileTempName(NULL));
          
        ajStrAssS(&hmmoutfname, tmpname);
        ajStrAppC(&hmmoutfname, ".hmmoutf");

        libscan_RunHmmsearch(hmmfile, hmminfname, hmmoutfname);                    
    
        /* open hmmsearch output file */
        if(!(inf = ajFileNewIn(hmmoutfname)))
            ajWarn("File %S could not be opened\n",hmmoutfname);
    

        /* get scoring information and alignment */
        while(ajFileReadLine(inf,&line))
        {
            if(ajStrFindC(line,"Alignments of top-scoring domains:")>=0)
            {
                while(ajFileReadLine(inf,&line))
                {
                    if(ajRegExec(rexp1,line) && ajRegExec(rexp2,line) && ajRegExec(rexp3,line) && 
                       ajRegExec(rexp4,line) && ajRegExec(rexp5,line))
                    {
                        /* Get the header for the current entry */ 
                        ajFmtScanS(line,"%S ",&id);
                        ajRegSubI(rexp1,1,&id);
            
                        ajRegSubI(rexp2,1,&startfrag);
                        ajFmtScanS(startfrag,"%*s %d",&start);
            
                        ajRegSubI(rexp3,1,&endfrag);
                        ajFmtScanS(endfrag,"%*s %d",&end);
            
                        ajRegSubI(rexp4,1,&scorefrag);
                        ajFmtScanS(scorefrag,"%*s %f",&score);
                    }

                    /* Get the sequence*/
                    else if(((ajStrFind(line,id))>=0))
                    {
                        ajFmtScanS(line,"%*s %*d %S %*d",&seqfrag);
                        ajStrApp(&sequence,seqfrag);
                    }
        
                    /* Print the sequence for the last entry */
                    else if((ajStrFindC(line,"Histogram of all scores:")>=0))
                    {
			/* construct the scophit structure */
                        hit = ajDmxScophitNew();
                        ajStrAssS(&hit->Class,class);
                        ajStrAssS(&hit->Fold,fold);
                        ajStrAssS(&hit->Superfamily,superfamily);
                        ajStrAssS(&hit->Family,family);
                        ajStrAssS(&hit->Acc,id);
                        ajStrAssS(&hit->Model,model);
                        ajStrAssS(&hit->Seq,sequence);
                        hit->Sunid_Family = sunid;
                        hit->Score = score;
                        hit->Start = start;
                        hit->End = end;

                        /* push the scop hit onto list */
                        ajListPushApp(tmplist,(AjPScophit) hit);

			break;
                    }


                    else
                        continue;
                }       
            }
            
            else
                continue;
        }

        ajFileClose(&inf);
        ajSysUnlink(&hmmoutfname);      
    }

    ajListIterFree(iter);
    
    /* CALCULATE THE DISTRIBUTION WITH THE TRUE HITS AND CROSS HITS
       REMOVED FROM THE LIST */
    pointlist = libscan_CalcLibscanDistribution(tmplist);
    
    if(ajListLength(pointlist)!=0)
    {
	hmmoutf = ajFileNewOutD(hmmoutpath,outfile);
	   
	familyhits  = ajListNew();
	   
	/* convert the original list of hits to an array for convenience */ 
	nhits = ajListToArray(tmplist,(void ***)&hits);
	   
	/* DO A SECOND PARSE THROUGH THE HITS FILE AND CALCULATE THE
           P-VALUES */
	for(i=0;i<nhits;i++)
	{
	    scophit = ajDmxScophitNew();
	    pvalue = libscan_ScoreToPvalue(hits[i]->Score,pointlist);
	    hits[i]->Pval = pvalue;
	    ajDmxScophitCopy(&scophit,hits[i]);
	    ajListPushApp(familyhits,scophit);
	}
	   
	/*sort the list before printing */
        ajListSort(familyhits,ajDmxScophitCompPval);

	/* write out the familyhits list */
	ajDmxScophitsWrite(hmmoutf,familyhits);
	ajFileClose(&hmmoutf);
	   
	AJFREE(hits);

	/* push on to the merge list the hits with the p-values calculated */
	iter = ajListIter(familyhits);
	while((mhit = (AjPScophit)ajListIterNext(iter)))
	    ajListPushApp(*mrglist,(AjPScophit) mhit);
	ajListIterFree(iter); 
	ajListDel(&familyhits);
	   
	/* delete and clean up pointlist */
	iter=ajListIter(pointlist);
	while((delpoint=(LibscanPCoord)ajListIterNext(iter)))
	    libscan_CoordDel(&delpoint);
	ajListIterFree(iter);
	ajListDel(&pointlist);   
    }
       
    /* remove temparary files from directory */
    ajSysUnlink(&hmminfname);
    ajSysUnlink(&hmmoutfname);
    
    /* delete and clean up tmplist */
    iter=ajListIter(tmplist);
    while((hit=(AjPScophit)ajListIterNext(iter)))
        ajDmxScophitDel(&hit);
    ajListIterFree(iter);
    ajListDel(&tmplist);
    
    /* delete and clean up pointlist */
    iter=ajListIter(pointlist);
    while((delpoint=(LibscanPCoord)ajListIterNext(iter)))
        libscan_CoordDel(&delpoint);
    ajListIterFree(iter);
    ajListDel(&pointlist);      
    
    /* delete and clean up modelnames */
    iter=ajListIter(modelnames);
    ajStrDel(&tmpname);    while((tmpname=(AjPStr)ajListIterNext(iter)))
        ajStrDel(&tmpname);
    ajListIterFree(iter);
    ajListDel(&modelnames); 


    /* clean up */
    ajRegFree(&rexp1);
    ajRegFree(&rexp2);
    ajRegFree(&rexp3);
    ajRegFree(&rexp4);
    ajRegFree(&rexp5);
  
    ajStrDel(&hmmoutfname);
    ajStrDel(&hmminfname);
    ajStrDel(&line);
    ajStrDel(&id);
/*CORRECTION */    ajStrDel(&class);
    ajStrDel(&startfrag);
    ajStrDel(&endfrag);
    ajStrDel(&scorefrag);
    ajStrDel(&seqfrag);
    ajStrDel(&sequence);
    ajStrDel(&sunidfrag);
    ajStrDel(&family);
    ajStrDel(&superfamily);
    ajStrDel(&fold);
    ajStrDel(&outfile);  

    return ajTrue;
  
}


/* @funcstatic libscan_ProfileLibScan *****************************************
**
** Scan a protein sequence against a library of profile models. The 
** models represents SCOP portein domain families. 
**
** @param [r] seqfname [AjPStr]  Name of sequence file. 
** @param [r] path     [AjPStr]  Directory of profile models.
** @param [r] extn     [AjPStr]  File extension of models.
** @param [r] scoplist [AjPList] List of scop objects.
**
** @return [AjPList] retuns familyhits.
** @@
** 
******************************************************************************/
static AjBool libscan_ProfileLibScan(AjPSeq seq, AjPStr path, AjPStr extn,
				     float gapopen, float gapextn,
				     AjPList scoplist, AjPStr model,
				     AjPStr profoutpath, AjPStr profoutextn, 
				     AjPList* mrglist)
{

    AjPStr  line       = NULL;
    AjPStr  id         = NULL;		/* Hit identifier */

    ajint   tmpstart   = 0;
    ajint   start      = 0;		/* start of hit */

    ajint   end        = 0;		/* end of hit */

    float   score      = 0.0;		/* score for alignment */

    AjPStr  seqfrag    = NULL;		/* the hit sequence fragment*/
    AjPStr  sequence   = NULL;		/* complete hit sequence */

    AjPStr sunidfrag   = NULL;		/* the sunid as a string */
    
    AjPStr family      = NULL;		/* scop family */
    AjPStr superfamily = NULL;		/* scop superfamily */
    AjPStr fold        = NULL;		/* scop fold */
    AjPStr class       = NULL;
    

    AjPStr  profile    = NULL;		/* name of seqret output file */
    AjPStr  tmpname    = NULL;
    AjPStr  outfname   = NULL;

    AjPStr outfile     = NULL;
    
    AjPFile inf        = NULL;
    AjPFile profileinf = NULL;		/* file pointer for the hmmer input file */
    AjPFile profoutf    = NULL;

    AjPScophit hit     = NULL;		/* Scophit structure */
    AjPScophit* hits   = NULL;

    AjPScophit scophit = NULL;
    AjPScophit mhit    = NULL;
    
    ajint posdash      = 0;
    ajint posdot       = 0;
    ajint sunid        = 0;
    ajint i            = 0;		/* counter for the number of hits */
    ajint nhits        = 0;

    float pvalue       = 0.0;

    LibscanPCoord delpoint  = NULL;
    
    AjIList iter       = NULL;		/* list iterator */
    
    AjPList familyhits = NULL;		/* a list of hits */
    AjPList modelnames = NULL;		/* A list of model names */
    AjPList pointlist  = NULL;
    AjPList tmplist    = NULL;
    
    AjPStr profileinfname  = NULL;	/* name of the hmmer input file */
    AjPStr profileoutfname = NULL;	/* name of the hmmer output file */
     
    
    line            = ajStrNew();
    seqfrag         = ajStrNew();
    sunidfrag       = ajStrNew();
    profile         = ajStrNew();
    tmpname         = ajStrNew();
    outfname        = ajStrNew();
    sequence        = ajStrNew();
    profileinfname  = ajStrNew();
    profileoutfname = ajStrNew();
    family          = ajStrNew();
    superfamily     = ajStrNew();
    fold            = ajStrNew();
    class           = ajStrNew();
    outfile         = ajStrNew();
    
    if(!path || !seq || !extn || !scoplist)
    {
        ajWarn("Bad arguments passed to libscan_ProfileLibScan\n");
        return ajFalse;
    }
    
    /* get the models */
    modelnames = libscan_GetLibrary(path,extn);

    tmplist     = ajListNew();
    
    /* Initialise random number generator for naming of temp. files
       and create hmmer output file */
    ajRandomSeed();
    ajStrAssC(&tmpname, ajFileTempName(NULL));
    
    ajStrAssS(&profileinfname, tmpname);
    ajStrAppC(&profileinfname, ".profileinf");
    
    profileinf = ajFileNewOut(profileinfname);
    ajFmtPrintF(profileinf,">%S\n%S\n",seq->Name,seq->Seq);
    ajFileClose(&profileinf);
    
    ajStrAssS(&outfile,seq->Name);
    ajStrApp(&outfile,profoutextn);

    iter = ajListIter(modelnames);
    /*Start of main application loop*/   
    while((profile = (AjPStr)ajListIterNext(iter)))
    {
        /* get the Sunid_Family from the profile. THIS WILL NEED TO BE CHANGED */
        posdash = ajStrRFindC(profile, "/");
        posdot  = ajStrRFindC(profile, ".");    
        
        if(posdash >= posdot)
            ajWarn("Could not create filename. Email rranasin@hgmp.mrc.ac.uk");
        else
        {
            ajStrAssSub(&sunidfrag, profile, posdash+1, posdot-1);
            ajStrToInt(sunidfrag,&sunid);
        }
        
        /* do a binary search on scoplist to find the relavent entry */
        if(!(libscan_SunidToScopInfo(sunid,&family,&superfamily,
				     &fold, &class, scoplist)))
            ajFatal("libscan_SunidToScopInfo failed in libscan_ProfileLibScan."
		    " email rranasin@hgmp.mrc.ac.uk\n");
        
        ajRandomSeed();
        ajStrAssC(&tmpname, ajFileTempName(NULL));
          
        ajStrAssS(&profileoutfname, tmpname);
        ajStrAppC(&profileoutfname, ".profileoutf");
            
        libscan_RunProphet(profile, profileinfname, gapopen, gapextn, profileoutfname);                    
    
        /* open hmmsearch output file */
        if(!(inf = ajFileNewIn(profileoutfname)))
            ajWarn("File %S could not be opened\n",profileoutfname);
    
        while(ajFileReadLine(inf,&line))
        {
            if((ajStrPrefixC(line,"Local:")))
            {
                /* GET THE ID */
                ajFmtScanS(line,"%*s %*s %*s %S",&id);
                ajStrAssC(&sequence,"");
            }

            /* GET THE SCORE */
            else if(ajStrPrefixC(line,"Score:"))
                ajFmtScanS(line,"%*s %f",&score);
            /* GET THE SEQUENCE */

            else if(ajStrPrefix(line,id))
            {
                ajFmtScanS(line,"%*s %d %S %d",&tmpstart,&seqfrag,&end);
        
                /* get start position from the first seqfrag only */
                if(!ajStrCmpC(sequence,""))
                    start = tmpstart;
        
                ajStrSubstituteCC(&seqfrag,".","");
                ajStrApp(&sequence,seqfrag);
            }

            else
                continue;
        }
            
        /* construct the scophit structure */
        hit = ajDmxScophitNew();
	ajStrAssS(&hit->Class,class);
        ajStrAssS(&hit->Fold,fold);
        ajStrAssS(&hit->Superfamily,superfamily);
        ajStrAssS(&hit->Family,family);
        ajStrAssS(&hit->Acc,id);
        ajStrAssS(&hit->Model,model);
        ajStrAssS(&hit->Seq,sequence);
        hit->Sunid_Family = sunid;
        hit->Score = score;
        hit->Start = start;
        hit->End = end;

            
        /*push the scop hit onto list */
        ajListPushApp(tmplist,(AjPScophit) hit);
            
        ajFileClose(&inf);
        ajSysUnlink(&profileoutfname);  
    }   
    ajListIterFree(iter);


    /* CALCULATE THE DISTRIBUTION WITH THE TRUE HITS AND CROSS HITS
       REMOVED FROM THE LIST */
    pointlist = libscan_CalcLibscanDistribution(tmplist);

    if(ajListLength(pointlist)!=0)
    {	
	profoutf = ajFileNewOutD(profoutpath,outfile);
	
	familyhits  = ajListNew();
	
	/* convert the original list of hits to an array for convenience */ 
	nhits = ajListToArray(tmplist,(void ***)&hits);
	
	/* DO A SECOND PARSE THROUGH THE HITS FILE AND CALCqULATE THE
           P-VALUES */
	for(i=0;i<nhits;i++)
	{
	    scophit = ajDmxScophitNew();
	    pvalue = libscan_ScoreToPvalue(hits[i]->Score,pointlist);
	    hits[i]->Pval = pvalue;
	    ajDmxScophitCopy(&scophit,hits[i]);
	    ajListPushApp(familyhits,scophit);
	}
     
	/*sort the list before printing */
        ajListSort(familyhits,ajDmxScophitCompPval);

	/* write out the familyhits list */
	ajDmxScophitsWrite(profoutf,familyhits);
	ajFileClose(&profoutf);
	
	AJFREE(hits);

	/* push on to the merge list the hits with the p-values calculated */
	iter = ajListIter(familyhits);
	while((mhit = (AjPScophit)ajListIterNext(iter)))
	    ajListPushApp(*mrglist,(AjPScophit) mhit);
	ajListIterFree(iter); 
	ajListDel(&familyhits);
	ajSysUnlink(&profileinfname);
	
	
	/* delete and clean up pointlist */
	iter=ajListIter(pointlist);
	while((delpoint=(LibscanPCoord)ajListIterNext(iter)))
	    libscan_CoordDel(&delpoint);
	ajListIterFree(iter);
	ajListDel(&pointlist);  
    }
    
    /* delete and clean up tmplist */
    iter=ajListIter(tmplist);
    while((hit=(AjPScophit)ajListIterNext(iter)))
        ajDmxScophitDel(&hit);
    ajListIterFree(iter);
    ajListDel(&tmplist);
    
    
    /* delete and clean up modelnames */
    iter=ajListIter(modelnames);
    ajStrDel(&tmpname);    while((tmpname=(AjPStr)ajListIterNext(iter)))
        ajStrDel(&tmpname);
    ajListIterFree(iter);
    ajListDel(&modelnames); 
/*CORRECTION*/    ajStrDel(&class);
    ajStrDel(&tmpname);
    ajStrDel(&id);
    ajStrDel(&line);
    ajStrDel(&seqfrag);
    ajStrDel(&sequence);
    ajStrDel(&profile);
    ajStrDel(&tmpname);
    ajStrDel(&outfname);
    ajStrDel(&sunidfrag);
    ajStrDel(&fold);
    ajStrDel(&superfamily);
    ajStrDel(&family);
    ajStrDel(&profileinfname);
    ajStrDel(&profileoutfname);
    ajStrDel(&outfile);
    
    return ajTrue;
    
}


/* @funcstatic libscan_SignatureLibScan ***************************************
**
** Scan a protein sequence against a library of Signature models. The 
** models represents SCOP portein domain families. 
**
** @param [r] db       [AjPSeqset]  Name of sequence file. 
** @param [r] path     [AjPStr]     Directory of profile models.
** @param [r] extn     [AjPStr]     File extension of models.
** @param [r] scoplist [AjPList]    List of scop objects.
**
** @return [AjPList] retuns familyhits.
** @@
** 
******************************************************************************/
static AjBool libscan_SignatureLibScan(AjPSeq seq, AjPStr path, AjPStr extn,
				       float gapopen, float gapextn, 
				       AjPMatrixf sub,  ajint ntopt,
				       AjPList scoplist, AjPStr model, 
				       AjPStr sigoutpath, AjPStr sigoutextn,
				       AjPList* mrglist)
{
    AjPSignature sig   = NULL;		/* Signature data structure*/

    AjPStr sigfile     = NULL;		/* name of seqret output file */
    AjPStr tmpname     = NULL;
    AjPStr outfile     = NULL;
    
    AjPFile sigin      = NULL;
    AjPFile sigoutf    = NULL;
    
    AjPScophit hit     = NULL;
    AjPScophit* hits   = NULL;
    AjPScophit scophit = NULL;
    AjPScophit mhit    = NULL;  
    
    AjPHit rawhit      = NULL;		/* Scophit structure */
    
    ajint nhits        = 0;

    ajint i            = 0;

    float pvalue       = 0.0;

    AjPList familyhits = NULL;		/* a list of hits */
    AjPList modelnames = NULL;		/* A list of model names */
    AjPList pointlist  = NULL;
    AjPList tmplist    = NULL;

    LibscanPCoord delpoint  = NULL;
   
    AjIList iter       = NULL;

    tmpname     = ajStrNew();
    outfile     = ajStrNew();
    

    if(!path || !seq || !extn || !scoplist)
    {
        ajWarn("Bad arguments passed to libscan_SignatureLibScan\n");
        return ajFalse;
    }

    /* get the models */
    modelnames = libscan_GetLibrary(path,extn);

    tmplist     = ajListNew();

    ajStrAssS(&outfile,seq->Name);
    ajStrApp(&outfile,sigoutextn);

    iter = ajListIter(modelnames);
    while((sigfile=(AjPStr)ajListIterNext(iter)))
    {
	 sigin  = ajFileNewIn(sigfile);
        
        /* READ SIGNATURE FILE */
	 if(!(sig=embSignatureReadNew(sigin)))
        {       
            ajMatrixfDel(&sub);
            ajFileClose(&sigin);
            return ajFalse;
            ajFatal("Error reading signature file");
        }        
        else
            ajFmtPrint("Signature file read ok\n");
        
        
	/* COMPILE SIGNATURE */
        if(!embSignatureCompile(&sig, gapopen, gapextn, sub))
        {     
            embSignatureDel(&sig);
            ajMatrixfDel(&sub);
            ajFileClose(&sigin);
            return ajFalse;
            ajFatal("Error compiling signature");
        }       
        else
	{
	    if(!sig)
		continue;
	    ajFmtPrint("Signature compiled ok\n");    
       }
	 
        
        /* Allocate memory for hit */
        rawhit = embHitNew();
     
        if(!embSignatureAlignSeq(sig, seq, &rawhit, ntopt))
        {       
            embHitDel(&rawhit);
/*CORRECTION*/            ajFileClose(&sigin);
/*CORRECTION*/            embSignatureDel(&sig);
            continue;
        }

	/* create a hit */
	hit = ajDmxScophitNew();
	
        ajStrAssS(&hit->Class,sig->Class);
        ajStrAssS(&hit->Fold,sig->Fold);
        ajStrAssS(&hit->Superfamily,sig->Superfamily);
        ajStrAssS(&hit->Family,sig->Family);
        hit->Sunid_Family = sig->Sunid_Family;
        ajStrAssS(&hit->Acc,rawhit->Acc);
	ajStrAssS(&hit->Seq,rawhit->Seq);
	ajStrAssS(&hit->Model,model);
	hit->Score = rawhit->Score;
	hit->Start = rawhit->Start;
	hit->End   = rawhit->End;

        ajListPush(tmplist,(AjPScophit) hit);
        embHitDel(&rawhit);
        embSignatureDel(&sig);
        ajFileClose(&sigin); 

    }
    ajListIterFree(iter);

    /* CALCULATE THE DISTRIBUTION WITH THE TRUE HITS AND CROSS HITS
       REMOVED FROM THE LIST */
    pointlist = libscan_CalcLibscanDistribution(tmplist);

    if(ajListLength(pointlist)!=0)
    {
	familyhits  = ajListNew();

	/* convert the original list of hits to an array for convenience */ 
	nhits = ajListToArray(tmplist,(void ***)&hits);

	sigoutf = ajFileNewOutD(sigoutpath,outfile);
	
	/* DO A SECOND PARSE THROUGH THE HITS FILE AND CALCULATE THE
           P-VALUES */
	for(i=0;i<nhits;i++)
	{
	    scophit = ajDmxScophitNew();

	    pvalue = libscan_ScoreToPvalue(hits[i]->Score,pointlist);
	    hits[i]->Pval = pvalue;
	    ajDmxScophitCopy(&scophit,hits[i]);
	    ajListPushApp(familyhits,scophit);
	}
	
	/*sort the list before printing */
        ajListSort(familyhits,ajDmxScophitCompPval);

	/* write out the familyhits list */
	ajDmxScophitsWrite(sigoutf,familyhits);
	ajFileClose(&sigoutf);
    
    	AJFREE(hits);
	
	/* push on to the merge list the hits with the p-values calculated */
	iter = ajListIter(familyhits);
	while((mhit = (AjPScophit)ajListIterNext(iter)))
	    ajListPushApp(*mrglist,(AjPScophit) mhit);
	ajListIterFree(iter);

	/*CORRECTION*/	ajListDel(&familyhits);
	

	/* delete and clean up pointlist */
	iter=ajListIter(pointlist);
	while((delpoint=(LibscanPCoord)ajListIterNext(iter)))
	    libscan_CoordDel(&delpoint);
	ajListIterFree(iter);
	ajListDel(&pointlist); 

    }
    
    /* delete and clean up tmplist */
    iter=ajListIter(tmplist);
    while((hit=(AjPScophit)ajListIterNext(iter)))
        ajDmxScophitDel(&hit);
    ajListIterFree(iter);
    ajListDel(&tmplist);

    /* delete and clean up modelnames */
    iter=ajListIter(modelnames);
    while((tmpname=(AjPStr)ajListIterNext(iter)))
        ajStrDel(&tmpname);
    ajListIterFree(iter);
    ajListDel(&modelnames); 

    ajStrDel(&outfile);

    return ajTrue;
    
}


/* @funcstatic libscan_RunHmmerInModeOne **************************************
**
** Scan database with hidden markov model. 
**
** @param [r] hit1
** @param [r] hit2
**
** @return [AjBool]
** @@
******************************************************************************/
static AjBool libscan_RunHmmerInModeOne(AjPSeqset db, AjPStr hmmpath,
					AjPStr hmmextn, AjPStr *mode,
					ajint overlap, ajint maxhits,
					AjPStr model,
					AjPList targetlist, AjPList scoplist,
					AjPStr hmmoutpath, AjPStr hmmoutextn,
					AjPList* mrglist)
{
    AjPList hmmlist    = NULL;		/* a list of hmm file names */
    
    AjPStr hmmfile     = NULL;
    AjPStr family      = NULL;
    AjPStr superfamily = NULL;
    AjPStr fold        = NULL;
    AjPStr class       = NULL;
    AjPStr sunid       = NULL;
    AjPStr hmmsearch   = NULL;
    
    AjPFile hmmoutf    = NULL;

    ajint posdash;
    ajint posdot;       
    ajint sun_id;    

    sunid       = ajStrNew();
    hmmsearch   = ajStrNew();
    family      = ajStrNew();
    superfamily = ajStrNew();
    fold        = ajStrNew();
    class       = ajStrNew();

    if(ajStrChar(*mode,0)=='1')
    {   
        hmmlist = libscan_GetLibrary(hmmpath,hmmextn);
        
        /*Start of main application loop*/   
        while(ajListPop(hmmlist,(void **)&hmmfile))
        {
            /* get the "seed" bit of filenames from the hmmfile */
            posdash = ajStrRFindC(hmmfile, "/");
            posdot  = ajStrRFindC(hmmfile, ".");
        
	    
            if(posdash >= posdot)
                ajFatal("Could not create filename. Email rranasin@hgmp.mrc.ac.uk");
	    
            else
            {
                /* get the Family_Sunid */
                ajStrAssSub(&sunid, hmmfile, posdash+1, posdot-1);
		
                /* CREAT OUTPUT FILE NAMES */
                ajStrAssS(&hmmsearch,sunid);
                ajStrApp(&hmmsearch, hmmoutextn);
		
		
                /* CREAT OUTPUT STREAMS */
                hmmoutf = ajFileNewOutD(hmmoutpath,hmmsearch);
            
                ajStrToInt(sunid,&sun_id);
            
                /* do a binary search on scoplist to find the relavent entry */
                if(!(libscan_SunidToScopInfo(sun_id,&family,&superfamily,
					     &fold, &class, scoplist)))
                    ajFatal("libscan_SunidToScopInfo failed in "
			    "libscan_RunHmmerInModeOne. "
			    "email rranasin@hgmp.mrc.ac.uk\n");
            

                /* READ SCOP FAMILIES FILE & FILL THE LIST OF TARGETS*/
		
                /* search with HMM */
                libscan_HmmSearch(db,hmmfile,targetlist,
				  family,superfamily,fold,class,
				  sun_id,overlap,maxhits,model,
				  hmmoutf,mrglist);
                ajFileClose(&hmmoutf);
		ajStrDel(&hmmfile);
	    }
        }
	
	ajListDel(&hmmlist);
	
	
	ajStrDel(&sunid);
	ajStrDel(&hmmsearch);
	ajStrDel(&family);
	ajStrDel(&superfamily);
	ajStrDel(&fold);   
     /* CORRECTION */ 	ajStrDel(&class);        
	return ajTrue;
    } 
    
    else
    {
	ajStrDel(&hmmfile);
	ajStrDel(&sunid);
	ajStrDel(&hmmsearch);
	ajStrDel(&family);
	ajStrDel(&superfamily);
	ajStrDel(&fold);
	ajStrDel(&class);
       
        return ajFalse;
    }
}       


/* @funcstatic libscan_RunHmmerInModeTwo **************************************
**
** Scan sequences with hidden markov model. 
**
** @param [r] 
** @param [r] 
**
** @return [AjBool] 
** @@
******************************************************************************/

static AjBool libscan_RunHmmerInModeTwo(AjPSeqset db, AjPStr hmmpath,
					AjPStr hmmextn, AjPStr *mode, AjPList
					scoplist, AjPStr model, AjPStr
					hmmoutpath, AjPStr hmmoutextn, AjPList*
					mrglist)
{
    AjPSeq seq = NULL;
    ajint i;
						   
    if(ajStrChar(*mode,0)=='2') 
    {
        for(i=0;i<db->Size;i++)
        {
            seq = ajSeqNew();
            ajStrAssS(&seq->Name,db->Seq[i]->Name);
            ajStrAssS(&seq->Seq,db->Seq[i]->Seq);
            
            /* search a library of hidden markov models */
            libscan_HmmLibScan(seq,hmmpath,hmmextn,scoplist,model,
			       hmmoutpath,hmmoutextn,mrglist);
            
            ajSeqDel(&seq);
            
        }
       
        return ajTrue;
    }

    else
        return ajFalse;
}


/* @funcstatic libscan_RunProphetInModeOne ************************************
**
** Scan database with profile model. 
**
** @param [r] hit1
** @param [r] hit2
**
** @return [AjBool]
** @@
******************************************************************************/
static AjBool libscan_RunProphetInModeOne(AjPSeqset db, AjPStr profpath,
					  AjPStr profextn, float gapo,
					  float gape, 
					  AjPStr *mode, ajint overlap,
					  ajint maxhits, AjPStr model,
					  AjPList targetlist, AjPList scoplist,
					  AjPStr profoutpath,
					  AjPStr profoutextn,
					  AjPList* mrglist)
{
    AjPList proflist    = NULL;		/* a list of hmm file names */
    
    AjPStr profile      = NULL;
    AjPStr family       = NULL;
    AjPStr superfamily  = NULL;
    AjPStr fold         = NULL;
    AjPStr class        = NULL;
 
    AjPStr sunid        = NULL;
    AjPStr profsearch   = NULL;
    
    AjPFile profoutf    = NULL;
    
    ajint posdash;
    ajint posdot;       
    
    ajint sun_id;
    
    
    sunid       = ajStrNew();
    profsearch  = ajStrNew();
    family      = ajStrNew();
    superfamily = ajStrNew();    
    fold        = ajStrNew();
    class       = ajStrNew();

    if(ajStrChar(*mode,0)=='1')
    {
        proflist = libscan_GetLibrary(profpath,profextn);
      
        /*Start of main application loop*/   
        while(ajListPop(proflist,(void **)&profile))
        {
            /* get the "seed" bit of filenames from the gbvfile */
            posdash = ajStrRFindC(profile, "/");
            posdot  = ajStrRFindC(profile, ".");
            
            if(posdash >= posdot)
                ajFatal("Could not create filename. Email rranasin@hgmp.mrc.ac.uk");

            else
            {
                /* Add a '.' to outextn if one does not already exist
                   if((ajStrChar(outextn, 0)!='.'))       
                   ajStrInsertC(&outextn, 0, ".");*/

                /* get the Family_Sunid */
                ajStrAssSub(&sunid, profile, posdash+1, posdot-1);
         
                /* CREAT OUTPUT FILE NAMES */
                ajStrAssS(&profsearch,sunid);
                ajStrApp(&profsearch, profoutextn);
                                      
                /* CREAT OUTPUT STREAMS */
                profoutf = ajFileNewOutD(profoutpath,profsearch);
                 
                ajStrToInt(sunid,&sun_id);
                 
                /* do a binary search on scoplist to find the relavent entry */
                if(!(libscan_SunidToScopInfo(sun_id,&family,&superfamily,
					     &fold, &class, scoplist)))
                    ajFatal("libscan_SunidToScopInfo failed in "
			    "libscan_RunProphetInModeOne. "
			    "email rranasin@hgmp.mrc.ac.uk\n");
                                  
                /* search with Gribskov Profile */
                libscan_ProfileSearch(db,profile,gapo,gape,targetlist,
				      family,superfamily,fold,class,
				      sun_id,overlap,maxhits,model,
				      profoutf,mrglist);
                ajFileClose(&profoutf);
	    }   
	    ajStrDel(&profile);
	}

	ajListDel(&proflist);
	ajStrDel(&sunid);
	ajStrDel(&profsearch);
	ajStrDel(&family);
	ajStrDel(&superfamily);
	ajStrDel(&fold); 
	ajStrDel(&class); 
        return ajTrue;
    }
    
    else
    {
	ajStrDel(&profile);
	ajStrDel(&sunid);
	ajStrDel(&profsearch);
	ajStrDel(&family);
	ajStrDel(&superfamily);
	ajStrDel(&fold); 
	ajStrDel(&class);
	
        return ajFalse;
    }   
}



/* @funcstatic libscan_RunProphetInModeTwo ************************************
**
** Scan sequences with hidden markov model. 
**
** @param [r] 
** @param [r] 
**
** @return [AjBool] 
** @@
******************************************************************************/
static AjBool libscan_RunProphetInModeTwo(AjPSeqset db, AjPStr profpath,
					  AjPStr profextn, float gapo,
					  float gape, AjPStr *mode,
					  AjPList scoplist, AjPStr model,
					  AjPStr profoutpath, 
					  AjPStr profoutextn, AjPList* mrglist)
{
    AjPSeq seq   = NULL;

    ajint i;

    if(ajStrChar(*mode,0)=='2') 
    {
        for(i=0;i<db->Size;i++)
        {
            seq = ajSeqNew();
            ajStrAssS(&seq->Name,db->Seq[i]->Name);
            ajStrAssS(&seq->Seq,db->Seq[i]->Seq);
            
            
            /* search a library of gribskov profiles */
            libscan_ProfileLibScan(seq,profpath,profextn,gapo,gape,
				   scoplist,model,profoutpath,profoutextn,
				   mrglist);
            
            ajSeqDel(&seq);
            
        }
        return ajTrue;
    }

    else
        return ajFalse;
    
}


/* @funcstatic libscan_RunSignatureInModeOne **********************************
**
** Scan database with signatures. 
**
** @param [r] hit1
** @param [r] hit2
**
** @return [AjBool]
** @@
******************************************************************************/
static AjBool libscan_RunSignatureInModeOne(AjPSeqset db, AjPStr sigpath,
					    AjPStr sigextn, float gapo, 
					    float gape, AjPMatrixf sub,
					    ajint ntopt, AjPStr *mode, 
					    ajint overlap, ajint maxhits,
					    AjPStr model, AjPList targetlist,
					    AjPList scoplist, 
					    AjPStr sigoutpath,
					    AjPStr sigoutextn,
					    AjPList* mrglist)
{
    AjPList siglist     = NULL;		/* a list of hmm file names */
    
    AjPStr sigfile      = NULL;
    AjPStr family       = NULL;
    AjPStr superfamily  = NULL;
    AjPStr fold         = NULL;
    AjPStr class        = NULL;
    
    AjPStr sunid        = NULL;
    AjPStr sigsearch    = NULL;
    
    AjPFile sigoutf     = NULL;
    
    ajint posdash;
    ajint posdot;       
    ajint sun_id;
    
    sunid       = ajStrNew();
    sigsearch   = ajStrNew();
    family      = ajStrNew();
    superfamily = ajStrNew();
    fold        = ajStrNew();
    class       = ajStrNew();
    
    if(ajStrChar(*mode,0)=='1')
    {
        siglist = libscan_GetLibrary(sigpath,sigextn);

      
        /*Start of main application loop*/   
        while(ajListPop(siglist,(void **)&sigfile))
        {
            /* get the "seed" bit of filenames from the gbvfile */
            posdash = ajStrRFindC(sigfile, "/");
            posdot  = ajStrRFindC(sigfile, ".");
            
            if(posdash >= posdot)
                ajFatal("Could not create filename. Email rranasin@hgmp.mrc.ac.uk");

            else
            {
                /* Add a '.' to outextn if one does not already exist
                   if((ajStrChar(outextn, 0)!='.'))       
                   ajStrInsertC(&outextn, 0, ".");*/

                /* get the Family_Sunid */
                ajStrAssSub(&sunid, sigfile, posdash+1, posdot-1);
         
                /* CREAT OUTPUT FILE NAMES */
                ajStrAssS(&sigsearch,sunid);

                ajStrApp(&sigsearch, sigoutextn);
                                      
                /* CREAT OUTPUT STREAMS */
                sigoutf = ajFileNewOutD(sigoutpath,sigsearch);

                 
                ajStrToInt(sunid,&sun_id);
                 
                /* do a binary search on scoplist to find the relavent entry */
                if(!(libscan_SunidToScopInfo(sun_id,&family,&superfamily,
					     &fold,&class,scoplist)))
                    ajFatal("libscan_SunidToScopInfo failed. "
			    "email rranasin@hgmp.mrc.ac.uk\n");
                 
		/* search with Signature */
                libscan_SignatureSearch(db,sigfile,sub,gapo,gape,ntopt,
					targetlist,family,superfamily,
					fold,class,sun_id,overlap,maxhits,
					model,sigoutf,mrglist);
                ajFileClose(&sigoutf);
            }   
            ajStrDel(&sigfile);
        }
	ajListDel(&siglist);
	ajStrDel(&sunid);
	ajStrDel(&sigsearch);
	ajStrDel(&family);
	ajStrDel(&superfamily);
	ajStrDel(&fold);
	ajStrDel(&class);
        return ajTrue;
    }
    
    else
    {
	ajStrDel(&sigfile);
	ajStrDel(&sunid);
	ajStrDel(&sigsearch);
	ajStrDel(&family);
	ajStrDel(&superfamily);
	ajStrDel(&fold); 
	ajStrDel(&class);
	
	return ajFalse;
    }
}


/* @funcstatic libscan_RunSignatureInModeTwo **********************************
**
** Scan sequences library of sigantures. 
**
** @param [r] 
** @param [r] 
**
** @return [AjBool] 
** @@
******************************************************************************/
static AjBool libscan_RunSignatureInModeTwo(AjPSeqset db, AjPStr sigpath,
					    AjPStr sigextn, 
					    float gapo,float gape,
					    AjPMatrixf sub, ajint ntopt, 
					    AjPStr *mode, AjPList scoplist,
					    AjPStr model, AjPStr sigoutpath, 
					    AjPStr sigoutextn,
					    AjPList* mrglist)
{
        
    AjPSeq seq   = NULL;
    ajint i;

    if(ajStrChar(*mode,0)=='2') 
    {
	 for(i=0;i<db->Size;i++)
	 {
	     seq = ajSeqNew();
	     ajStrAssS(&seq->Name,db->Seq[i]->Name);
	     ajStrAssS(&seq->Seq,db->Seq[i]->Seq);            
            
	     ajSeqDel(&seq);
	 }

        for(i=0;i<db->Size;i++)
        {
            seq = ajSeqNew();
            ajStrAssS(&seq->Name,db->Seq[i]->Name);
            ajStrAssS(&seq->Seq,db->Seq[i]->Seq);            

            /* search a library of signature */
            libscan_SignatureLibScan(seq,sigpath,sigextn,gapo,gape,
				     sub,ntopt,scoplist,model,sigoutpath,
				     sigoutextn,mrglist);
            
            ajSeqDel(&seq);
        }
        return ajTrue;
    }

    else
        return ajFalse;
    
}









/* @funcstatic libscan_CombineScophitsPvalues *********************************
**
**   In either mode, the mrglist contains the total results of potentially multiple modelds
**   versus potentially multiple sequences.
**   
**   mrglist is sorted so that
**   in mode 1 hits are merged with identical accession numbers, e.g. the 1st three:
**   fam1 (HMM)  ACC1   10
**   fam1 (Grb)  ACC1   12
**   fam1 (Sig)  ACC1   13
**   fam1 (HMM)  ACC2   15
**   fam1 (Grb)  ACC2   16
**   fam1 (Sig)  ACC2   17
**   fam2 (HMM)  ACC1   10
**   fam2 (Grb)  ACC1   12
**   fam2 (Sig)  ACC1   13
**   fam2 (HMM)  ACC2   15
**   fam2 (Grb)  ACC2   16
**   fam2 (Sig)  ACC2   17
**   .
**   .
**   .
**   
**  
**   in mode 2 hits are merged with identical family Sunids's, e.g. the 1st three:
**   acc1 (HMM)  FAM1   10
**   acc1 (Grb)  FAM1   12
**   acc1 (Sig)  FAM1   13
**   acc1 (HMM)  FAM2   10
**   acc1 (Grb)  FAM2   12
**   acc1 (Sig)  FAM2   13
**   acc2 (HMM)  FAM1   10
**   acc2 (Grb)  FAM1   12
**   acc2 (Sig)  FAM1   13
**   .
**   .
**   .
******************************************************************************/


static AjBool libscan_CombineScophitsPvalues(ajint mode, AjPStr outpath,
					     AjPStr outextn,
					     AjPList targetlist, 
					     AjPList mrglist, ajint overlap,
					     ajint maxhits, ajint n)
{
    AjPScophit hit     = NULL;
    AjPScophit tmphit  = NULL;
    AjPScophit nexthit = NULL;
    
    AjPScophit mrghit  = NULL;
    AjPScophit tmphit1 = NULL;

    AjPScophit tmphit2 = NULL;
    
    AjPHitlist tmphitlist=NULL;
    AjIList    tmpiter   =NULL;
    
    
    AjPScophit* arr        = NULL;
    
    AjIList iter       = NULL;
    AjIList iter2      = NULL;
    
    AjPList newlist    = NULL;
    AjPList tmplist    = NULL;
    
    float productP     = 0.0;   
    
    ajint i    = 0;
    ajint j    = 0;
    ajint nmod = 0;			/* no of models with overlap */
    
    ajint narr = 0;
    ajint freq = 0;
    
    float fraction = 0.0;
    
    
    AjPStr outfile     = NULL;
    AjPFile outf    = NULL;
    
    
    newlist    = ajListNew();
    tmplist    = ajListNew();
    
    if(!mrglist)
        ajFatal("Merged list does not exit!");
    
    /* models vs sequences */
    if(mode==1)
	ajListSort3(mrglist, ajDmxScophitCompSunid,
		    ajDmxScophitCompAcc, ajDmxScophitCompStart);
    
    /* sequences vs models */
    else if(mode==2)	
	ajListSort3(mrglist, ajDmxScophitCompAcc,
		    ajDmxScophitCompSunid, ajDmxScophitCompStart);
    
    /* incorrect mode */
    else
	ajFatal("Unknown mode in libscan_CombineScophitsPvalues");
    
    
    iter   = ajListIter(mrglist);
    hit    = (AjPScophit)ajListIterNext(iter);
    mrghit = ajDmxScophitNew();
    ajDmxScophitCopy(&mrghit, hit);
    
    
    productP = hit->Pval;
    
    /* models vs sequences */
    while((nexthit=(AjPScophit)ajListIterNext(iter)))
    {
	/* Check if we're on the same family / acc. no. */
	if(((mode==1) && (hit->Sunid_Family==nexthit->Sunid_Family)) ||
	   ((mode==2) && (ajStrMatch(hit->Acc, nexthit->Acc))))
	{
	    /* Check if we're on the same accession number / family */
	    if(((mode==1) && (ajStrMatch(hit->Acc, nexthit->Acc)))  ||
	       ((mode==2) && (hit->Sunid_Family==nexthit->Sunid_Family)))
	    {
		if(embDmxScophitsOverlap(mrghit,nexthit,overlap))
		{
		    /* Check again to prevent any merging of
		       non-overlapping hits which might cause crashes
		       or unpredictable behaviour, e.g. where hit1 &
		       hit2 do not overlap but hit2 & hit3 do, mrghit
		       still pointing to hit1 */
		    if(embDmxScophitsOverlap(mrghit,nexthit,overlap))
		    {
			tmphit = mrghit;
		       
			mrghit = embDmxScophitMerge(mrghit,nexthit); 
			
			nmod++;		/* This must be reset to 0 */
			productP *= nexthit->Pval; /* This must be
						      reset to 0 */
			ajDmxScophitDel(&tmphit);
		    }
		}
	    }

	    /* Different acc. no. / family */
	    else
	    {
		/* If all <n> models have hit the same region 
		   put mrghit into newlist */
		if((nmod+1)==n)
		{
		    mrghit->Pval = productP;  
		    ajListPushApp(newlist,mrghit);
		    
		}
		/* If mrghit has been created but not all models
		   have hit the same region, delete mrghit */
		else
		{
		    ajDmxScophitDel(&mrghit);		    
		}
		
		nmod=0;
		productP=nexthit->Pval;
		mrghit=ajDmxScophitNew();
		ajDmxScophitCopy(&mrghit, nexthit);		
	    }
	}
	
	/* Different family / acc. no. */
	else
	{ 
	    /* If all <n> hits are to the same region 
	       put mrghit into newlist */
	    if((nmod+1)==n)
	    {
		mrghit->Pval = productP;
		ajListPushApp(newlist,mrghit);
		
	    }
	    /* If mrghit has been created but hits
	       are not to the same region, delete mrghit */
	    else
	    {
		ajDmxScophitDel(&mrghit);
	    }

	    
	    nmod=0;
	    productP=nexthit->Pval;
	    mrghit=ajDmxScophitNew();
	    ajDmxScophitCopy(&mrghit, nexthit);
	    

	    /* calculate the new significance for each hit */
	    narr = ajListToArray(newlist,(void***)&arr);
	    for(freq=0, i=0;i<narr;i++)
	    { 
		for(j=0;j<narr;j++)
		{
		    if(arr[i]->Pval > arr[j]->Pval)
			freq++;
		    else
			continue;
		}	
		
		/* this is the new p-value */
		fraction = ((float)freq/(float)narr);

		/*arr[i]->Pval = fraction;*/

		
		/*RAND's mods. */       
                tmphit1 = ajDmxScophitNew();
                ajDmxScophitCopy(&tmphit1, arr[i]);
                tmphit1->Pval = fraction;
                ajListPushApp(tmplist,tmphit1);
                freq=0;
	    }    		
	    
	    /* write the new p-values back into newlist 
	    iter2   = ajListIter(newlist);
	    i=0;
	    while((tmphit2=(AjPScophit)ajListIterNext(iter2)))
	    {
		tmphit2->Pval = arr[i]->Pval;
		i++;
	    } 
	    ajListIterFree(iter2); */
	    AJFREE(arr);
	    arr=NULL;
	    
	    
	    /* Write the output file. For mode 1 this will be a signature hits file and 
	       family Sunid's will be used for naming files, for mode 2 this will be a 
	       library scan file and accession numbers will be used for naming files */
	    outfile = ajStrNew();
	    
	    if(mode==1)
		ajFmtPrintS(&outfile, "%d", hit->Sunid_Family);
	    else
		ajStrAssS(&outfile, hit->Acc);

	    ajStrApp(&outfile,outextn);
	    outf = ajFileNewOutD(outpath,outfile);

	    
	    if(mode==1)
	    {
		tmphitlist=NULL;
		tmpiter   =NULL;

		/* tmpiter is freed in the function, tmphitlist must
                   be freed here */
		embDmxScophitsToHitlist(tmplist, &tmphitlist, &tmpiter);
		/* CORRECTION tmpiter is *not* freed in the function */
		/* CORRECTION */  ajListIterFree(tmpiter);
		
		tmpiter=NULL;
	     
		embHitlistClassify(&tmphitlist,targetlist,overlap);

		embDmxHitsWrite(outf, tmphitlist,maxhits);
		embHitlistDel(&tmphitlist);
	    }

	    else
	    {
		/* RAND's mods*/
                /*sort the list before printing */
                ajListSort(tmplist,ajDmxScophitCompPval);
        
                ajDmxScophitsWrite(outf, tmplist);
	    }


	    ajStrDel(&outfile);
	    ajFileClose(&outf);

	    /* clean up newlist */
	    iter2 = ajListIter(newlist);

	    while((tmphit2 = (AjPScophit)ajListIterNext(iter2)))
	    {
		ajDmxScophitDel(&tmphit2);
	    }

	    ajListDel(&newlist);
	    newlist = ajListNew();
	    ajListIterFree(iter2);


            /* clean up tmplist */
            iter2 = ajListIter(tmplist);
            while((tmphit2 = (AjPScophit)ajListIterNext(iter2)))
                ajDmxScophitDel(&tmphit2);
            ajListDel(&tmplist);
            tmplist = ajListNew();
            ajListIterFree(iter2);
	}

	hit=nexthit;	
    }

/*CORRECTION*/    	ajListIterFree(iter);		

    /* Process the last part of the list */
    /* THIS CODE BLOCK IS IDENTICAL TO THE ONE ABOVE */
    
    /* If all <n> models have hit the same region 
       put mrghit into newlist */
    if((nmod+1)==n)
    {	
	mrghit->Pval = productP;   
	ajListPushApp(newlist,mrghit);
	
    }
    /* If mrghit has been created but not all models
       have hit the same region, delete mrghit */
    else
    {
	ajDmxScophitDel(&mrghit);
	
    }    
    
    
    /* calculate the new significance for each hit */
    narr = ajListToArray(newlist,(void***)&arr);
    for(freq=0, i=0;i<narr;i++)
    {
	for(j=0;j<narr;j++)
	{
	    if(arr[i]->Pval > arr[j]->Pval)
		freq++;
	    else
		continue;
	}	
        
	/* this is the new p-value */
	fraction = ((float)freq/(float)narr);
/*	arr[i]->Pval = fraction; */
/*printf("fraction = %f freq= %d narr = %d\n",fraction,freq,narr);*/
        /* RAND's mods*/
        tmphit1 = ajDmxScophitNew();
        ajDmxScophitCopy(&tmphit1, arr[i]);
        tmphit1->Pval = fraction;
        ajListPushApp(tmplist,tmphit1);
        freq=0;
    }    		
    
    /* write the new p-values back into newlist 
    iter2   = ajListIter(tmplist);
    i=0;
    while((tmphit2=(AjPScophit)ajListIterNext(iter2)))
    {
	tmphit2->Pval = tmphit1->Pval;
	i++;
    } 
    ajListIterFree(iter2);*/
    AJFREE(arr);
    
    /* Write the output file. For mode 1 this will be a signature hits file and 
       family Sunid's will be used for naming files, for mode 2 this will be a 
       library scan file and accession numbers will be used for naming files */
    outfile = ajStrNew();
    
    if(mode==1)
	ajFmtPrintS(&outfile, "%d", hit->Sunid_Family);
    else
	ajStrAssS(&outfile, hit->Acc);
 
    ajStrApp(&outfile,outextn);

    outf = ajFileNewOutD(outpath,outfile);
    
    if(mode==1)
    {
	tmphitlist=NULL;
	tmpiter   =NULL;
	/* tmpiter is freed in the function, tmphitlist must be freed here */
	embDmxScophitsToHitlist(tmplist, &tmphitlist, &tmpiter);
/* CORRECTION tmpiter is not freed in the function */
/* CORRECTION */ 		ajListIterFree(tmpiter);	
	tmpiter=NULL;
	     
	embHitlistClassify(&tmphitlist,targetlist,overlap);

	embDmxHitsWrite(outf, tmphitlist, maxhits);
	embHitlistDel(&tmphitlist);
    }
    else
    {
	/* RAND's mods*/
        /*sort the list before printing */
        ajListSort(tmplist,ajDmxScophitCompPval);
	ajDmxScophitsWrite(outf, tmplist);
	/* CORRECTION ajListIterFree(iter);   */
    }
    
    ajStrDel(&outfile);
    ajFileClose(&outf);
    
    /* clean up newlist */
    iter2 = ajListIter(newlist);
    while((tmphit2 = (AjPScophit)ajListIterNext(iter2)))
	ajDmxScophitDel(&tmphit2);
    ajListDel(&newlist);
    ajListIterFree(iter2);
    


    /* clean up tmplist */
    iter2 = ajListIter(tmplist);
    while((tmphit2 = (AjPScophit)ajListIterNext(iter2)))
        ajDmxScophitDel(&tmphit2);
    ajListDel(&tmplist);
    ajListIterFree(iter2);
    
    ajListIterFree(iter);

    return ajTrue;
}



/* @funcstatic libscan_CalcLibscanDistribution ********************************
**
** Calculate the distribution from a list of hits.
**
** @param [r] listhits   [AjPList] List is hits 
** @param [r] fold        [AjPStr ] SCOP fold
** @param [r] superfamily [AjPStr ] SCOP superfamily
** @param [r] famly       [AjPStr ] SCOP family
** @param [r] sun_id      [ajint  ] SCOP family sunid
**
** @return [AjPList] A list of coordinates in a distribution.
** @@
******************************************************************************/
static AjPList libscan_CalcLibscanDistribution(AjPList scophits)
{
    AjPList pointlist = NULL;
    
    ajint i           = 0;
    ajint nhits       = 0;
    ajint high        = 0;
    ajint low         = 0;
    ajint freq        = 0;
    ajint interval    = 0;              /* the score interva, x-axis */

    LibscanPCoord  point   = NULL;	/* a Datapoint object to hold
					   individual coordinates */

    AjPScophit* hits  = NULL;
    
    if(!scophits)
        ajFatal("No list of hits passed to libscan_CalcDistribution\n");
    
    if(ajListLength(scophits)==0)
	return NULL;
    
    pointlist = ajListNew();

    /* but only remove them inside the libscan_CalcDistribution sub-routine */
    ajListGarbageCollect(scophits, ajDmxScophitDelWrap,
                         (int(*)(const void*)) ajDmxScophitCheckTarget);

    /* sort the list according to score */
    ajListSort(scophits,ajDmxScophitCompScore);

    /* convert list to array for convenience */
    nhits = ajListToArray(scophits,(void ***)&hits);

    if(!nhits)
	ajFatal("No hits in libscan_CalcDistribution!");
    
    low  = (ajint)hits[0]->Score;
    
    high = (ajint)hits[nhits-1]->Score;
    freq = 0;
    
    /* set the starting point */
    if(low > 0)
        interval = (low+1);
    
    else if(low < 0)
        interval = (low-1);
    
    for(i=0; i<nhits; i++)
    { 
	/* check if the array only contains only one hit */
	if((nhits)==1)
	{
	    point = libscan_CoordNew();
	    ajStrAssS(&point->Acc,hits[i]->Acc);
	    point->x = interval;
	    point->y = 1;

	    ajListPushApp(pointlist,point);
	    break;

	}		

        if(hits[i]->Score < (float)interval)
        {
            freq++;
	    
	    /* check to see if end of the array has been reached */
            if(interval == (ajint)hits[nhits-1]->Score)
            {
                point = libscan_CoordNew();
         
                ajStrAssS(&point->Acc,hits[i]->Acc);
                point->x = interval;
                point->y = freq;

                ajListPushApp(pointlist,point);
            }
        }
     
        else if(hits[i]->Score > (float)interval)
        { 
            while((float)interval <= hits[i]->Score)
            {           
                point = libscan_CoordNew();
         
                ajStrAssS(&point->Acc,hits[i]->Acc);
                point->x = interval;
                point->y = freq;
                
		ajListPushApp(pointlist,point);
                interval++;
        
            }

            freq++;
        }
    }

    AJFREE(hits);

    return pointlist;
}




/* @funcstatic libscan_CoordNew ***********************************************
**
** Coord object constructor. This is normally called by the
** ajDmxDiscordToCoords function.
**
** 
** @return [LibscanPCoord] Pointer to a Coord object
** @@
******************************************************************************/

static LibscanPCoord libscan_CoordNew(void)
{
    LibscanPCoord ret = NULL;

    AJNEW0(ret);
    ret->Class       = ajStrNew();
    ret->Fold        = ajStrNew();
    ret->Superfamily = ajStrNew();
    ret->Family      = ajStrNew();
    ret->Model_Type  = ajStrNew();
    ret->Acc         = ajStrNew();
    ret->Spr         = ajStrNew();
    ret->x           = 0.0;
    ret->y           = 0.0;

    return ret;
}




/* @funcstatic libscan_CoordDel ***********************************************
**
** Destructor for Coord object.
**
** @param [w] pthis [LibscanPCoord*] Coord object pointer
**
** @return [void]
** @@
******************************************************************************/

static void libscan_CoordDel(LibscanPCoord *pthis)
{
    ajStrDel(&(*pthis)->Class);
    ajStrDel(&(*pthis)->Fold);
    ajStrDel(&(*pthis)->Superfamily);
    ajStrDel(&(*pthis)->Family);
    ajStrDel(&(*pthis)->Acc);
    ajStrDel(&(*pthis)->Spr);
 
    AJFREE(*pthis);
    *pthis = NULL;
    
    return;
}






/* @funcstatic libscan_ScoreToPvalue ******************************************
**
** Read a score  and calculates the p-value. Relies on a list 
** of Coord objects sorted by score.
** 
** @param [r] score  [float]    The sunid_family 
** @param [r] list   [AjPList]  Sorted list of Coord objects
**
** @return [float] a p-value calculated from a list of scores.
** @@
*****************************************************************************/

static float libscan_ScoreToPvalue(float score, AjPList list)
{
    LibscanPCoord *arr = NULL;       /* array derived from list */
    ajint dim = 0;              /* size of the array */
    ajint idx = 0;              /* index into the array for the score */
    float p_value = 0.0;
    
    if(!score || !list)
        ajWarn("Bad args passed to libscan_ScoreToPvalue");
    
    dim = ajListToArray(list,(void***)&(arr));
    
    if(!dim)
        ajWarn("Empty list passed to libscan_ScoreToPvalue");
    
    if((idx = libscan_CoordBinSearchScore(score, arr, dim))==-1)
    {
      AJFREE(arr);
      ajFatal("libscan_ScoreToPvalue fatal error.");

      return p_value;
    }
    
    p_value = ((1-(float)arr[idx]->y/(float)arr[dim-1]->y));  
    AJFREE(arr);
    
    return p_value;
}





/* @funcstatic libscan_SunidToScopInfo ****************************************
**
** Read a sunid  and writes the relavent scop infomation for it. Relies on 
** a list of scop objects sorted by Sunid_Family code.
** 
** @param [r] sunid  [ajint]   The sunid_family 
** @param [w] family [AjPStr*]  Family 
** @param [w] superfamily [AjPStr*]  Superfamily
** @param [w] fold [AjPStr*]  Fold
** @param [w] klass [AjPStr*]  Class
** @param [r] list   [AjPList]  Sorted list of scop objects
**
** @return [AjBool]  True if a swissprot identifier code was found for the
**                    Scop code.
** @@
******************************************************************************/
static AjBool libscan_SunidToScopInfo (ajint sunid, AjPStr *family,
				       AjPStr *superfamily, AjPStr *fold,
				       AjPStr *klass, AjPList list)
{
    AjPScop *arr = NULL;             /* array derived from list */
    ajint dim    = 0;                /* size of the array */
    ajint idx    = 0; /* index into the array for the Sunid_family */

    AjPStr *class = NULL;

    class = klass;
    
    if(!sunid || !list)
    {
        ajWarn("Bad args passed to libscan_SunidToScopInfo");
        return ajFalse;
    }
    
    dim = ajListToArray(list,(void***)&(arr));
    
    if(!dim)
    {
        ajWarn("Empty list passed to libscan_SunidToScopInfo");
        return ajFalse;
    }

    if( (idx = ajScopArrFindSunid(sunid, arr, dim))==-1)
    {
        AJFREE(arr);
        return ajFalse;
    }   
    
    ajStrAssS(family, arr[idx]->Family);
    ajStrAssS(superfamily, arr[idx]->Superfamily);
    ajStrAssS(fold, arr[idx]->Fold);
    ajStrAssS(class, arr[idx]->Class);
    
    AJFREE(arr);

    return ajTrue;
}





/* @funcstatic libscan_CoordBinSearchScore ************************************
**
** Performs a binary search for a given score over an array of score generated
** from a model on a set of randomly generated protein sequences. 
**
** @param [r] score [float]           Search score
** @param [r] arr [LibscanPCoord*]    Array of LibscanPCoord objects
** @param [r] siz [ajint]            Size of array
**
** @return [ajint] Index of first AjPScop object found with an PDB code
** matching id, or -1 if id is not found.
** @@
******************************************************************************/

static ajint libscan_CoordBinSearchScore(float score, LibscanPCoord *arr,
					 ajint siz)
{
    int l;
    int m;
    int h;
  
    l = 0;
    h = siz-1;
  
    while(l<=h)
    {
        m = (l+h)>>1;
    
        if( (m==0) && (score < arr[m]->x))
          return m;

        else if( (m<siz-1) &&  (score >= arr[m]->x) && (score < arr[m+1]->x))
          return m;

        else if( (m==siz-1) &&  (score >= arr[m]->x))
          return m;

        else if(score < arr[m]->x)
          h=m-1;

        else if(score > arr[m]->x)
          l=m+1;
    }

    return -1;
}












