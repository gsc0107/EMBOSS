/* @source siggen application
**
** Generates a sparse protein signature from an alignment and residue contact 
** data.
** 
** @author: Copyright (C) Matt Blades (mblades@hgmp.mrc.ac.uk)
** @author: Copyright (C) Jon Ison (jison@hgmp.mrc.ac.uk)
** @@
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
**

*******************************************************************************
**  Application name
**  siggen
**
**
**  
**  Summary
**  Generates a sparse protein signature from an alignment and residue contact 
**  data.
**
**
**  
**  Input and Output
**  siggen reads a directory of scop family alignments file and, optionally, a
**  directory containing a contacts file for each domain in an alignment, and
**  generates a protein signature of a specified sparsity for each alignment.
**  The scop Sunid (an integer) of a family will be used as the base name for
**  its signature file. The paths and extensions for the alignment (input) and
**  signature (output) files are provided by the user. 
**
**
** 
**  Sister applications
**  A 'scop family alignment file' contains a sequence alignment of domains 
**  belonging to the same scop family.  The file is in embl-like format and is
**  annotated with records describing the SCOP classification of the family.  A
**  scop family alignment file generatd by scopalign will contain a structure-
**  based sequence alignment of domains of known structure only.  Such 
**  alignments can be extended with sequence relatives (of unknown structure)
**  to the family in question by using seqalign.
**  A 'contacts file' contains intra-chain residue-residue contact data for a
**  protein or domain.  The files are generated by contacts and are in embl-
**  like format.
**  A signature file is used by sigscan. 
**
**
**
**  Notes
**  In the case a signature file is generated by hand, it is essential that the 
**  gap data given is listed in order of increasing gap size.  
**
**  The user is prompted for a window size that is used for every position in 
**  the signature.  Likely this is not optimal.
**  A future implementation will provide a range of methods for generating 
**  values of window size depending upon the alignment (window size is 
**  identified by the WSIZ record in the signature output file).
**  
**  There are 3 modes for signatures generatation: (1) Use positions specified
**  in alignment file. The alignment file must contain a line beginning with 
**  the text 'Positions' for each line of the alignment.  A '1' in the 
**  'Positions' line indicates that the signature should include data from the
**  corresponding alignment site.  The signature will only include the 
**  positions that are marked with a '1'.  (2) Use a scoring method.  The 
**  alignment is scored (see 'Algorithm') and the signature of a specified 
**  sparsity is sampled from high scoring positions.  (3): Generate a 
**  randomised signature.  A signature of a specified sparsity is sampled at
**  random from the alignment.
**  
** 
**  
**  Known bugs & warnings
**  Handling of missing residues in scop alignment files
**  The alignment in the scop alignment file is generated by using stamp. 
**  stamp will omit from an alignment any residues that either completely lacks
**  electron density and so does not appear in the ATOM records of the pdb 
**  file, or which lacks a CA atom.  Such residues will of course not be 
**  present in the scop alignment file.  This means that acurate gap distances
**  (distance, in residues, between any two residues) for residues from two 
**  different alignment positions cannot reliably be found by simply counting
**  residues.  
** 
**  To overcome this problem, data from the clean domain coordinate files are
**  used.  These data should be used where available, i.e. the conoption acd
**  option should be set to a value 1, 2, 3 or 4 if possible.
**  
**  The function ajXyzPdbAtomIndexICA is used to create an array which gives 
**  the index into the full-length protein sequence for structured residues,
**  i.e. residues for which electron density was determined, EXCLUDING those
**  residues for which CA atoms are missing. The array length is of course 
**  equal to the number of structured residues.  This array is used for 
**  calculating the correct gap distances between residues in the alignment.
**  The clean domain coordinate files MUST be derived from clean protein 
**  coordinate files in which residues with a single atom only are ommitted.
**  Such files ccan be generated by pdbparse with the atommask option set to
**  True.  This requirement will not be necessary when a new version of 
**  ajXyzPdbAtomIndexICA which also excludes residues with a single atom only
**  becomes available.
**  
**  
**  
**  Description
**  This program is part of a suite of EMBOSS applications that directly or 
**  indirectly make use of the protein structure databases pdb and scop.  
**  This program is part of an experimental analysis pipeline described in an
**  accompanying document.  We provide the software in the hope that it will
**  be useful.  The applications were designed for specific research purposes
**  and may not be useful or reliable in contexts other than the described 
**  pipeline.  The development of the suite was coordinated by Jon Ison to
**  whom enquiries and bug reports should be sent (email jison@hgmp.mrc.ac.uk).
**  
**  Protein signatures are useful for characterising protein families and 
**  have been generated manually in the past (Ison et al, 2000).  siggen 
**  provides various methods to generate automatically protein signatures. 
**  
** 
**   
**  Algorithm
**  signature generation, proceeds in three stages as follows: (i) Read data 
**  and write residue-residue contact maps.  (ii) Apply selected scoring 
**  methods to potential signature positions.  (iii) Select residues to form
**  the signature and write residue identity and residue gap data into 
**  signature output file.
**  
**  Data Parsing
**  siggen reads scop alignment files and, optionally, clean domain coordinate
**  files and contact files corresponding to domains in the alignment.  A 
**  contact map for each protein domain in the structural alignment is used.
**  A contact map is an N by N matrix (where N is the length of the sequence),
**  a '1' at any element of the matrix indicates contact between the two 
**  residues at the corresponding positions, a '0' indicates no contact (see 
**  contacts.c for more information).  The data from the scop alignment files
**  are parsed, including the Post_Similar line, which is fundamental to the 
**  algorithm; the user specifies whether only alignment positions with a 
**  post_similar value of '1' are considered to be potential signature 
**  positions or whether all positions are considered as potential candidates.
**  Alignment positions where the Post_Similar value is represented by a '-' 
**  are not considered because one or more of the proteins in the alignment
**  were assigned a gap by the stamp program that was used to generate the 
**  alignment given in the scop alignment file (see  scopalign.c).
**  
**  Residue Scoring Schemes
**  The algorithm provides four scoring schemes that can be applied to aligned
**  positions (i.e. positions with Post_Similar values that is not '-' or, 
**  optionally, '0' either), to enable key residues to be selected for the 
**  final signature.  The schemes can be split into two groups: sequence based,
**  and structure based.  Each position in the alignment is scored on the basis
**  of a single or combination of 2 scoring schemes, one each from the different
**  groups, thus providing a method of refining/improving the generation
**  of signatures.  Every aligned position is allocated a normalised score 
**  based on one or more of the following schemes.
**  
**  Sequence Based Scoring - Residue Identity (ResId)
**  This scoring function simply takes every residue at a particular aligned
**  position, and calculates a score for the substitution of each residue pair,
**  using a residue substitution matrix.  The average residue substitution 
**  score for the position is then normalised and the score assigned to the 
**  score array for that alignment position.
**  
**  Sequence Based Scoring - Residue Variability (ResVar)
**  This scoring scheme implements the residue variability function of (Mirny
**  & Shakhnovich, 2001).
**
**  s(l) = - sum for i=1 to i=6 ( pi(l) x log pi(l) )
**  
**  Where s(l) is the variability at position l, and pi(l) is the frequency of
**  residues from class i at position l.  Six classes of residue are defined 
**  which reflect their physical-chemical properties and natural pattern of 
**  substitution as follows: (i) Aliphatic	(A, V, L, I, M, C); (ii) 
**  Aromatic (F, W, Y, H); (iii) Polar (S, T, N, Q); (iv) Basic (K, R); (v) 
**  Acidic (D, E); (vi) Special (G, P).  The special class represents the 
**  special conformational properties of glycine and proline.  As a result of
**  this classification mutations within a class are ignored  e.g. L to V, 
**  whereas mutations that change the residue class are taken into account.  
**  Thus each aligned position is given a normalised score that reflects the 
**  variability of all the residues in that particular position.
**  
**  Structure Based Scoring - Number of Residue-Residue Contacts (N-Con)
**  The contact scoring scheme provides a score based purely on structural 
**  information, i.e. the identity and nature of the residues are not 
**  considered.  The structural information used is the number of 
**  residue-residue contacts and the contact maps generated in the first phase
**  of the algorithm are used to derive the number of contacts made by residues
**  at aligned positions.  Each residue from an aligned position is noted, and
**  the position that residue occupies in its original protein sequence is 
**  determined.  The column of the contact map that corresponds to the position
**  of the residue in its original sequence is identified, the occurrence of a
**  '1' anywhere in that column of the matrix is recorded, and the total number
**  of '1's indicates the total number of contacts that residue makes. The 
**  number of contacts for each residue at a particular aligned position are 
**  determined, the average number of contacts is calculated and the resulting
**  value normalised.  This procedure is then repeated for every aligned position.
**  
**  Structure Based Scoring - Conservation of Residue Contacts (C-Con)
**  This scoring scheme extends the concept of the number of contacts residues
**  at aligned positions make, by also determining which residues are contacted
**  and their position in the alignment, thus providing a score representing
**  how conserved the contacts made by residues at an aligned position are.  
**  The initial stage of the process is identical to that for determining the
**  number of contacts, except every time a contact is found in the contact map,
**  the position of the contacted residue is recorded and its position in the 
**  alignment determined.  Each residue in an aligned position therefore has 
**  associated with it a list of positions in the alignment with which it makes
**  contact.  For example if all the residues at position 25 of the alignment
**  make contact with the residues at position 79 of the alignment, a conserved
**  contact is defined and a maximum score is allocated to the residues at 
**  position 25.  This procedure is repeated for all the contacts made by the 
**  residues at position 25 and an average normalised conservation of contact
**  score calculated.
**  
**  Selection of Signature Positions
**  The final phase of the algorithm involves selecting the residues that will 
**  make up the signature.  Following the scoring phase siggen will have 
**  created an array of scores for each scoring scheme employed, i.e. a score
**  will have been allocated for every position in the alignment with a 
**  Post_Similar value of '1' and optionally '0' also (depending on the 
**  Post_Similar option selected, see below).  If more than one scoring scheme
**  was used then the scores for each alignment position from the different 
**  scoring methods are added together, to give a final array (total score 
**  array) of the total scores for each position.  It is these final scores 
**  that determine which positions will make up the signature.
** 
**  Signature Sparsity
**  The signature sparsity is a user-defined parameter that determines how many
**  residues the final signature will contain, for example, if the average 
**  sequence length of the proteins in the alignment is 250 residues, then a 
**  signature of sparsity 10% (default value) will contain 25 key residues or
**  signature positions, that correspond to the top 25% highest scoring 
**  alignment positions.
**
**  
**  Key Residue Selection
**  Assuming that a signature of 10% sparsity is desired and the average 
**  sequence length of the proteins is 250 residues, the total score array is 
**  re-arranged into ascending order of score.  The top (highest scoring) 25 
**  alignment positions (equal to 10% sparsity) are then selected, it is these
**  25 positions which will make up the final signature.  These 25 highest 
**  scoring alignment positions are then traced back to the original protein 
**  sequences, the residue identities determined and gap data (number of 
**  residues between signature positions) calculated.  The signature output 
**  file is then written, this specifies for each of the 25 signature positions
**  the residues that are observed at that position in the alignment, and the 
**  gap (in residues) between that position and the next.  In the case of the
**  first signature position the gap data corresponds to the number of residues
**  between the beginning of the sequence and the first position.
**  
**  Signature Generating Parameters
**  The SigGen algorithm incorporates several options that can be selected when
**  generating a signature.  The first is the signature sparsity, which has 
**  been introduced above and affects the amount of information encoded in the
**  signature.  In addition to the four scoring schemes described above, there
**  are two further option to be considered when generating a signature.
**  
**  Post_Similar Option
**  This option determines which alignment positions should be considered as 
**  putative signature positions.  As mentioned above, the Post_Similar line 
**  represents aligned positions by either a '1' a '0' or a '-'.  SigGen gives
**  the option of considering both positions with values of '1' and '0' or 
**  ignoring positions represented by '0', which STAMP considers to be less 
**  structurally equivalent, and therefore use just positions with a 
**  Post_Similar value of  '1'.
**  
**  Contact Filtering Option
**  This option also determines which aligned positions should be considered 
**  as putative key residues for inclusion in the signature.  However, the 
**  criterion in this case is whether or not the average number of contacts
**  that the residues at that position make is above a defined threshold (the
**  contact threshold).  The default value is 10 contacts, i.e. only aligned 
**  positions that make on average 10 or more residue-residue contacts will be
**  considered as potential key residues.  As with all the SigGen parameters, 
**  they can be used in combination.  For example, selecting the following 
**  parameters: contact threshold = 10; residue identity and conservation of
**  contact scoring schemes; Post_Similar option set to ignore positions with
**  values of '0'; signature sparsity set to 15%, the SigGen algorithm would
**  proceed in the following manner: (i) Determine positions with Post_Similar
**  value of '1'; (ii) Determine which of those positions make greater than 10
**  residue contacts; (iii) Apply the residue id and conservation of contact 
**  scoring schemes to the positions resulting from the previous two filtering
**  steps;  (iv) Select the top scoring 15% positions to make up the signature.
**  (v) Write signature file.
**  
**  
**  
**  Usage 
**  An example of interactive use of siggen is shown below.
**  
**  Unix % siggen
**  Generates a sparse protein signature from an alignment and residue contact
**  data.
**  Location of scop alignment files (input) [./]: /test_data
**  Extension of alignment files [.salign]: 
**  Specify mode of signature generation
**           1 : Use positions specified in alignment file
**           2 : Use a scoring method
**           3 : Generate a randomised signature
**  Select number [1]: 2
**  % sparsity of signature [10]: 15
**  Window size [0]: 
**  Sequence variability scoring method
**           1 : Substitution matrix
**           2 : Residue class
**           3 : None
**  Select number [3]: 1
**  Substitution matrix to be used [EBLOSUM62]: 
**  Residue contacts scoring method
**           1 : Number
**           2 : Conservation
**           3 : Number and conservation
**           4 : None (structural data available)
**           5 : None (no structural data available)
**  Select number [5]: 5
**  Ignore alignment postitions with post_similar value of 0 [Y]: y
**  Location of signature files (output) [./]: /test_data
**  Extension of signature files [.sig]: 
**  Unix % 
**  
**  A sparse protein signature was generated for each scop alignment file with
**  the file extension .salign in the directory /test_data.  The signatures 
**  included high scoring positions from the alignments, scored on the basis 
**  of residue variability calculated by using the EBLOSUM62 residue 
**  substitution matrix (mode 2).  Signatures of 15% sparsity were generated, 
**  and the default window size (0) was used. 
**  Alignment postitions with a post_similar value of 0 were ignored, i.e. not
**  sampled in the signature.  No structural data were available for the 
**  domains in the alignments and this was specified as option 5 in the 
**  "Residue contacts scoring method".  Signature files with the file extenion
**  .sig were written to the directory /test_data.
**  
**  The following command line would achieve the same result.
**  
**  siggen /test_data .salign /test_data .sig 
**  -mode 2 -sparsity 15 -seqoption 1 -datafile EBLOSUM62 -conoption 5 
**  -filterpsim Y -wsiz 0
**
**
**  
**  Input file format
**  The format of the scop alignment file is described in scopalign.c
**  The format of the contact files is described in contacts.c
**  The format of the domain coordinate files is described in pdbparse.c
**  
**  
**  
**  Output file format
**  The output file (below) uses the following records.  The four SCOP 
**  classification records are taken from the alignment input file: 
**  (1)  CL - Domain class.  It is identical to the text given after 'Class' in 
**  the scop classification file (see documentation for the EMBOSS application 
**  scope). 
**  (2)  FO - Domain fold.  It is identical to the text given after 'Fold' in 
**  the scop classification file (see scope documentation). 
**  (3)  SF - Domain superfamily.  It is identical to the text given after 
**  'Superfamily' in the scop classification file (see scope documentation). 
**  (4)  FA - Domain family. It is identical to the text given after 'Family' 
**  in the scop classification file (see scope documentation). 
**  (5)  NP - Number of signature positions.
**  (6)  NN - Signature position number.  The number given in brackets after 
**  this record indicates the start of the data for the relevent signature 
**  position.
**  (7)  IN - Informative line about signature position. The number of different 
**  amino acid residues seen for this position is given after 'NRES', the number 
**  of different sizes of gap follows 'NGAP', and the window size after 'WSIZ'.
**  When a signature is aligned to a protein sequence, the permissible gaps 
**  between two signature positions is determined by the empirical gaps and the 
**  window size for the C-terminal position (see sigscan.c)
**  Two rows of data for the emprical residues and gaps are then given:
**  (8)  AA - The identifier of a residue seen in this position and the 
**  frequency of its occurence are delimited by ';'.
**  (9)  GA - The size of a gap seen in this position and the frequency 
**  of its occurence are delimited by ';'.
**  (10) // - used to delimit data for each signature. The last line of a file 
**  always  contains '//' only.
** 
**  Excerpt from a signature file
**
**  CL   All beta proteins
**  XX
**  FO   Lipocalins
**  XX
**  SF   Lipocalins
**  XX
**  FA   Fatty acid binding protein-like
**  XX
**  NP   2
**  XX
**  NN   [1] 
**  XX
**  IN   NRES 3 ; NGAP 2 ; WSIZ 2  
**  XX
**  AA   A ; 2
**  AA   V ; 1
**  AA   L ; 4
**  XX
**  GA   1 ; 5
**  GA   2 ; 2
**  XX
**  NN   [2] 
**  XX
**  IN   NRES 2 ; NGAP 2 ; WSIZ 5  
**  XX
**  AA   F ; 1
**  AA   Y ; 5
**  XX
**  GA   12 ; 3
**  GA   10 ; 2
**  XX
**  //
**  
**  
**  
**  Data files
**  siggen requires a residue substitution matrix.
**  
**  
**  
**  Diagnostic error messages
**  
**  
**  
**  Authors
**  Matt Blades (mblades@hgmp.mrc.ac.uk)
**  Jon Ison (jison@hgmp.mrc.ac.uk)
**
**
**  
**  References
**  Please cite the authors.
**
**  Other relevant references are given below.
**  A key residues approach to the definition of protein families and analysis
**  of sparse family signatures.  JC Ison, AJ Bleasby, MJ Blades, SC Daniel, 
**  JH Parish, JBC Findlay.  PROTEINS: Structure, Function & Genetics.  2000, 
**  40:330-341
**
**  Alignment of a sparse protein signature with protein sequences: application
**  to fold prediction for three small globulins.  SC Daniel, JH Parish, 
**  JC Ison, MJ Blades & JBC Findlay.  FEBS Letters.  1999, 459:349-352. 
**
**  
**  
******************************************************************************/






#include <math.h>

#include "emboss.h"

static AjBool  siggen_ScoreSeqMat(AjPScopalg alg, AjPScorealg *scores, AjPMatrixf mat, 
                        AjPInt2d seq_pos);
static AjBool  siggen_ScoreSeqVar(AjPScopalg alg, AjPScorealg *scores, AjPInt2d seq_pos);

static AjBool  siggen_ScoreNcon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps, 
                         AjPInt2d seq_pos, AjPInt *atom_idx, AjBool *noca);
static AjBool  siggen_ScoreCcon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps, 
                         AjPInt2d seq_pos, AjPInt *atom_idx, AjBool *noca);
static AjBool  siggen_ScoreNCCon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps,  
                          AjPInt2d seq_pos);
static AjBool  siggen_ScoreCombined(AjPScorealg *scores);
static AjPSignature  siggen_SigSelectSeq(AjPScopalg alg, AjPScorealg scores, 
					 AjPInt2d seq_pos, ajint sig_sparse,
					 float *spar_check, ajint wsiz);

static AjPSignature  siggen_SigSelect(AjPScopalg alg, AjPScorealg scores, 
                               AjPInt2d seq_pos, ajint sig_sparse, AjPCmap *cmaps,
                               AjPInt *atom_idx, float *spar_check, ajint wsiz);

static AjBool siggen_CalcSeqpos(AjPScopalg alg, AjPInt2d *seq_pos);
static AjBool siggen_ScoreAlignment(AjPScorealg *scores, AjPScopalg alg, AjPCmap *cmaps, 
                             AjPMatrixf  mat, AjBool *noca, AjPInt2d seq_pos, 
			     AjPInt *atom_idx);
static AjBool siggen_ScoreAlignmentSeq(AjPScorealg *scores, AjPScopalg alg, 
				       AjPMatrixf  mat, AjPInt2d seq_pos);

static AjPSignature siggen_SigSelectManual(AjPScopalg alg, AjPScorealg *scores, 
				     AjPInt2d seq_pos, float *spar_check,
					   ajint wsiz);




/*
static AjBool  siggen_ScoreNcon_Filter(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps, 
                         AjPInt2d seq_pos);                  
*/
static AjBool siggen_Con_Thresh(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps, 
			 ajint conthresh, AjBool *noca, AjPInt2d seq_pos, 
			 AjPInt *atom_idx);








/* @prog siggen *************************************************************
**
** Generates a sparse protein signature from an alignment and residue 
** contact data.
**
******************************************************************************/

int main(ajint argc, char **argv)
{
    /* Variables for stuff in acd */
    AjPStr      alg_path      =NULL;    /* Location of alignment files for input */
    AjPStr      alg_extn      =NULL;    /* Extn. of alignment files */
    AjPStr      alg_name      =NULL;    /* Name of alignment file */
    AjPStr      cpdb_path     =NULL;    /* Location of coordinate files for input */
    AjPStr      cpdb_extn     =NULL;    /* Extn. of coordinate files */
    AjPStr      cpdb_name     =NULL;    /* Name of coordinate file */
    AjPStr      con_path      =NULL;    /* Location of contact files for input */
    AjPStr      con_extn      =NULL;    /* Extn. of contact files */
    AjPStr      con_name      =NULL;    /* Name of contact file */
    AjPStr      sig_path      =NULL;    /* Location of signature files for input */
    AjPStr      sig_extn      =NULL;    /* Extn. of signature files */
    AjPStr      sig_name      =NULL;    /* Name of signature files */
    AjPStr      sig_name_sp   =NULL;    /* Sparsity extn for signature file */
    AjPStr      pair_mat      =NULL;    /* Residue pair substitution matrix */
    AjPStr      temp          =NULL;    /* Temp string */
    AjPStr      temp1         =NULL;    /* Temp string */
    AjPStr      temp2         =NULL;    /* Temp string */
    AjPStr      temp3         =NULL;
    

    AjPFile     fptr_alg      =NULL;    /* Pointer to alignment file */
    AjPFile     fptr_con      =NULL;    /* Pointer to current contact file */
    AjPFile     fptr_cpdb     =NULL;    /* Pointer to current coordinate file */
    AjPFile     sig_outf      =NULL;    /* File pointer for output file */

    AjPList     list          =NULL;    /* List of files in alignment directory */   
    AjPMatrixf  mat           =NULL;
    AjPInt2d    seq_pos       =NULL;    /* Numbering of sequence according to alignment */


    AjPSignature sig=NULL;              /* Signature */
    AjPScopalg  alg           =NULL;    /* Pointer to Scopalg structure */
    AjPScorealg scores        =NULL;    /* Pointer to Scorealg structure */
    AjPCmap    *cmaps         =NULL;    /* Array of pointers to Cmap structures */

    AjBool      score_seq_mat =ajFalse;  /* Score on basis of residue conservation  (Y/N) */ 
    AjBool      score_seq_var =ajFalse; /* Score on basis of variability function  (Y/N) */ 
/*    AjBool      score_ncon_filter =ajFalse; */   /* Score using variability after ncon filtering  (Y/N) */    
    AjBool      score_ncon    =ajFalse; /* Score on basis of number of contacts  (Y/N) */ 
    AjBool      score_ccon    =ajFalse; /* Score on basis of conservation of contacts  (Y/N) */

    AjBool      score_both    =ajFalse; /* Score on combined measure of number and 
					   conservation (Y/N) ( not implemented at moment) */ 
    AjBool      filterpsim    =ajFalse; /* Filter on basis of post_similar data line (Y/N) */ 
    AjBool      filtercon     =ajFalse; /* Filter on basis of number of contacts (Y/N) */ 
    ajint       conthresh     =0;       /* Threshold number of contacts for filtercon */
    AjPStr      *mode         =NULL;    /* Holds mode options from acd*/
    AjPStr      *seqoption    =NULL;    /* Holds sequence scoring options from acd*/
    AjPStr      *conoption    =NULL;    /* Holds contact scoring options from acd*/

    char        id            ='.';     /* Chain identifier for a scop domain*/
    ajint       idn           =0;       /* Chain identifier as a number */
    ajint       x             =0;       /* Loop counter */

    ajint       sig_sparse    =0;       /* Sparsity of signature */
    ajint       wsiz          =0;       /* Window size */
    AjBool      idok          =ajFalse; /* Whether chain identifier could be determined ok */
    AjPPdb      pdb           =NULL;    /* Pdb object pointer*/

    AjBool      *noca          =NULL;    /* Array whose elements are True if the relevant sequence in 
                                           the alignment contained an NOCA grouyp in the original pdb
                                           file */
    AjPInt     *atom_idx=NULL;          /* Array of AjPInt's which hold the indeces into the full 
                                           length sequences for sequences in the alignment (alignment
                                           sequences are for structured residues (residues with electron
                                           density) only) */
    AjPStr      tempres       =NULL;


    float       spar_check    =0.0;
    
/*JISON*/    ajint       nres =0;  /* number of structured residues for current sequence in alignment */
             
    

    

    /* Allocate strings etc */
    sig_path      = ajStrNew();
    sig_extn      = ajStrNew();
    sig_name      = ajStrNew();
    sig_name_sp   = ajStrNew();
    alg_path      = ajStrNew();
    alg_extn      = ajStrNew();
    alg_name      = ajStrNew();
    con_path      = ajStrNew();
    con_extn      = ajStrNew();
    con_name      = ajStrNew();
    cpdb_path     = ajStrNew();
    cpdb_extn     = ajStrNew();
    cpdb_name     = ajStrNew();
    pair_mat      = ajStrNew();
    temp          = ajStrNew();
    temp1         = ajStrNew();
    temp2         = ajStrNew();
    temp3         = ajStrNew();
    tempres       = ajStrNew();



    /* Read data from acd */
    ajNamInit("emboss");
    ajAcdInitP("siggen",argc,argv,"DOMAINATRIX"); 
    sig_path      = ajAcdGetString("sigpath");
    sig_extn      = ajAcdGetString("sigextn");    
    alg_path      = ajAcdGetString("algpath");
    alg_extn      = ajAcdGetString("algextn");    
    sig_sparse    = ajAcdGetInt("sparsity");
    wsiz          = ajAcdGetInt("wsiz");
    mode          = ajAcdGetList("mode");
    seqoption     = ajAcdGetList("seqoption");
    mat           = ajAcdGetMatrixf("datafile");
    conoption     = ajAcdGetList("conoption");
    filtercon     = ajAcdGetBool("filtercon");
    conthresh     = ajAcdGetInt("conthresh");
    con_path      = ajAcdGetString("conpath");    
    con_extn      = ajAcdGetString("conextn");    
    cpdb_path     = ajAcdGetString("cpdbpath");    
    cpdb_extn     = ajAcdGetString("cpdbextn");    
    filterpsim    = ajAcdGetBool("filterpsim");
    



    /* If random is chosen then just use one scoring     */
    /* method to go through the process, but sig will be */
    /* random!!                                          */
    if((ajStrChar(*mode, 0) == '3'))
	score_seq_var = ajTrue;
    



    
    /* Check directories*/
    if(!ajFileDir(&sig_path))
        ajFatal("Could not open signatures directory");
    if(!ajFileDir(&alg_path))
        ajFatal("Could not open alignments directory");

    /* LATEST MOD */
    /*  if((ajStrChar(*conoption, 0)) != '4' || filtercon) */
    if(((ajStrChar(*conoption, 0) != '4') && (ajStrChar(*conoption, 0) != '5')) || filtercon)
    {
        if(!ajFileDir(&con_path))
            ajFatal("Could not open contacts directory");
        if(!ajFileDir(&cpdb_path))
            ajFatal("Could not open coordinate file directory");
    }	
    
    
    /* Assign ajtrue to score_seq_var if seqoption  from acd is == 1 */
    if(ajStrChar(*seqoption, 0) == '1')
        score_seq_mat = ajTrue;
    /* Assign ajtrue to score_seq_var if seqoption  from acd is == 2 */
    else if(ajStrChar(*seqoption, 0) == '2')
        score_seq_var = ajTrue;
    /* Both methods are left as ajFalse if user selects option 3, 
       i.e. no sequence scoring */


    if(ajStrChar(*conoption, 0) == '1')
        score_ncon=ajTrue;
    else if(ajStrChar(*conoption, 0) == '2')
        score_ccon=ajTrue;
    else if(ajStrChar(*conoption, 0) == '3')
    {
        score_ccon=ajTrue;
        score_ncon=ajTrue;
    }
    



    /*DIAGNOSTICS - to remove*/
    /*    if(score_seq_mat == ajFalse)
       printf("seq_mat not selected\n");

    if(score_seq_var == ajFalse)
       printf("seq_var not selected\n");

    if(score_ncon == ajFalse)
       printf("ncon not selected\n");

    if(score_ncon == ajTrue)
       printf("ncon selected\n");

    if(score_ccon == ajFalse)
       printf("ccon not selected\n");

    if(score_ccon == ajTrue)
       printf("ccon selected\n");
    

    ajFmtPrint("seqoption = %S\n", *seqoption);

    printf("sparsity = %d\n", sig_sparse);
    */


    /* Check if a scoring method has been selected */
    if((score_seq_mat == ajFalse) && (score_seq_var == ajFalse) && 
       (score_ncon == ajFalse) && (score_ccon == ajFalse))
    {
        ajFmtPrint("No scoring methods were selected from acd. Exiting\n");

        ajExit();

        return(0);
    }   

    /* Create list of files in alignments directory */
    list = ajListNew();
    ajStrAssC(&temp, "*");      
    if((ajStrChar(alg_extn, 0)=='.'))
        ajStrApp(&temp, alg_extn);    
    else
    {
        ajStrAppC(&temp, ".");    
        ajStrApp(&temp, alg_extn);    
    }
    ajFileScan(alg_path, temp, &list, ajFalse, ajFalse, 
               NULL, NULL, ajFalse, NULL); 
    ajStrDel(&temp);



    /*Start of main application loop*/
    while(ajListPop(list,(void **)&temp))
    {
        /* Open alignment file */
        if((fptr_alg=ajFileNewIn(temp))==NULL)
        {
            ajFileClose(&fptr_alg);
            ajWarn("Could not open alignment file");
            ajStrDel(&temp);
            continue;       
        }


        /* Read alignment file, write Scopalg structure, 
           close alignment file */
        ajXyzScopalgRead(fptr_alg, &alg);


	if(alg->N==0)
	{
            ajFileClose(&fptr_alg);
            ajWarn("Alignment file does not contain sequences");
            ajStrDel(&temp);
	    ajXyzScopalgDel(&alg);
	    continue;       
	}
	

        ajFileClose(&fptr_alg);
        

        /* Allocate array of pointers to Cmap structures for contact maps */
	/* LATEST MOD */
	if(ajStrChar(*conoption, 0) != '5')
	    AJCNEW0(cmaps, alg->N);
        

        /* Allocate array of bool's for noca array */
	/* LATEST MOD */
	if(ajStrChar(*conoption, 0) != '5')
	    AJCNEW0(noca, alg->N);
        
        /* Allocate array of AjPInt for indeces into sequences */
	/* LATEST MOD */
	if(ajStrChar(*conoption, 0) != '5')
	{
	    AJCNEW0(atom_idx, alg->N);
	    
	    for(x=0; x<alg->N; ++x)
		atom_idx[x] = ajIntNew();
        }
	

        /* Start of loop for reading contact data and coordinate files. 
           Only entered if contact data is to be used.*/
       /* if((ajStrChar(*conoption, 0)) != '4' || filtercon)

        {*/
	/* LATEST MOD */
	if(ajStrChar(*conoption, 0) != '5')
	{
            for(x=0; x<alg->N; ++x)

            {
                idok=ajFalse;
                
                /* Get name of contact data file */
                ajStrAss(&temp1, con_path);
                ajStrApp(&temp1, alg->Codes[x]);
                
                if((ajStrChar(con_extn, 0)=='.'))
                    ajStrApp(&temp1, con_extn);    
                else
                {
                    ajStrAppC(&temp1, ".");    
                    ajStrApp(&temp1, con_extn);    
                }       
                
                
                /* Open contact data file */
                if((fptr_con=ajFileNewIn(temp1))==NULL)
                {
                    ajWarn("Could not open contact file!!");
                    continue;           
                }   
                
                
                /* Read contact data file; hard-coded to read model 1 
                   from file */
                /* A scop identifier is presumed if the id is 7 characters 
                   long and the first character is a 'd' or 'D' */
                if((ajStrLen(alg->Codes[x])==7)
                   &&(toupper(ajStrChar(alg->Codes[x], 0)) == 'D'))

                { 
                    /*Read the chain id from the SCOP domain code and convert 
                      cases of '_' identifiers to '.' */
                    id=ajStrChar(alg->Codes[x], 5);
                    if(id=='_') id='.';
                    
                    ajXyzCmapReadC(fptr_con, id, 1, &cmaps[x]);

		    /*DIAGNOSTICS
		      ajFmtPrint("Cmap->Ncon = %d\n", cmaps[x]->Ncon); */
                    
                    idok=ajTrue;
                }
                else  
                {
                    /*Not sure of a chain identifier so read the first chain*/
                    ajWarn("Uncertain of chain identifier so reading first chain");
                    ajXyzCmapReadI(fptr_con, 1,1, &cmaps[x]);
                }
                
                
                /* Close contact data file */
                ajFileClose(&fptr_con);



                /* Get name of coordinate data file */
                ajStrAss(&temp1, cpdb_path);
                ajStrApp(&temp1, alg->Codes[x]);
                if((ajStrChar(cpdb_extn, 0)=='.'))
                    ajStrApp(&temp1, cpdb_extn);    
                else
                {
                    ajStrAppC(&temp1, ".");    
                    ajStrApp(&temp1, cpdb_extn);    
                }
                
                /* Open coordinate file */
                if((fptr_cpdb=ajFileNewIn(temp1))==NULL)
                {
                    ajWarn("Could not open coordinate file");
                    continue;           
                }   

                /* Read coordinate data file */ 
                ajXyzCpdbRead(fptr_cpdb, &pdb);
                
                /* Determine the chain number */
                if(idok)
                {
                    if(!ajXyzPdbChain(id, pdb, &idn))
                    {
                        idn=1;
                        ajWarn("Could not find chain in siggen x = %d. Assuming chain 1\n", x);
                        /*ajXyzPdbDel(&pdb);
			  ajFileClose(&fptr_cpdb);
			  continue;*/
                    }
                }
                else  
                {
                    /*Not sure of a chain identifier so read the first chain*/
                    idn=1;
                }


                /* Check for CA atom in N terminal residue  */
                /* hard-coded to read data for model 1      */
                
                /* Segment now redundant as ajXyzPdbAtomIndexICA      */

                /* Now checks entire sequence for residues lacking CA */
                /* and corrects atom_idex aray accordingly            */
		/*      iter = ajListIter(pdb->Chains[idn-1]->Atoms);           
			atom = (AjPAtom)ajListIterNext(iter);
			ajStrAss(&tempres, atom->Id3);
			if(ajStrMatchC(atom->Atm, "CA"))
			{
			foundCA = ajTrue;
			}
			else
			{    
			while((atom = (AjPAtom)ajListIterNext(iter)))
			{
                        if(!ajStrMatch(tempres, atom->Id3))
			break;
                        if(ajStrMatchC(atom->Atm, "CA"))
                        {
			foundCA = ajTrue;
			break;
                        }
			}
			}
			
			if(!foundCA)
			{
			noca[x]=ajTrue;
			}               
			
			ajListIterFree(iter);
			*/

                /* Make noca ajFalse to keep following */
                /* condition tests happy               */
                noca[x]=ajFalse;


		/*              ajListPop(pdb->Chains[idn-1]->Atoms, (void **)&atom);
				if((ajStrMatchC(atom->Id3, "ACE")))
				noca[x]=ajTrue;*/
                
                if(!ajXyzPdbAtomIndexICA(pdb, idn, &atom_idx[x], &nres))
                {
                    ajWarn("Could not find chain in siggen ajXyzPdbAtomIndexICA\n");
                    ajXyzPdbDel(&pdb);
                    ajFileClose(&fptr_cpdb);
                    continue;
                }
                
		/*JISON*/		ajIntPut(&atom_idx[x], nres, -1);
		
    

                
                /* Close coordinate file and free Pdb object*/
                ajXyzPdbDel(&pdb);
                ajFileClose(&fptr_cpdb);
            }
	}
	


	/* DIAGNOSTICS
	   for(x=0;x<alg->N;x++)
        {       
            printf("\natom_idx\n");
            for(y=0; y<125; y++)
            {
                ajFmtPrint("%4d", ajIntGet(atom_idx[x], y));    
            }
        }*/
                
        

        /* Allocate Scorealg structure and write values from acd */
        scores = ajXyzScorealgNew((ajint)alg->width);
        scores->seqmat_do    = score_seq_mat;
        scores->seqvar_do    = score_seq_var;
        scores->filtercon    = filtercon;
        scores->filterpsim   = filterpsim;
        scores->ncon_do      = score_ncon;
        scores->ccon_do      = score_ccon;
        scores->nccon_do     = score_both;
	if((ajStrChar(*mode, 0) == '3'))
	    scores->random   = ajTrue;
	if((ajStrChar(*mode, 0) == '1'))
	    scores->manual   = ajTrue;



        /* Calculate index for use by scoring functions */
        siggen_CalcSeqpos(alg, &seq_pos);


        /* Determine positions with > conthresh no. of contacts*/
	if(filtercon == ajTrue)
	    siggen_Con_Thresh(alg, &scores, cmaps, conthresh, noca, seq_pos, atom_idx);        


        /* Score alignement - write Scorealg structure and generate signature */
	if(ajStrChar(*mode, 0) == '1')
	{
	    sig = siggen_SigSelectManual(alg, &scores, seq_pos, &spar_check, wsiz);
	}
	else
	{
	    if(ajStrChar(*conoption, 0) == '5')
		siggen_ScoreAlignmentSeq(&scores, alg, mat, seq_pos);
	    else
		siggen_ScoreAlignment(&scores, alg, cmaps, mat, noca, seq_pos, atom_idx);

	    spar_check = 0.0;

	    if(ajStrChar(*conoption, 0) == '5')
	    {
		if( (sig = siggen_SigSelectSeq(alg, scores, seq_pos, sig_sparse, 
					       &spar_check, wsiz))==NULL)
		{
		    if(ajStrChar(*conoption, 0) != '5')
			for(x=0; x<alg->N; ++x)
			    ajXyzCmapDel(&cmaps[x]);
		    
		    if(ajStrChar(*conoption, 0) != '5')
		    {
			for(x=0; x<alg->N; ++x)
			    ajIntDel(&atom_idx[x]);
			AJFREE(atom_idx);
			AJFREE(noca);
			AJFREE(cmaps);
		    }
		    
		    ajXyzScorealgDel(&scores); 
		    ajXyzScopalgDel(&alg);
		    ajStrDel(&temp);
		    continue;
		}
	    }
	    
	    else 
	    {
		if( (sig = siggen_SigSelect(alg, scores, seq_pos, sig_sparse, cmaps, 
					    atom_idx, &spar_check, wsiz))==NULL)
		{
		    if(ajStrChar(*conoption, 0) != '5')
			for(x=0; x<alg->N; ++x)
			    ajXyzCmapDel(&cmaps[x]);
		    
		    if(ajStrChar(*conoption, 0) != '5')
		    {
			for(x=0; x<alg->N; ++x)
			    ajIntDel(&atom_idx[x]);
			AJFREE(atom_idx);
			AJFREE(noca);
			AJFREE(cmaps);
		    }
		    
		    ajXyzScorealgDel(&scores); 
		    ajXyzScopalgDel(&alg);
		    ajStrDel(&temp);
		    continue;
		}
	    }
	}
	

	/*JISON*/    ajInt2dDel(&seq_pos);    


        

        /* This code block can be used to produce file names 
	   which uses the Sunid only */
	ajStrFromInt(&temp3, alg->Sunid_Family);
	ajStrAssS(&sig_name, temp3);	
	ajStrInsert(&sig_name, 0, sig_path);	
	ajStrApp(&sig_name, sig_extn);


        /* This code block can be used to produce file names which
	   are the same as the SCOP family but with instances of ' ' 
           and '&' replnocad by '_'*/
	/*        
	   ajStrAss(&sig_name, alg->Family);       
	   ajStrSubstituteCC(&sig_name, " ", "_");
	   ajStrSubstituteCC(&sig_name, "&", "_");
	   ajStrInsert(&sig_name, 0, sig_path);            
	   ajStrApp(&sig_name, sig_extn);
	   */


        /* This code block can be used to produce file names in 
	   which sparsity and method of generation are indicated. */
	/*
        if(spar_check == 0.0)
            ajStrFromInt(&sig_name_sp, (int)sig_sparse);  
        else
        {
            ajStrFromInt(&sig_name_sp, (int)sig_sparse);            
            ajStrAppC(&sig_name_sp, "_");
            ajStrFromInt(&temp3, (int)spar_check);          
            ajStrApp(&sig_name_sp, temp3);
        }
        
        
	ajStrFromInt(&sig_name, (int)alg->Sunid_Family);            
	ajStrSubstituteCC(&sig_name, " ", "_");
        ajStrSubstituteCC(&sig_name, "&", "+");
        ajStrInsert(&sig_name, 0, sig_path);    
        ajStrAppC(&sig_name, "_");                   

        if(filtercon == ajTrue)
        {
            ajStrAppC(&sig_name, "F");             
            ajStrAppC(&sig_name, "_");             
        }

        if(filterpsim == ajTrue)
        {
            ajStrAppC(&sig_name, "P");             
            ajStrAppC(&sig_name, "_");             
        }


        if((score_seq_mat == ajTrue) && (ajStrMatchC(ajMatrixfName(mat), "./EBLOSUM62")))
        {
            ajStrAppC(&sig_name, "sb");             
            ajStrAppC(&sig_name, "_");             
        }

        if((score_seq_mat == ajTrue) && (ajStrMatchC(ajMatrixfName(mat), "./EBC0030")))
        {
            ajStrAppC(&sig_name, "ss");             
            ajStrAppC(&sig_name, "_");             
        }

        if(score_seq_var == ajTrue)
        {
            if(scores->random != ajTrue)
            {
                ajStrAppC(&sig_name, "v");             
                ajStrAppC(&sig_name, "_");             
            }

            else if(scores->random == ajTrue)
                ajStrAppC(&sig_name, "rand_");
        }


        if(score_ncon == ajTrue)
        {
            ajStrAppC(&sig_name, "n");             
            ajStrAppC(&sig_name, "_");             
        }

        if(score_ccon == ajTrue)

        {
            ajStrAppC(&sig_name, "c");             
            ajStrAppC(&sig_name, "_");             
        }
        ajStrApp(&sig_name, sig_name_sp);             
        ajStrApp(&sig_name, sig_extn);
	*/



        /* If a file of that name exists, then append _1 or _2 etc 
           as necessary until a unique name is found */
	/*
        ajStrAss(&temp1, sig_name);     
        for(x=1;
            (ajFileStat(&temp1, AJ_FILE_R ) ||
             ajFileStat(&temp1, AJ_FILE_W ) ||
             ajFileStat(&temp1, AJ_FILE_X ));
            x++)
        {
            ajStrAss(&temp1, sig_name); 
            ajStrAppC(&temp1, "_");
            ajFmtPrintS(&temp2, "%d", x);
            ajStrApp(&temp1, temp2);
        }
        ajStrAss(&sig_name, temp1);     
	*/
        if((sig_outf=ajFileNewOut(sig_name))==NULL)
        {
            ajWarn("Could not open signature file for output");
            ajStrDel(&temp);

            continue;       
        }

        /* Write and close signature file*/
        if(!ajXyzSignatureWrite(sig_outf, sig))
            ajFatal("Error writing signature file");
        ajFileClose(&sig_outf);

        /* Free memory */
        ajXyzSignatureDel(&sig);

	/* LATEST MOD */
/*        if((ajStrChar(*conoption, 0)) != '4' || filtercon)*/
	if(ajStrChar(*conoption, 0) != '5')
            for(x=0; x<alg->N; ++x)
                ajXyzCmapDel(&cmaps[x]);

	/* LATEST MOD */
	if(ajStrChar(*conoption, 0) != '5')
	{
	    for(x=0; x<alg->N; ++x)
		ajIntDel(&atom_idx[x]);
	    AJFREE(atom_idx);
	    AJFREE(noca);
	    AJFREE(cmaps);
	}
	
        ajXyzScorealgDel(&scores); 
        ajXyzScopalgDel(&alg);
        ajStrDel(&temp);
    }
    
    
    

    /*Tidy up */
    ajStrDel(&conoption[0]);
    AJFREE(conoption);
    ajStrDel(&seqoption[0]);
    AJFREE(seqoption);
    ajStrDel(&mode[0]);
    AJFREE(mode);
    ajStrDel(&temp1);
    ajStrDel(&temp2);
    ajStrDel(&temp3);
    ajStrDel(&sig_path);

    ajStrDel(&sig_extn);
    ajStrDel(&sig_name);
    ajStrDel(&sig_name_sp);
    ajStrDel(&alg_path);
    ajStrDel(&alg_extn);
    ajStrDel(&alg_name);
    ajStrDel(&con_path);
    ajStrDel(&con_extn);
    ajStrDel(&con_name);
    ajStrDel(&cpdb_path);
    ajStrDel(&cpdb_extn);
    ajStrDel(&cpdb_name);
    ajStrDel(&pair_mat);
    ajStrDel(&tempres);

    ajListDel(&list);
    ajMatrixfDel(&mat);
/*JISON    ajInt2dDel(&seq_pos);     */



    /* Return */
    ajExit();
    return 0;
}





/* @funcstatic  siggen_ScoreSeqMat ****************************************************
 **

 ** Reada a Scopalg object and writes a Scorealg object. Each residue in 
 ** the alignment is scored on the basis of conservation of residue type.
 **
 **
 ** @param [r] alg     [AjPScopalg]   Alignment
 ** @param [w] scores  [AjPScorealg*] Scores for alignment
 ** @param [r] mat     [AjPMatrixf]   Subsitution matrix
 ** @param [r] seq_pos [AjPInt2d]     Index for alignment

 **
 ** @return [AjBool] True on succcess
 ** @@
 ****************************************************************************/

static AjBool  siggen_ScoreSeqMat(AjPScopalg alg, AjPScorealg *scores, AjPMatrixf mat, 
                 AjPInt2d seq_pos)
{
    ajint       memb_cnt     =0;    /* Counter for members of the family (alignment) */
    ajint       res_cnt      =0;    /* Counter for residue in the alignment */
    ajint       post_cnt     =0;    /* Counter for post_similar line */
    float       **sub        =0;    /* Array of floats for sub matrix */
    float       val          =0;    /* Current value for res sub score */        
    float       pos_score    =0;    /* Total sub score for all res at position */
    float       temp         =0;    /* Temp variable for score */
    AjPSeqCvt   cvt          =0;    /* variable for sequence character conversion table */






    cvt = ajMatrixfCvt(mat);        /* Create sequence character conversion table */
    sub = ajMatrixfArray(mat);      /* Create matrix as array of floats           */
    

    /* Counter for positions in alignment */
    for(post_cnt = 0; post_cnt < alg->width; post_cnt++)
    {
        /* Filter on basis of post_similar line */
        if(((ajStrChar(alg->Post_similar, post_cnt) == '1') && 
	    ((*scores)->filterpsim == ajTrue) &&
	    ((*scores)->filtercon == ajTrue)  && 
	    (ajIntGet((*scores)->ncon_thresh, post_cnt) == 1))
	   ||
           (((*scores)->filterpsim == ajTrue) && 
	    (ajStrChar(alg->Post_similar, post_cnt) == '1') &&
	    ((*scores)->filtercon == ajFalse))
           ||
           (((*scores)->filterpsim == ajFalse) && 
	    (ajStrChar(alg->Post_similar, post_cnt) != '-') && 
	    ((*scores)->filtercon == ajTrue) && 
	    (ajIntGet((*scores)->ncon_thresh, post_cnt) == 1))
           ||
           (((*scores)->filterpsim == ajFalse) && 
	    (ajStrChar(alg->Post_similar, post_cnt) != '-') && 
	    ((*scores)->filtercon == ajFalse)))
        {
            /* Initialise variable to zero */
            val = 0;
            pos_score = 0;
            temp = 0;

            /* Iterate through member of family */
            for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
            {   
                if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='-')
                    continue;


                
                /* Iterate throught every combination of residues */
                /* at the current position */
                for(res_cnt = (memb_cnt+1); res_cnt < alg->N; res_cnt++)
                    {
                        if(ajStrChar(alg->Seqs[res_cnt], post_cnt)=='-')
                            continue;


                        /* Assign score form matrix to variable val */
                        val = (sub[ajSeqCvtK(cvt, (ajStrChar(alg->Seqs[memb_cnt], 
                            post_cnt)))][ajSeqCvtK(cvt, 
                            (ajStrChar(alg->Seqs[res_cnt], post_cnt)))]);



                        /* Add score form matrix to temp */
                        temp += val;

                    }
            }
            /* Perform last part of calculation */
            /* Divide total score by members in family */
            pos_score = (temp/alg->N);


            /* Assign total score for substitution of all the residues */
            /* at a position into scoring array                         */
            ajFloatPut(&(*scores)->seqmat_score, post_cnt, pos_score);
        }
    }

 
    /* Return */
    return ajTrue;
}





/* @funcstatic  siggen_ScoreSeqVar**************************************************
 **
 ** Reada a Scopalg object and writes a Scorealg object. Each residue in 
 ** the alignment is scored on the basis of a variability function.
 **
 **
 ** @param [r] alg     [AjPScopalg]   Alignment

 ** @param [w] scores  [AjPScorealg*] Scores for alignment
 ** @param [r] seq_pos [AjPInt2d]     Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ****************************************************************************/
static AjBool  siggen_ScoreSeqVar(AjPScopalg alg, AjPScorealg *scores, AjPInt2d seq_pos)
{
    ajint       memb_cnt     =0;    /* Counter for members of the family (alignment) */

    ajint       post_cnt     =0;    /* Counter for post_similar line */
    ajint       aliphatic    =0;    /* Counter for aliphatic residue group */    
    ajint       aromatic     =0;    /* Counter for aromatic residue group */
    ajint       polar        =0;    /* Counter for polar residue group */  
    ajint       basic        =0;    /* Counter for basic residue group */  
    ajint       acidic       =0;    /* Counter for acidic residue group */
    ajint       special      =0;    /* Counter for special residue group */
    ajint       x            =0;    /* Loop counter */
    ajint       total        =0;    /* Total */
    float       val          =0;    /* Current value for res sub score */        
    float       temp         =0;    /* Temp value for res sub score */        
    float       temp2        =0;    /* Temp value for res sub score */        
    float       pos_score    =0;    /* Total sub score for all res at position */
    AjPFloat    class_freq   =NULL; /* Array for frequencies for each residue group */




    /* Create the class frequencey array */
    class_freq = ajFloatNewL((float)6);
    


    /* Counter for positions in alignment */
    for(post_cnt = 0; post_cnt < alg->width; post_cnt++)
    {
        /* Filter on basis of post_similar line*/
	/*if(((ajStrChar(alg->Post_similar, post_cnt) == '1') && 
	  ((*scores)->filterpsim == ajTrue)) || 
	  (((*scores)->filterpsim == ajFalse) && 
	  ((ajStrChar(alg->Post_similar, post_cnt) == '1')
	  ||  (ajStrChar(alg->Post_similar, post_cnt) == '0'))))*/

        if(((ajStrChar(alg->Post_similar, post_cnt) == '1') && 
	    ((*scores)->filterpsim == ajTrue) &&
           ((*scores)->filtercon == ajTrue) && 
	    (ajIntGet((*scores)->ncon_thresh, post_cnt) == 1))
	   ||
           (((*scores)->filterpsim == ajTrue) && 
	    (ajStrChar(alg->Post_similar, post_cnt) == '1') &&
	    ((*scores)->filtercon == ajFalse))
           ||
           (((*scores)->filterpsim == ajFalse) && 
	    (ajStrChar(alg->Post_similar, post_cnt) != '-') && 
           ((*scores)->filtercon == ajTrue) && 
	    (ajIntGet((*scores)->ncon_thresh, post_cnt) == 1))
           ||
           (((*scores)->filterpsim == ajFalse) && 
	    (ajStrChar(alg->Post_similar, post_cnt) != '-') && 
	    ((*scores)->filtercon == ajFalse)))

        {

            /* Initialise variable to zero */
            aliphatic    =0;

            aromatic     =0;
            polar        =0;    
            basic        =0;   
            acidic       =0;
            special      =0;
            val          =0;
            pos_score    =0;

            total        =0;
            ajFloatPut(&class_freq, 0, (float) 0.0);
            ajFloatPut(&class_freq, 1, (float) 0.0);
            ajFloatPut(&class_freq, 2, (float) 0.0);
            ajFloatPut(&class_freq, 3, (float) 0.0);
            ajFloatPut(&class_freq, 4, (float) 0.0);
            ajFloatPut(&class_freq, 5, (float) 0.0);

            /* Iterate through member of family */
            /* Calculate frequency of each residue group */

            for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
            {   
                if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='-')
                    continue;
                    
                /* Check if residues are in group 1  */
                /* Then increment aliphatic counter  */
                if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='A')
                    aliphatic++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='V')
                    aliphatic++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='I')
                    aliphatic++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='L')
                    aliphatic++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='M')
                    aliphatic++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='C')
                    aliphatic++;
                                    
                /* Check if residues are in group 2  */
                /* Then increment aromatic counter   */
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='F')
                    aromatic++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='W')
                    aromatic++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='Y')
                    aromatic++;
                


                /* Check if residues are in group 3  */
                /* Then increment polar counter      */
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='S')
                    polar++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='T')
                    polar++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='N')
                    polar++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='Q')
                    polar++;
                
                /* Check if residues are in group 4  */
                /* Then increment basic counter      */
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='K')
                    basic++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='R')
                    basic++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='H')
                    basic++;

                /* Check if residues are in group 5  */
                /* Then increment acidic counter     */
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='D')
                    acidic++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='E')
                    acidic++;

                /* Check if residues are in group 6  */
                /* Then increment special counter     */
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='G')
                    special++;
                else if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='P')
                    special++;
            }

            /* Sum all counts of each residue class */
            total =  (aliphatic + aromatic + polar + basic + acidic + special); 

            /* Check to ensure total residues counted at          */
            /* position is not greater than number of seqs in set */
            if(total != alg->N)
            {
                if(total > alg->N)
                {
                    printf("Error in Siggen_ScoreSeqVar.... total"
			   " = greater than number of sequences\n");
                    printf("Exiting....   email jison@hgmp.mrc.ac.uk\n");
                    ajExit();

                    return 0;
                }

                else
                {
                    /* print warning */
                    printf("Unknown residue type found in siggen_ScoreSeqVar.... "
			   "total residues counted does not = number of sequences\n");
                    /* perform frequency calculation */
                    /* divide by total, NOT alg->N  */
                    ajFloatPut(&class_freq, 0, ((float)aliphatic/(float)total));
                    ajFloatPut(&class_freq, 1, ((float)aromatic/(float)total));
                    ajFloatPut(&class_freq, 2, ((float)polar/(float)total));
                    ajFloatPut(&class_freq, 3, ((float)basic/(float)total));
                    ajFloatPut(&class_freq, 4, ((float)acidic/(float)total));
                    ajFloatPut(&class_freq, 5, ((float)special/(float)total));
                }

            }

            else
            {
                /* perform frequency calculation */
                ajFloatPut(&class_freq, 0, ((float)aliphatic/(float)alg->N));
                ajFloatPut(&class_freq, 1, ((float)aromatic/(float)alg->N));
                ajFloatPut(&class_freq, 2, ((float)polar/(float)alg->N));
                ajFloatPut(&class_freq, 3, ((float)basic/(float)alg->N));
                ajFloatPut(&class_freq, 4, ((float)acidic/(float)alg->N));
                ajFloatPut(&class_freq, 5, ((float)special/(float)alg->N));
            }
            
            

            /* Perform calculation of residue variability*/
            for(x=0; x<6; x++)
            {   
                /* Check if frequency = 0, i.e. no residues of */
                /* that class in the position                  */
                if(ajFloatGet(class_freq, x) == 0 )
                    continue;

                
                /* Else Perform calculation */
                else
                {                   
                    val = 0;
                    /* Assign value of (freq * (ln(freq)) to val */
                    val = ((ajFloatGet(class_freq, x)) * ((log(ajFloatGet(class_freq, x)))));


                    /* assign value of val to pos_score, which holds */
                    /* total score for all residues at the position  */
                    pos_score += val;
                }
                
            }
            /* Determine absolute value of pos_score */
            temp = (fabs(pos_score));


            /* Invert the score, by taking away from 1 */
            temp2 = (1 - temp);


            /* Assign total score for substitution of all the residues */
            /* at a position into scoring array                         */      
            ajFloatPut(&(*scores)->seqvar_score, post_cnt, temp2);
        }
        
        else
            continue;
    }
    
           


    /* Return */
    return ajTrue;

}









/* @funcstatic  siggen_ScoreNcon *****************************************************
 **
 ** Reads a Scopalg object and writes a Scorealg object. Each residue in 

 ** the alignment is scored on the basis of the number of phsyical contacts
 ** (residue-residue) it makes in the structure. Contacts are read from a
 ** Cmaps object.
 **
 ** @param [r] alg     [AjPScopalg ]    Alignment
 ** @param [w] scores  [AjPScorealg*]   Scores for alignment
 ** @param [r] cmaps   [AjPCmap*]       Residue contacts
 ** @param [r] seq_pos [AjPInt2d]       Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
static AjBool  siggen_ScoreNcon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps, 
                         AjPInt2d seq_pos, AjPInt *atom_idx, AjBool *noca)
{

    ajint       memb_cnt     =0;    /* Counter for members of the family (alignment) */
    ajint       xmat_cnt     =0;    /* Counter for x axis of contact matrix */
    ajint       ymat_cnt     =0;    /* Counter for y axis of contact matrix */
    ajint       nconcount    =0;    /* Counter for number of contacts at position*/
    ajint       x            =0;    /* Counter for initializing arrays to zero */
    ajint       post_cnt     =0;    /* Counter for post_similar line */
    ajint       nconpos_cnt  =0;    /* Counter to hold ncon */
    ajint       idx_seqpos   =0;    /* Index into seq_pos array */
    ajint       idx_atomidx  =0;    /* Index into atom_idx array */
    float       av_ncon      =0;    /* Counter to hold average no. of contacts */
    AjIStr      iter         =NULL; /* Iterator for post_similar string */
    AjPInt2d    align_ncon   =NULL; /* Matrix of number of contacts for every residue */

    
    

    /* Allocate memory for the align_ncon array  */
    align_ncon = ajInt2dNewL((ajint)alg->width);        


    /* Assign iterator for post_similar line */
    iter = ajStrIter(alg->Post_similar);


    /* Create arrays of size width */
    for(x = 0; x < alg->N; x++)
        ajInt2dPut(&align_ncon, x, alg->width-1, (ajint) 0);


    /* Diagnostics to print out contact maps */
/* DIAGNOSTICS
    for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
    {
        printf("\n");
        printf("%d\n", memb_cnt);

        for(xmat_cnt = 0; xmat_cnt < cmaps[memb_cnt]->Dim; xmat_cnt++)

        {
            printf("\n");
            for(ymat_cnt = 0; ymat_cnt < cmaps[memb_cnt]->Dim; ymat_cnt++)
                ajFmtPrint("%2d", ajInt2dGet(cmaps[memb_cnt]->Mat, xmat_cnt, ymat_cnt));
        }
    }*/
    
    /* Determine ncon value for every residue */
    /* Counter for sequences in alignment */
    for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
    {   
        /* Counter for x-axis of contact map */
        for(xmat_cnt = 0; xmat_cnt < cmaps[memb_cnt]->Dim; xmat_cnt++)
        {
            /* Counter for y-axis of contact map */
            for(ymat_cnt = 0; ymat_cnt < cmaps[memb_cnt]->Dim; ymat_cnt++)
            {
                /* Check if position in contact map is 1 (i.e. contact) */
                if(ajInt2dGet(cmaps[memb_cnt]->Mat, xmat_cnt, ymat_cnt) == 1)
                {
                    /* Increment ncon counter */
                    nconcount++;
                }
            }
            /* Put nconcounter value into array */
            ajInt2dPut(&align_ncon, memb_cnt, xmat_cnt, nconcount);
            nconcount = 0;
        }
    }


    /* Diagnostic to print out align_ncon array */
/* DIAGNOSTICS
    for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
    {
        printf("\n");
        for(x=0;x<alg->width;x++)
            ajFmtPrint("%4d", ajInt2dGet(align_ncon, memb_cnt, x)); 
    }


    for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
    {
        printf("\n");
        for(x=0;x<alg->width;x++)
            ajFmtPrint("%4d", ajInt2dGet(seq_pos, memb_cnt, x)); 
    }
    
    printf("\n");*/

    /* Counter for positions in alignment */
    for(post_cnt = 0; post_cnt < alg->width; post_cnt++)
    {
        if(((ajStrChar(alg->Post_similar, post_cnt) == '1') && 
	    ((*scores)->filterpsim == ajTrue) &&
            ((*scores)->filtercon == ajTrue) && 
	    (ajIntGet((*scores)->ncon_thresh, post_cnt) == 1))
           ||   
           (((*scores)->filterpsim == ajTrue) && 
	    (ajStrChar(alg->Post_similar, post_cnt) == '1') &&
            ((*scores)->filtercon == ajFalse))
           ||
           (((*scores)->filterpsim == ajFalse) && 
	    (ajStrChar(alg->Post_similar, post_cnt) != '-') && 
            ((*scores)->filtercon == ajTrue) && 
	    (ajIntGet((*scores)->ncon_thresh, post_cnt) == 1))
           ||
           (((*scores)->filterpsim == ajFalse) && 
	    (ajStrChar(alg->Post_similar, post_cnt) != '-') && 
            ((*scores)->filtercon == ajFalse)))
        {
            /* Extract ncon for residues in alignment at that position */
            for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
            {
                /*Check to see if alignment position is a gap*/
                /* Assign position of seq_pos array to idx_seqpos */
                if((idx_seqpos = ajInt2dGet(seq_pos, memb_cnt, post_cnt))==-1)
                    continue;
                
                /* Assign position of atom_idx array to idx_atomidx */
                else
                    idx_atomidx = ajIntGet(atom_idx[memb_cnt], idx_seqpos);
                



                /* If noca is true, increment counter into align_ncon array by 1 */
                /* to take into account extra 'residue' not present in alignment */
                if(noca[memb_cnt] == ajTrue)
                {
                    nconpos_cnt += ajInt2dGet(align_ncon, memb_cnt, idx_atomidx);
                   /* DIAGNOSTICS
		      ajFmtPrint("post_cnt   = %4d memb_cnt = %4d\nseq_pos    = %4d\natomidx   
		      = %4d\nalign_ncon = %4d\nnconpos    = %4d\n\n", 
                               post_cnt, memb_cnt, idx_seqpos, idx_atomidx, 
                               ajInt2dGet(align_ncon, memb_cnt, idx_atomidx), nconpos_cnt);*/
                }
                
                /* Else continue as normal */
                else
                {
                    nconpos_cnt += ajInt2dGet(align_ncon, memb_cnt, (idx_atomidx - 1));
                    /* DIAGNOSTICS
		       ajFmtPrint("post_cnt   = %4d memb_cnt = %4d\nseq_pos    = %4d\natomidx  
		      = %4d\nalign_ncon = %4d\nnconpos    = %4d\n\n", 
		      post_cnt, memb_cnt, idx_seqpos, idx_atomidx, 
		      ajInt2dGet(align_ncon, memb_cnt, (idx_atomidx - 1)), nconpos_cnt);*/
                }
            }


            /* Divide total ncon at the position by no. of */
            /* sequences in alignment */
            av_ncon = (float)nconpos_cnt/(float)alg->N;
            nconpos_cnt = 0;


            /* Assign av. ncon value for residues at that position into */
            /* ncon_score array of scores structure at position */
            /* corresponding to alignment */
            ajFloatPut(&(*scores)->ncon_score, post_cnt, av_ncon);
        }
    }

    /* DIAGNOSTICS
       for(x=0;x<alg->width;x++)
       ajFmtPrint("%4f   %3d\n", ajFloatGet((*scores)->ncon_score, x), 
       ajIntGet((*scores)->ncon_thresh, x)); 
       printf("\n");*/


    /* Free memory for matrix and iterator */
    ajInt2dDel(&align_ncon);
    ajStrIterFree(&iter);


    /* Return */
    return ajTrue;
}





/* @funcstatic  siggen_ScoreCcon *****************************************************
 **
 ** Reada a Scopalg object and writes a Scorealg object. Each residue in 
 ** the alignment is scored on the basis of the conservation of phsyical 
 ** contacts (residue-residue) it makes in the structures. Contacts are 
 ** read from a Cmaps object.
 **
 ** @param [r] alg     [AjPScopalg ]    Alignment
 ** @param [w] scores  [AjPScorealg*]   Scores for alignment

 ** @param [r] cmaps   [AjPCmap*]       Residue contacts
 ** @param [r] seq_pos [AjPInt2d]       Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
static AjBool  siggen_ScoreCcon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps, 
                  AjPInt2d seq_pos, AjPInt *atom_idx, AjBool *noca)
{

    ajint       memb_cnt     =0;    /* Counter for members of the family (alignment) */
    ajint       post_cnt     =0;    /* Counter for post_similar line */
    ajint       y_cnt        =0;    /* Counter for y axis of contact matrix */
    ajint       seqpos_cnt   =0;    /* Counter for position in alignment */
    ajint       atomidx_cnt  =0;    /* Counter for position in actual sequence */
    ajint       nsite        =0;    /* Number of sites with oarticular contact */
    ajint       x            =0;    /* Counter */
    ajint       temp         =0;    /* Current position of seq_pos array */
    ajint       num          =0;    /* Assign to each element of con_contacts */
    ajint       p            =0;
    ajint       idx_seqpos   =0;    /* Index */
    ajint       idx_atomidx  =0;    /* Index */
    ajint       size         =0;    /* length of atom_idx arrays */

    float       sum          =0;    /* Variable to hold nsite calculation */
    AjIStr      iter         =NULL; /* Iterator for post_similar string */
    AjPInt2d    con_contact  =NULL; /* Matrix of conserv of contacts for every residue */
    AjPInt      con_line     =NULL; /* Temp storage of line */
    AjPInt      atomidx_size =NULL; /* Array of sizes of atom_idx arrays */
    


    
    /*Allocate memory for arrays  */
    con_contact    = ajInt2dNewL((ajint)alg->width);    
    con_line       = ajIntNewL((ajint)alg->width);
    atomidx_size   = ajIntNewL((ajint)alg->N);

    
    for(memb_cnt = 0; memb_cnt<alg->N;memb_cnt++)
    {
        if(alg->width == cmaps[memb_cnt]->Dim)
        {
            for(x=0; x<=alg->width;x++)
            {
                if(ajIntGet(atom_idx[memb_cnt], x) == -1)
                {
                    ajIntPut(&atomidx_size, memb_cnt, x);
                    break;
                }
                else
                    continue;
            }
        }

        else
        {
            for(x=0; x<alg->width;x++)
            {
                if(ajIntGet(atom_idx[memb_cnt], x) == -1)
                {
                    ajIntPut(&atomidx_size, memb_cnt, x);
                    break;
                }
                else
                    continue;
            }
        }
    }
    

    
    /* Assign iterator for post_similar line */
    iter = ajStrIter(alg->Post_similar);
    

    
    /* Create arrays of size width */
    for(x = 0; x < alg->width; x++)
        ajInt2dPut(&con_contact, x, alg->width-1, 0);


    /* Create arrays of size width */
    ajIntPut(&con_line, alg->width-1, 0);



    /* Start of main loop */
    /* Iterate through Post_similar line */
    for(post_cnt = 0; post_cnt < alg->width; post_cnt++)
    {
        if(((ajStrChar(alg->Post_similar, post_cnt) == '1') && 
	    ((*scores)->filterpsim == ajTrue) &&
           ((*scores)->filtercon == ajTrue) && 
	    (ajIntGet((*scores)->ncon_thresh, post_cnt) == 1))
          ||
           (((*scores)->filterpsim == ajTrue) && 
	    (ajStrChar(alg->Post_similar, post_cnt) == '1') &&
           ((*scores)->filtercon == ajFalse))
           ||
           (((*scores)->filterpsim == ajFalse) && 
	    (ajStrChar(alg->Post_similar, post_cnt) != '-') && 
           ((*scores)->filtercon == ajTrue) && 
	    (ajIntGet((*scores)->ncon_thresh, post_cnt) == 1))
           ||
           (((*scores)->filterpsim == ajFalse) && 
	    (ajStrChar(alg->Post_similar, post_cnt) != '-') && 
           ((*scores)->filtercon == ajFalse)))
        {
            /* Create array of size width */
            for(x = 0; x < alg->width; x++)
                ajIntPut(&con_line, x, 0); 
            nsite = 0;
            num = 0;

            /* DIAGNOSTICS 
	       printf("\n\nPost_cnt = %d\n", post_cnt);*/

            /* Perform calculation for each member of family */

            for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
            {   
/* DIAGNOSTICS 
             printf("XXXXXmemb_cnt = %dXXXXX\n", memb_cnt);*/                

                /* Go through each element of cmap column */
                for(y_cnt = 0; y_cnt < cmaps[memb_cnt]->Dim; y_cnt++)
                {
                    /*Check to see if alignment position is a gap*/
                    if((idx_seqpos=ajInt2dGet(seq_pos,memb_cnt,post_cnt))==-1)
                        {
                            printf("Error! found a '-' in siggen_ScoreCcon function\n");
                            continue; 
                        }
                    
                    /* Assign position of atom_idx array to idx_atomidx */
                    else
                        idx_atomidx = ajIntGet(atom_idx[memb_cnt], idx_seqpos);
                    /*DIAGNOSTICS 
		      printf("idx_seqpos = %d \nidx_atomidx = %d\n", idx_seqpos, idx_atomidx);*/

                    if(noca[memb_cnt] == ajTrue)
                    {
                       /* DIAGNOSTICS 
			  printf(" NOCA = TRUE!!\n");*/
                        /*Check if position in contact map is 1 (i.e. contact) */
                        if(ajInt2dGet(cmaps[memb_cnt]->Mat, (idx_atomidx), y_cnt)==1)
                        {
                           /*DIAGNOSTICS 
			     printf("contact!! y_cnt = %d\n", y_cnt);*/
                        
                            /* Assign number of elements in atom_idx array to size */
                            size = ajIntGet(atomidx_size, memb_cnt);
                            /* determine position of ymat_cnt in atom_idx array */
                            for(atomidx_cnt=0; atomidx_cnt<size; atomidx_cnt++)
                            {
                                /* Assign value from atom_idx to variable */
                                idx_atomidx = ajIntGet(atom_idx[memb_cnt], atomidx_cnt);

                                /*DIAGNOSTICS 
				  printf("at position atomidx_cnt = %d atom_id = %d\n", 
				  atomidx_cnt,idx_atomidx);*/

                                /* Find position where value of y_cnt appears */
                                if(idx_atomidx == y_cnt)
                                {
                                 /*  DIAGNOSTICS 
				     printf("y_cnt = %d idx_atomidx = %d\n",y_cnt,idx_atomidx);  */
                                    /* atomidx_cnt = 4..... thus 4th structured res in seq_pos*/
                                    /* Determine position of the atomidx_cnt residue in seq_pos array */
                                    for(seqpos_cnt=0; seqpos_cnt<alg->width; seqpos_cnt++)
                                    {
                                        /* Assign value from seq_pos to variable */
                                        idx_seqpos=ajInt2dGet(seq_pos, memb_cnt, seqpos_cnt);
                                    
                                        /* Check if seq_pos element contains the (atomidx_cnt)th structured residue */
                                        if((idx_seqpos == atomidx_cnt) && (idx_seqpos != '-'))
                                        {
                                           /* DIAGNOSTICS 
					      printf("at seqpos_cnt = %d idx_seqpos = %d atomidx_cnt = %d\n", 
					      seqpos_cnt, idx_seqpos,atomidx_cnt);*/
                                            /* Assign current value of seqpos_cnt to temp */
                                            /* i.e. the element of seq_pos (hence position in alignment)  */
                                            /* where the residue from atom_idx array occurs */
                                            temp = seqpos_cnt; /* !!idx_seqpos*/
                                    
                                            /* increment the number if sites counter */
                                            if(ajIntGet(con_line, temp) == 0)
                                                nsite++;

                                            /* Increment element of con_line */
                                            ajIntInc(&con_line, (ajint) temp);

                                            /* !!idx_seqpos*/
                                            ajInt2dPut(&con_contact, post_cnt, seqpos_cnt, 
                                                       (ajIntGet(con_line, seqpos_cnt)));
                                            break;
                                        }
                                
                                        else
                                            continue;
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    else if(noca[memb_cnt] == ajFalse)
                    {
                        /*DIAGNOSTICS printf(" NOCA = FALSE!!\n");*/
                        /*Check if position in contact map is 1 (i.e. contact) */
                        /* -1 as atom_idx counts from 1 NOT ZERO!! */
                        if(ajInt2dGet(cmaps[memb_cnt]->Mat, (idx_atomidx-1), y_cnt)==1)
                        {
                           /* DIAGNOSTICS  printf("contact!! y_cnt = %d\n", y_cnt);*/
                        
                            /* Assign number of elements in atom_idx array to size */
                            size = ajIntGet(atomidx_size, memb_cnt);

                            /* determine position of ymat_cnt in atom_idx array */
                            for(atomidx_cnt=0; atomidx_cnt<size; atomidx_cnt++)
                            {
                                /* Assign value from atom_idx to variable */
                                idx_atomidx = ajIntGet(atom_idx[memb_cnt], atomidx_cnt);
				
                                /* DIAGNOSTICS  printf("at position atomidx_cnt = %d atom_id = %d\n", 
				  atomidx_cnt,idx_atomidx);*/
                                /* Find position where value of y_cnt appears */
                                /* +1 as atom_idx array counts from 1 */
                                if(idx_atomidx == (y_cnt + 1))
                                {
                                    /*DIAGNOSTICS  printf("y_cnt+1 = %d idx_atomidx = %d\n",(y_cnt + 1),idx_atomidx);  */
                                    /* atomidx_cnt = 4..... thus 4th structured res in seq_pos*/
                                    /* Determine position of the atomidx_cnt residue in seq_pos array */
                                    for(seqpos_cnt=0; seqpos_cnt<alg->width; seqpos_cnt++)
                                    {
                                        /* Assign value from seq_pos to variable */
                                        idx_seqpos=ajInt2dGet(seq_pos, memb_cnt, seqpos_cnt);
                                    
                                        /* Check if seq_pos element contains the (atomidx_cnt)th structured residue */
                                        if((idx_seqpos == atomidx_cnt) && (idx_seqpos != '-'))
                                        {
                                           /*DIAGNOSTICS  printf("at seqpos_cnt = %d idx_seqpos = %d atomidx_cnt = %d\n", 
					     seqpos_cnt, idx_seqpos,atomidx_cnt);*/
                                            /* Assign current value of seqpos_cnt to temp */
                                            /* i.e. the element of seq_pos (hence position in alignment)  */
                                            /* where the residue from atom_idx array occurs */
                                            temp = seqpos_cnt; /* !!idx_seqpos*/
                                    
                                            /* increment the number if sites counter */
                                            if(ajIntGet(con_line, temp) == 0)
                                                nsite++;

                                            /* Increment element of con_line */
                                            ajIntInc(&con_line, (ajint) temp);

                                            /* !!idx_seqpos*/
                                            ajInt2dPut(&con_contact, post_cnt, seqpos_cnt, 
                                                       (ajIntGet(con_line, seqpos_cnt)));
                                            break;
                                        }
                                
                                        else
                                            continue;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            /* Perform calculation */
            sum = 0;
            for(p = 0; p < alg->width; p++)
            {
                /*DIAGNOSTICS  ajFmtPrint("%2d", ajIntGet(con_line, p));*/
                /* Divide number of sequences making a contact with a particular */
                /* residue by the total no. of sequences                         */
                if(ajIntGet(con_line, p)!=0)
                    sum += ((float)(ajIntGet(con_line, p)/((float)(ajint)alg->N)));

            }

            

            /* Write total sum for all residues at position post_cnt*/
            /* into scores structure */ 
            ajFloatPut(&(*scores)->ccon_score, post_cnt, (sum/(float)nsite));
        }
    }


    /* Diagnostics */
/*   DIAGNOSTICS 
     printf("con_contact\n");
    for(p = 0; p < alg->width; p++)
    {
        for(x = 0; x < alg->width; x++)
            ajFmtPrint("%2d", ajInt2dGet(con_contact,p,x));
        printf("\n");
    }*/
    


    

    /* Free memory for arrays and iterator */
    ajIntDel(&con_line);
    ajIntDel(&atomidx_size);
    ajInt2dDel(&con_contact);
    ajStrIterFree(&iter);


    /* Return */
    return ajTrue;
}






/* @funcstatic  siggen_ScoreNCCon ****************************************************
 **
 ** Reada a Scopalg object and writes a Scorealg object. Each residue in 
 ** the alignment is scored on the basis of a combination of the the number 
 ** and conservation of phsyical contacts (residue-residue) it makes in the 
 ** structure. Contacts are read from a Cmaps object.
 ** 
 ** @param [r] alg     [AjPScopalg ]    Alignment
 ** @param [w] scores  [AjPScorealg*]   Scores for alignment
 ** @param [r] cmaps   [AjPCmap*]       Residue contacts
 ** @param [r] seq_pos [AjPInt2d]       Index for alignment

 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
static AjBool  siggen_ScoreNCCon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps,  
                   AjPInt2d seq_pos)
{
    /*JC added to stop make bitching */
    return ajFalse;
}





/* @funcstatic  siggen_ScoreCombined *****************************************************
 **
 ** Read the Scorealg structure and calculates the combined scores for 

 ** each structurally equivalent residue in the alignment.
 ** 
 **
 ** @param [w] scores  [AjPScorealg*] Scorealg object
 **
 ** @return [AjBool] True on succcess
 ** @@
 *****************************************************************************/
static AjBool  siggen_ScoreCombined(AjPScorealg *scores)
{
    /*JC added to stop make bitching */
    return ajFalse;
}





/* @funcstatic  siggen_SigSelect *************************************************
 **
 ** Read Scopalg and Scorealg objects and returns a pointer to a Signature
 ** object. The signature generated is derived from a number, determined
 ** by the sparsity of the signature, of the top-scoring positions in the 
 ** alignment
 **
 ** @param [r] alg        [AjPScopalg]  Alignment 
 ** @param [r] scores     [AjPScorealg] Scores for alignment
 ** @param [r] seq_pos    [AjPInt2d]    Index for alignment
 ** @param [r] sig_sparse [ajint]       Sparsity of signature
 ** @param [r] *pdb       [AjPPdb]      PDB structure
 ** @param [r] wsiz       [ajint]       Window size 
 ** @return [AjPSignature] Pointer to Signature structure or NULL on failure
 ** @@
 *****************************************************************************/
static AjPSignature  siggen_SigSelect(AjPScopalg alg, AjPScorealg scores, 
                               AjPInt2d seq_pos, ajint sig_sparse, AjPCmap *cmaps,
                               AjPInt *atom_idx, float *spar_check, ajint wsiz)
{
    ajint       nseqs=0;                /*Number of sequences*/
    ajint       idx              =0;    /*Index*/
    ajint       atomidx          =0;    /*Index*/
    ajint       cnt              =0;    /* Counter for post_similar line */
    ajint       first            =0;    /* Counter */
    ajint       x                =0;    /* Counter */
    ajint       memb_cnt         =0;    /* Counter */
    ajint       rand_cnt         =0;    /* Counter */
    ajint       j                =0;    /* Counter */
    ajint       i                =0;    /* Counter */
    ajint       av_temp          =0;    /* Counter */
    float       total_temp       =0;    /* Counter */
    ajint       imax             =0;    /* Loop exit condition */
    ajint       hold_pos         =0;    /* Counter to hold values whilst sorting */

    ajint       res_count        =0;    /* Counter for total number of residues */
    ajint       num_aligned      =0;    /* Number of positions scoring '1' in alignment */
    ajint       single_rescount  =0;
    ajint       gsiz             =0;    /* Temp. size of gap*/
    ajint       npos             =0;    /* Counter of signature positions*/
    ajint       sig_npos         =0;    /* Number of positions in signature */
    float       val              =0.0;  /*Temp. val*/
    float       seqmat_min       =0;    /* Variable for minimum seq subn score */
    float       seqmat_max       =0;    /* Variable for maximum seq subn score */
    float       seqvar_min       =0;    /* Variable for minimum seq var score */
    float       seqvar_max       =0;    /* Variable for maximum seq var score */
    float       ncon_min         =0;    /* Variable for minimum ncon score */
    float       ncon_max         =0;    /* Variable for maximum ncon score */
    float       ncon_temp        =0;    /* Variable for temp. ncon score */
    float       ccon_min         =0;    /* Variable for minimum ncon score */
    float       ccon_max         =0;    /* Variable for maximum ncon score */
    float       ccon_temp        =0;    /* Variable for temp. ncon score */
    float       hold             =0;    /* Counter to hold values whilst sorting */
    AjBool      done             =ajFalse;  /*Flag*/
    AjBool      finish           =ajFalse;  /*Flag*/
    AjBool      already_done     =ajFalse;  /*Flag*/
    AjPFloat    seqmat_normal    =NULL; /* Array of floats for normalised seqmat_score */
    AjPFloat    seqvar_normal    =NULL; /* Array of floats for normalised seqvar_score */
    AjPFloat    ncon_normal      =NULL; /* Array of floats for normalised ncon_score */
    AjPFloat    ccon_normal      =NULL; /* Array of floats for normalised ccon_score */
    AjPFloat    total_score      =NULL; /* Array of floats for total normalised scores */
    AjPInt      keyres_pos       =NULL; /* Total_score array, sorted in ascending order */
    AjPInt      post_sim         =NULL; /* Array for positions in post_similar line */
    AjPInt      seq_len          =NULL; /* Array of length of each seq, as in alignment  */
    AjPInt      fullseq_len      =NULL; /* Array of length of each seq, as in original seq  */
    AjPInt      rand_pos         =NULL; /* Array of positions for random selection  */
    AjPInt      temp_rand        =NULL; /* Array of positions for random selection  */
    AjPInt2d    keyres_seq       =NULL; /* Total_score array, sorted in ascending order */
    AjPInt2d    atomres_seq      =NULL; /* Total_score array, sorted in ascending order */
    AjPStr      *seq_array       =NULL; /* Arrays of sequence (w/o gaps) from alignment */
    AjPSignature sig=NULL;              /* Signature */
    float       spar             =0.0;
    
    double      rn               = 0;   
    int         irn              = 0; 
    

    /* Check args */
    if(!alg || !scores || !seq_pos || !sig_sparse || !atom_idx)
    {
        ajWarn("Null args passed to siggen_SigSelect");
        return NULL;
    }
    
    /* Seed the number generator */
    ajRandomSeed();
    
    /* Create arrays */
    seqmat_normal       =  ajFloatNewL(alg->width);
    seqvar_normal       =  ajFloatNewL(alg->width);
    ncon_normal         =  ajFloatNewL(alg->width);
    ccon_normal         =  ajFloatNewL(alg->width);
    total_score         =  ajFloatNewL(alg->width);
    keyres_pos          =  ajIntNewL(alg->width);    


    post_sim            =  ajIntNewL(alg->width);
    rand_pos            =  ajIntNewL(alg->width);
    keyres_seq          =  ajInt2dNew();    
    atomres_seq         =  ajInt2dNew();    
    seq_len             =  ajIntNewL(alg->N);    
    fullseq_len         =  ajIntNewL(alg->N);    
    

    /* Initialise array elements to zero */
    ajFloatPut(&seqmat_normal, alg->width-1, (float) 0.0);

    ajFloatPut(&seqvar_normal, alg->width-1, (float) 0.0);
    ajFloatPut(&ncon_normal, alg->width-1, (float) 0.0);
    ajFloatPut(&ccon_normal, alg->width-1, (float) 0.0);
    ajFloatPut(&total_score, alg->width-1, (float) 0.0);

    ajIntPut(&keyres_pos, alg->width-1, (ajint) 0);
    ajIntPut(&post_sim, alg->width-1, (ajint) 0);
    ajIntPut(&rand_pos, alg->width-1, (ajint) 0);

    nseqs=ajXyzScopalgGetseqs(alg, &seq_array);

    /* Start of main application loop */
    /* Determine min and max values of seqmat_score */
    /* Iterate through (scores)->seqmat_score array */

    if((scores)->seqmat_do == ajTrue)
    {
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Check if value is not zero */
            if(ajFloatGet((scores)->seqmat_score, cnt) != 0)
            {

                /* If in loop for first time assign min and max */

                if(first == 0)
                {
                    seqmat_min = ajFloatGet((scores)->seqmat_score, cnt);
                    seqmat_max = ajFloatGet((scores)->seqmat_score, cnt);
                    first = 1;
                }


                /* Check if value is >, <, = to min/max */
                /* If true assign value to min/max variable */
                if(ajFloatGet((scores)->seqmat_score, cnt) < seqmat_min)
                    seqmat_min = ajFloatGet((scores)->seqmat_score, cnt);
                if(ajFloatGet((scores)->seqmat_score, cnt) == seqmat_min)
                    continue;
                if(ajFloatGet((scores)->seqmat_score, cnt) == seqmat_max)
                    continue;
                if(ajFloatGet((scores)->seqmat_score, cnt) > seqmat_max)
                    seqmat_max = ajFloatGet((scores)->seqmat_score, cnt);
            }
        }
    }

    /* Start of main application loop */
    /* Determine min and max values of seqvar_score */
    /* Iterate through (scores)->seqvar_score array */
    if((scores)->seqvar_do == ajTrue)
    {
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Check if value is not zero */
            if(ajFloatGet((scores)->seqvar_score, cnt) != 0)
            {
                /* If in loop for first time assign min and max */
                if(first == 0)
                {
                    seqvar_min = ajFloatGet((scores)->seqvar_score, cnt);
                    seqvar_max = ajFloatGet((scores)->seqvar_score, cnt);

                    first = 1;
                }



                /* Check if value is >, <, = to min/max */
                /* If true assign value to min/max variable */
                if(ajFloatGet((scores)->seqvar_score, cnt) < seqvar_min)
                    seqvar_min = ajFloatGet((scores)->seqvar_score, cnt);
                if(ajFloatGet((scores)->seqvar_score, cnt) == seqvar_min)
                    continue;
                if(ajFloatGet((scores)->seqvar_score, cnt) == seqvar_max)
                    continue;

                if(ajFloatGet((scores)->seqvar_score, cnt) > seqvar_max)
                    seqvar_max = ajFloatGet((scores)->seqvar_score, cnt);
            }
        }
    }




    /* Determine min and max values of ncon_score */
    /* Iterate through (scores)->ncon_score array */
    if((scores)->ncon_do == ajTrue)
    {
        first = 0;
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Check if value is not zero */
            if(ajFloatGet((scores)->ncon_score, cnt) != 0)
            {
                /* If in loop for first time assign min and max */
                if(first == 0)

                {
                    ncon_min = ncon_max = ajFloatGet((scores)->ncon_score, cnt);

                    first = 1;

                }


                ncon_temp = ajFloatGet((scores)->ncon_score, cnt);
                if(ncon_temp < ncon_min)


                    ncon_min = ncon_temp;
                else if(ncon_temp > ncon_max)

                    ncon_max = ncon_temp;
            }
        }
/*    DIAGNOSTICS     printf("ncon_min = %f ncon_max = %f\n", ncon_min, ncon_max);*/
    }

    /* Determine min and max values of ccon_score */
    /* Iterate through (scores)->ccon_score array */
    if((scores)->ccon_do == ajTrue)
    {

        first = 0;
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Check if value is not zero */
            if(ajFloatGet((scores)->ccon_score, cnt) != 0)
            {
                /* If in loop for first time assign min and max */
                if(first == 0)

                {
                    ccon_min = ccon_max = ajFloatGet((scores)->ccon_score, cnt);

                    first = 1;

                }


                ccon_temp = ajFloatGet((scores)->ccon_score, cnt);
                if(ccon_temp < ccon_min)
                    ccon_min = ccon_temp;

                else if(ccon_temp > ccon_max)
                    ccon_max = ccon_temp;
            }
        }
/*    DIAGNOSTICS     printf("ncon_min = %f ncon_max = %f\n", ncon_min, ncon_max);*/
    }



    /* Perform normalising calculation on seqmat_score array */
    if((scores)->seqmat_do == ajTrue)
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Only perform nornalisation on Post_similar */
            /* positions with value '1' or '0', if filter = ajFalse */
	    /*  if((((scores)->filterpsim) && 
		(ajStrChar(alg->Post_similar, cnt) == '1')) ||
               ((scores)->filterpsim == ajFalse))*/
	    
	    /* if(((ajStrChar(alg->Post_similar, cnt) == '1') && ((scores)->filterpsim == ajTrue)) 
               || (((scores)->filterpsim == ajFalse) && ((ajStrChar(alg->Post_similar, cnt) == '1')
              ||  (ajStrChar(alg->Post_similar, cnt) == '0'))))*/

	    if(((ajStrChar(alg->Post_similar, cnt) == '1') && 
		((scores)->filterpsim == ajTrue) &&
		((scores)->filtercon == ajTrue) && 	
		(ajIntGet((scores)->ncon_thresh, cnt) == 1))
	       ||
	       (((scores)->filterpsim == ajTrue) && 
		(ajStrChar(alg->Post_similar, cnt) == '1') &&
		((scores)->filtercon == ajFalse))
	       ||
	       (((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, cnt) != '-') && 
		((scores)->filtercon == ajTrue) && 
		(ajIntGet((scores)->ncon_thresh, cnt) == 1))
	       ||
	       (((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, cnt) != '-') && 
		((scores)->filtercon == ajFalse)))
            {   
                /* Put normalised score into array at eqiuvalent position */
                ajFloatPut(&seqmat_normal, cnt,((ajFloatGet((scores)->seqmat_score, cnt) 
                                                 - seqmat_min)/(seqmat_max - seqmat_min)));
            }	
            else
                ajFloatPut(&seqmat_normal, cnt, 0);
        }


    /* Perform normalising calculation on seqvar_score array */
    if((scores)->seqvar_do == ajTrue)
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Only perform nornalisation on Post_similar */
            /* positions with value '1'                   */

/*          if((((scores)->filterpsim) && (ajStrChar(alg->Post_similar, cnt) == '1')) ||
               ((scores)->filterpsim == ajFalse))*/
/*        if(((ajStrChar(alg->Post_similar, cnt) == '1') && ((scores)->filterpsim == ajTrue)) || 
           (((scores)->filterpsim == ajFalse) && ((ajStrChar(alg->Post_similar, cnt) == '1')
           ||  (ajStrChar(alg->Post_similar, cnt) == '0'))))*/

	    if(((ajStrChar(alg->Post_similar, cnt) == '1') && 
		((scores)->filterpsim == ajTrue) &&
		((scores)->filtercon == ajTrue) && 
		(ajIntGet((scores)->ncon_thresh, cnt) == 1))
	       ||
	       (((scores)->filterpsim == ajTrue) && 
		(ajStrChar(alg->Post_similar, cnt) == '1') &&
		((scores)->filtercon == ajFalse))
	       ||
	       (((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, cnt) != '-') && 
		((scores)->filtercon == ajTrue) && 
		(ajIntGet((scores)->ncon_thresh, cnt) == 1))
	       ||
	       (((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, cnt) != '-') && 
		((scores)->filtercon == ajFalse)))
            {   
                /* Put normalised score into array at eqiuvalent position */
                ajFloatPut(&seqvar_normal, cnt,((ajFloatGet((scores)->seqvar_score, cnt) 
                                          - seqvar_min)/(seqvar_max - seqvar_min)));

            }

            else

                ajFloatPut(&seqvar_normal, cnt, 0);
        }
    
 

    /* Perform normalising calculation on ncon_score array */
    if((scores)->ncon_do == ajTrue)
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Only perform nornalisation on Post_similar */
            /* positions with value '1'                   */
/*          if((((scores)->filterpsim) && (ajStrChar(alg->Post_similar, cnt) == '1')) ||
               ((scores)->filterpsim == ajFalse))*/
/*                if(((ajStrChar(alg->Post_similar, cnt) == '1') && ((scores)->filterpsim == ajTrue)) 
                   || (((scores)->filterpsim == ajFalse) && ((ajStrChar(alg->Post_similar, cnt) == '1')
                   ||  (ajStrChar(alg->Post_similar, cnt) == '0'))))*/

	    if(((ajStrChar(alg->Post_similar, cnt) == '1') && 
		((scores)->filterpsim == ajTrue) &&
		((scores)->filtercon == ajTrue) && 
		(ajIntGet((scores)->ncon_thresh, cnt) == 1))
	       ||
	       (((scores)->filterpsim == ajTrue) && 
		(ajStrChar(alg->Post_similar, cnt) == '1') &&
		((scores)->filtercon == ajFalse))
	       ||
	       (((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, cnt) != '-') && 
		((scores)->filtercon == ajTrue) && 
		(ajIntGet((scores)->ncon_thresh, cnt) == 1))
	       ||
	       (((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, cnt) != '-') && 
		((scores)->filtercon == ajFalse)))
            {
                /* Put normalised score into array at eqiuvalent position */
                ajFloatPut(&ncon_normal, cnt,((ajFloatGet((scores)->ncon_score, cnt) 
                                           - ncon_min)/(ncon_max - ncon_min)));  
            }   
            
            else
                ajFloatPut(&ncon_normal, cnt, 0);           
            
        }

    
    /* Perform normalising calculation on ccon_score array */
    if((scores)->ccon_do == ajTrue)
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Only perform nornalisation on Post_similar */
            /* positions with value '1'                   */
/*          if((((scores)->filterpsim) && (ajStrChar(alg->Post_similar, cnt) == '1')) ||
               ((scores)->filterpsim == ajFalse))*/
/*                if(((ajStrChar(alg->Post_similar, cnt) == '1') && ((scores)->filterpsim == ajTrue)) 
                   || (((scores)->filterpsim == ajFalse) && ((ajStrChar(alg->Post_similar, cnt) == '1')
                   ||  (ajStrChar(alg->Post_similar, cnt) == '0'))))*/

        if(((ajStrChar(alg->Post_similar, cnt) == '1') && 
	    ((scores)->filterpsim == ajTrue) &&
           ((scores)->filtercon == ajTrue) && 	
	    (ajIntGet((scores)->ncon_thresh, cnt) == 1))
	   ||
           (((scores)->filterpsim == ajTrue) && 
	    (ajStrChar(alg->Post_similar, cnt) == '1') &&
           ((scores)->filtercon == ajFalse))
           ||
           (((scores)->filterpsim == ajFalse) && 
	    (ajStrChar(alg->Post_similar, cnt) != '-') && 
           ((scores)->filtercon == ajTrue) && 
	    (ajIntGet((scores)->ncon_thresh, cnt) == 1))
           ||
           (((scores)->filterpsim == ajFalse) && 
	    (ajStrChar(alg->Post_similar, cnt) != '-') && 
           ((scores)->filtercon == ajFalse)))
            {
                /* Put normalised score into array at eqiuvalent position */
                ajFloatPut(&ccon_normal, cnt,((ajFloatGet((scores)->ccon_score, cnt) 
                                           - ccon_min)/(ccon_max - ccon_min)));  
            }   
            
            else
                ajFloatPut(&ccon_normal, cnt, 0);           
            
        }

    


/* MJB changed so ccon_score array is normalised */
/* exactly the same way as other scores          */
/* to change, uncomment  following 6 lines and   */
/* comment out previous section                  */

   /* Copying ccon_score array to ccon_normal */
/*    if((scores)->ccon_do == ajTrue)
        for(cnt =0; cnt <alg->width; cnt++)*/

            /* Put normalised score into array at eqiuvalent position */
/*            ajFloatPut(&ccon_normal, cnt,((ajFloatGet((scores)->ccon_score, 
                                                      cnt))));*/
    
    /* Add total scores for each position depending on the */
    /* scoring options selected.  Enter value in total_score array */

    for(x=0; x<alg->width; x++)
    {
        val=0.0;
        if((scores)->seqmat_do == ajTrue) 
            val+=ajFloatGet(seqmat_normal, x);

        if((scores)->seqvar_do == ajTrue) 
            val+=ajFloatGet(seqvar_normal, x);

        if((scores)->ncon_do == ajTrue) 
            val+=ajFloatGet(ncon_normal, x);

        if((scores)->ccon_do == ajTrue)
            val+=ajFloatGet(ccon_normal, x);


        ajFloatPut(&total_score, x, val);

    }
    
    /* Initialise array elements from 0 to alg->width */
    /* Count number of potential signature positions  */
    /* depending on the scoring methods selected      */
    num_aligned = -1;
    
    for(x=0; x<alg->width; x++)
    {
        /* initialise post_sim array to zero */
        ajIntPut(&post_sim, x, x);
        
        /* Check if filtersim and filtercon are true */
        /* and that ncon_thresh and post_similar = 1 */
        /* if so incrememnt num_aligned              */
        if((ajStrChar(alg->Post_similar, x) == '1') && 
	   ((scores)->filterpsim == ajTrue) &&
           ((scores)->filtercon == ajTrue) && 
	   (ajIntGet((scores)->ncon_thresh, x) == 1))
            {
		num_aligned++;
		ajIntPut(&rand_pos, j++, x);
	    }
	
        else if(((scores)->filterpsim == ajTrue) && 
		(ajStrChar(alg->Post_similar, x) == '1') &&
           ((scores)->filtercon == ajFalse))
	    {
		num_aligned++;
		ajIntPut(&rand_pos, j++, x);
	    }
	
        else if(((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, x) != '-') && 
           ((scores)->filtercon == ajTrue) && 
		(ajIntGet((scores)->ncon_thresh, x) == 1))
            {
		num_aligned++;
		ajIntPut(&rand_pos, j++, x);
	    }
	
        else if(((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, x) != '-') && 

           ((scores)->filtercon == ajFalse))
	{
            num_aligned++;
	    ajIntPut(&rand_pos, j++, x);
	}
	

        /*ajIntPut(&post_sim, x, x);*/
        /* Count positions with '1'  */
/*        if((scores->filterpsim == ajTrue) && (ajStrChar(alg->Post_similar, x) == '1'))
            num_aligned++;

        else if((scores->filterpsim == ajFalse) && (ajStrChar(alg->Post_similar, x) != '-'))
            num_aligned++;*/
    }    

    /* Diagnostics */
/*    if(scores->filtercon == ajTrue && scores->filterpsim == ajTrue)
        printf("filtercon = true!! filterpsim = true!! num_aligned = %d\n", num_aligned);

    else if(scores->filtercon == ajTrue && scores->filterpsim == ajFalse)
        printf("filtercon = true!! filterpsim = false!! num_aligned = %d\n", num_aligned);

    else if(scores->filtercon == ajFalse && scores->filterpsim == ajTrue)

        printf("filtercon = false!! filterpsim = true!! num_aligned = %d\n", num_aligned);

    else if(scores->filtercon == ajFalse && scores->filterpsim == ajFalse)
        printf("filtercon = false!! filterpsim = false!! num_aligned = %d\n", num_aligned);*/


    /* If filter == ajFalse, count number of positions */
    /* With post_similar value of '1' and '0'          */
   /* for(x=0; x<alg->width; x++)
    {
        ajIntPut(&post_sim, x, x);*/
        /* Count positions with '1' and '0' */
/*        if(((scores)->filterpsim == ajFalse) && ((ajStrChar(alg->Post_similar, x) == '1') 
                                  ||(ajStrChar(alg->Post_similar, x) == '0')))
                num_aligned++;
    }    */



    /* Perform bubble sort of total_score array  */ 
    for(i=1; i<=(alg->width-1); i++)
        for(j=0; j<=(alg->width-2); j++)
        { 
            /* Check if element j is > than element j+1 */
            if((ajFloatGet(total_score, j)) > 
               (ajFloatGet(total_score, (j + 1))))
            {
                /* Swap elements j and j+1 via hold/hold_pos variables */
                hold = ajFloatGet(total_score, j);

                hold_pos = ajIntGet(post_sim, j);
                ajFloatPut(&total_score, j, (ajFloatGet(total_score, (j+1))));

                ajIntPut(&post_sim, j, (ajIntGet(post_sim, (j+1))));
                ajFloatPut(&total_score, (j+1), hold);
                ajIntPut(&post_sim, (j+1), hold_pos);
            }           

        }

    /* Determine average number of residues for each sequence from ALIGNMENT  */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
    {
        single_rescount = 0;
        for(i=0; i<alg->width; i++)
            if(ajStrChar(alg->Seqs[memb_cnt], i) != '-')
            {
                single_rescount++;
            }

        ajIntPut(&seq_len, memb_cnt, single_rescount);
    }

    /* Determinine actual length of each sequence from */
    /* dimensions of cmap, NOT the STAMP alignment     */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
    {
/* DIAGNOSTICS
       printf("loop %d\n", memb_cnt);
        ajFmtPrint("cmaps[%d]->Dim = %d\n", memb_cnt, cmaps[memb_cnt]->Dim); */
        ajIntPut(&fullseq_len, memb_cnt, cmaps[memb_cnt]->Dim);
        res_count += cmaps[memb_cnt]->Dim;
    }
    

    /* Initialise keyres_seq array to zero */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
        for(i=0; i<ajIntGet(seq_len, memb_cnt); i++)
            ajInt2dPut(&keyres_seq, memb_cnt, i, 0);

    /* Initialise atomres_seq array to zero */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
        for(i=0; i<ajIntGet(fullseq_len, memb_cnt); i++)
            ajInt2dPut(&atomres_seq, memb_cnt, i, 0);    
    
    /* Calculate the number of positions the signature should have */
    /* Determine no. of positions the signature will have */
    /* JC New way of calculating sig_npos */
    sig_npos = (ajint) ceil((double)  ((res_count/alg->N) * 
                                       ( (float)sig_sparse/(float)100)));


    
    for(i=((alg->width)-1); i>((alg->width)-sig_npos); i--)
    {
        /*ajFmtPrint("i = %d %f %d \n", i, ajFloatGet(total_score, i), ajIntGet(post_sim, i));*/
        if(ajFloatGet(total_score, i) == 0)

            printf("Total_score array = 0.00 at position = %d\n", i);
    }


    /* Do random number generating here and fill post_sim array */
    /* from the end with the random numbers which equate to the */
    /* putative signature positions identified above            */

    /* Assign temp array and initialise */
    temp_rand =  ajIntNewL(num_aligned);
    for(i=0;i<num_aligned;i++)
        ajIntPut(&temp_rand, i, -1);
    
    if(scores->random == ajTrue)
    {    
        while(finish == ajFalse)
        {
            /* Generate random number */
            rn = ajRandomNumberD();
            irn = (int) (rn * (double)num_aligned);
            already_done = ajFalse;
            
            /* Check number hasn't already been put into array */
            for(i=0;i<num_aligned;i++)
            {
                if(ajIntGet(temp_rand, i) == irn)
                {
                    already_done = ajTrue;
                    break;
                }       
            
                else
                    continue;
            }

            /* If number not already in array, then put it in */
            if(already_done == ajFalse)
                ajIntPut(&temp_rand, rand_cnt++, irn);

            /* Number already in array so continue and choose another */
            else
                continue;

            /* If all array elements filled then finish while loop */
            if(rand_cnt == num_aligned)

            {   
                finish = ajTrue;
                /*printf("rand_cnt = %d num_aligned = %d\n", rand_cnt, num_aligned);*/
            }
        }
    
        /*printf("out!!\n");
        printf("rand_cnt = %d num_aligned = %d\n", rand_cnt, num_aligned);
        
        printf("temp_rand\n");
        for(i=0;i<num_aligned;i++)

            ajFmtPrint("%4d\n", ajIntGet(temp_rand, i));*/
        
        /* Diagnostic to sort temp_rand and check all number are present */
        /*for(i=0;i<num_aligned;i++)
          ajSortIntInc((ajint *) ajIntInt(temp_rand), num_aligned);
          
          printf("sorted temp_rand\n");
          for(i=0;i<num_aligned;i++)
          ajFmtPrint("%4d\n", ajIntGet(temp_rand, i));*/
        
/*      printf("post_sim\n");
        for(i=0;i<alg->width;i++)
            ajFmtPrint("%4d\n", ajIntGet(post_sim, i));*/
        
        
        /* Copy the random numbers to the last 'num_aligned' positions */
        /* of the post_sim array */
        for(i=0;i<num_aligned;i++)
            ajIntPut(&post_sim, ((alg->width) - i), ajIntGet(rand_pos, ajIntGet(temp_rand, i)));
        
/*      printf("new post_sim\n");
        for(i=0;i<alg->width;i++)
            ajFmtPrint("%4d\n", ajIntGet(post_sim, i));*/
    }



    /* Check if the user entered sparsity exceeds */
    /* the number of positions which are aligned  */
    /* in the alignment                           */
    if(num_aligned < sig_npos)
    {
        /* calculate sparsity for number of aligned positions */
        av_temp = (ajint) (res_count/alg->N);
        total_temp = (((float)num_aligned/(float)av_temp) * (float)100);

        /* If so print message */
	/*  DIAGNOSTICS */
        ajFmtPrint("There are not sufficient aligned positions to generate a "
		   "signature of the specified sparsity.\nSignature sparsity = %.2f\n", 
		   total_temp);

	if(total_temp < 1)
	{
	    /* Tidy up */
	    ajFloatDel(&seqmat_normal);
	    ajFloatDel(&seqvar_normal);
	    ajFloatDel(&ncon_normal);
	    ajFloatDel(&ccon_normal);
	    ajFloatDel(&total_score);
	    ajIntDel(&keyres_pos);   
	    ajIntDel(&post_sim);     
	    ajIntDel(&rand_pos);     
	    ajIntDel(&temp_rand);     
	    ajInt2dDel(&keyres_seq);
	    ajIntDel(&seq_len);
	    for(x=0;x<nseqs;x++)
		ajStrDel(&seq_array[x]);
	    AJFREE(seq_array);
	    ajInt2dDel(&atomres_seq);
	    ajIntDel(&fullseq_len);
	    return NULL;
	}
	
        spar = total_temp;
        (*spar_check) = (ceil((double)spar));

        /* Generate signature using all of the aligned positions */
        /* scoring '1' */
        /* Begin at end i.e. highest scoring positions */
        /* of post_sim array */
        /* Count down from end until all '1' positions are */
        /* entered in keyres_pos array */
        for(i=alg->width-1; i>=alg->width-(num_aligned); i--)
        {
            /* Put a '1' in keyres_pos array at position */
            /* corresponding to position in post_sim array */
            ajIntPut(&keyres_pos, ajIntGet(post_sim, i), 1);

        }
    }
    
    /* Else output signature of sparsity specified by user */
    else
    {
        /* Begin at end i.e. highest scoring positions */
        /* of post_sim array */
        /* Count down from end until sparsity is fulfilled */
        for(i=alg->width-1; i>=alg->width-(sig_npos); i--)
        {
            /* Put a '1' in keyres_pos array at position */
            /* corresponding to position in post_sim array */
            ajIntPut(&keyres_pos, ajIntGet(post_sim, i), 1);
        }
    }    




    /* fill 2d array with positions of each key res w.r.t. alignment seq */
    for(i=0; i<alg->width; i++)
    {
        if(ajIntGet(keyres_pos, i) == 1)
        {
            for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)            
            {
                /*Check to see if alignment position is a gap*/
                if((idx=ajInt2dGet(seq_pos, memb_cnt, i))==-1)
                    continue;
                else
                    ajInt2dPut(&keyres_seq, memb_cnt, idx, 1); 
            }
        }
    }


    /* convert keyres_seq array into atomidx_seq.               */
    /* i.e. the signature posions w.r.t. the original sequence  */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
    {            
        for(x=0; x<ajIntGet(seq_len, memb_cnt); x++)
        {
            if(ajInt2dGet(keyres_seq, memb_cnt, x)==1)
            {
                atomidx = ajIntGet(atom_idx[memb_cnt], x);
                /* DIAGNOSTICS 
		   ajFmtPrint("Key res at position %4d, atom_idx = %4d\n", x, (atomidx-1));*/
                ajInt2dPut(&atomres_seq, memb_cnt, (atomidx-1), 1);
            }
        }
    }


/* DIAGNOSTICS 
    printf("atom_idx\n");
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)                           
    {
        printf("\n");
        for(x=0; x<(ajIntGet(fullseq_len, memb_cnt)-10); x++)
            ajFmtPrint("%4d", ajIntGet(atom_idx[memb_cnt], x));
    }
    printf("\n");*/

/*  DIAGNOSTICS 
   for(i=0; i<alg->width; i++)
    {
        ajFmtPrint("%d", ajIntGet(keyres_pos, i));
    }*/
    
    
    /* DIAGNOSTICS  
    printf("\n\nkeyres_seq\n");
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)                   
    {
        printf("\n");
        for(x=0; x<ajIntGet(seq_len, memb_cnt); x++)
            ajFmtPrint("%d", ajInt2dGet(keyres_seq, memb_cnt, x));
    }
    */
    /* DIAGNOSTICS
    printf("\n\natomres_seq\n");
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)                   
    {
        printf("\n");
        for(x=0; x<ajIntGet(fullseq_len, memb_cnt); x++)
            ajFmtPrint("%d", ajInt2dGet(atomres_seq, memb_cnt, x));
    }
*/      

    /* Allocate signature structure and write SCOP classification records*/
    /* If not enough aligned positions then make structure size num_aligned */
    if(num_aligned < sig_npos)
            sig =  ajXyzSignatureNew(num_aligned);
    else
        sig =  ajXyzSignatureNew(sig_npos);

    ajStrAss(&sig->Class, alg->Class);
    ajStrAss(&sig->Fold, alg->Fold);
    ajStrAss(&sig->Superfamily, alg->Superfamily);
    ajStrAss(&sig->Family, alg->Family);
    sig->Sunid_Family =  alg->Sunid_Family;

    /* Allocate sigdat structures, don't know the number of 
       residue or gaps in advance, these are set below, but
       set the window size here */
    /* Tue Oct  1 08:13:45 BST 2002 */
    for(x=0; x<sig->npos; x++)
    {
	sig->dat[x]=ajXyzSigdatNew(0, 0);
	sig->dat[x]->wsiz=wsiz;
    }
    


    /* Write signature structure */
    for(j=0; j<alg->N; j++)
    {   /* seq_len changed to fullseq_len */
        for(npos=0, gsiz=0, i=0, imax=ajIntGet(fullseq_len, j); 
            i<imax; 
            i++)       
        {

            /* keyres_seq changed to atomres_seq */
            /* The position is a signature position */
            if(ajInt2dGet(atomres_seq, j, i) == 1)
            {
                /*Process gap */
                for(done=ajFalse,x=0;x<sig->dat[npos]->ngap;x++)
                {
                    /*The gap length is NOT new*/
                    if((ajIntGet(sig->dat[npos]->gsiz, x)==gsiz))
                    {
                        ajIntInc(&sig->dat[npos]->gfrq, x);
                        /* DIAGNOSTICS
			   printf("npos = %4d, memb_cnt = %4d, gsiz = %4d gfrq = %4d\n", npos, j, gsiz, 
                               ajIntGet(sig->dat[npos]->gfrq, x));*/
                        done=ajTrue;
                        break;

                    }   
                }

                

                /*The gap length is new*/
                if(!done)
                {
                    sig->dat[npos]->ngap++;
                    ajIntPut(&sig->dat[npos]->gsiz, sig->dat[npos]->ngap-1, 
                             gsiz);
                    ajIntPut(&sig->dat[npos]->gfrq, sig->dat[npos]->ngap-1, 
                             (ajint) 1);
		    /* DIAGNOSTICS 
		       printf("npos = %4d, memb_cnt = %4d, gsiz = %4d gfrq = %4d\n", npos, j, gsiz, 
		       ajIntGet(sig->dat[npos]->gfrq, x));*/
                }    



                /*Process residue*/
               /* for(done=ajFalse,x=0;x<sig->dat[npos]->nres;x++)*/
                    /*The residue id is NOT new*/
                /*{*/
                   /* if((ajChararrGet(sig->dat[npos]->rids, x))
                       ==ajStrChar(seq_array[j], i))
                    {
                        ajIntInc(&sig->dat[npos]->rfrq, x);
                        done=ajTrue;
                        break;
                    }
                }*/


                /*The residue id is new*/
               /* if(!done)
                {
                    sig->dat[npos]->nres++;
                    ajChararrPut(&sig->dat[npos]->rids, sig->dat[npos]->nres-1, 

                                 ajStrChar(seq_array[j], i));

                    ajIntPut(&sig->dat[npos]->rfrq, sig->dat[npos]->nres-1, 
                             (ajint) 1);
                }*/    
                

                /* Set variables*/
                gsiz=0;
                npos++;
            }
            else
            {
                gsiz++;
            }
        }

    }





    /* Write residue id into signature structure */
    for(j=0; j<alg->N; j++)
    {
        /* seq_len changed to fullseq_len */
        for(npos=0, i=0, imax=ajIntGet(seq_len, j); 
            i<imax; 
            i++)       
        {
            /* keyres_seq changed to atomres_seq */
            /* The position is a signature position */
            if(ajInt2dGet(keyres_seq, j, i) == 1)
            {
                /*Process residue*/
                for(done=ajFalse,x=0;x<sig->dat[npos]->nres;x++)
                    /*The residue id is NOT new*/
                {
                    if((ajChararrGet(sig->dat[npos]->rids, x))
                       ==ajStrChar(seq_array[j], i))
                    {
                        ajIntInc(&sig->dat[npos]->rfrq, x);
                        done=ajTrue;
                        break;
                    }
                }


                /*The residue id is new*/
                if(!done)
                {
                    sig->dat[npos]->nres++;
                    ajChararrPut(&sig->dat[npos]->rids, sig->dat[npos]->nres-1,         
                                 ajStrChar(seq_array[j], i));

                    ajIntPut(&sig->dat[npos]->rfrq, sig->dat[npos]->nres-1, 
                            (ajint) 1);
                }    
                

                /* Set variables*/
                npos++;
            }
            else
            {
                continue;
            }
        }
    }
    
    

















/* DIAGNOSTICS
   Keep this until ajsort.c has been fixed
    printf("PREORDER\n");
    printf("No.gaps: %d   No.res: %d\n", sig->dat[0]->ngap, 
    sig->dat[0]->nres);
    for(x=0; x<sig->dat[0]->ngap;x++)
        printf("siz:%d frq:%d\n", ajIntGet(sig->dat[0]->gsiz, x), 
        ajIntGet(sig->dat[0]->gfrq, x));

  */  
    

  
    /* Perform bubble sort of gap sizes and frequencies array  */ 
    for(x=0; x<sig->npos;x++) 
    { 
/* DIAGNOSTICS
      for(i=0; i<sig->dat[x]->ngap;i++)
        {
            ajFmtPrint("npos/ngap = %d:  [%d] = %3d x %2d\n", x, i, ajIntGet(sig->dat[x]->gsiz, i),
                       ajIntGet(sig->dat[x]->gfrq, i));
        }*/     
/*       DIAGNOSTICS
        for(i=0; i<sig->dat[x]->ngap;i++)

        {
            ajFmtPrint("npos/gfrq = %d:  [%d] = %3d\n", x, i, ajIntGet(sig->dat[x]->gfrq, i));
        }*/
        
        for(cnt=1; cnt<(sig->dat[x]->ngap);cnt++)
            for(i=0; i<(sig->dat[x]->ngap-1);i++)
            {    
                /* Check if element i is > than element i+1 */
                if(ajIntGet(sig->dat[x]->gsiz, i) > ajIntGet(sig->dat[x]->gsiz, i+1))
                {       
                    /* Swap elements i and i+1 via y/hold_pos variables */
                    j        = ajIntGet(sig->dat[x]->gsiz, i);
                    hold_pos = ajIntGet(sig->dat[x]->gfrq, i);

                    ajIntPut(&sig->dat[x]->gsiz, i, ajIntGet(sig->dat[x]->gsiz, i+1));
                    ajIntPut(&sig->dat[x]->gfrq, i, ajIntGet(sig->dat[x]->gfrq, i+1));
                
                    ajIntPut(&sig->dat[x]->gsiz, i+1, j);
                    ajIntPut(&sig->dat[x]->gfrq, i+1, hold_pos);
                }               
            }
        
/*  DIAGNOSTICS
     printf("AFTER SORTING!!!!\n");
        for(i=0; i<sig->dat[x]->ngap;i++)
        {
            ajFmtPrint("npos/ngap = %d:  [%d] = %3d x %2d\n", x, i, ajIntGet(sig->dat[x]->gsiz, i),
                      ajIntGet(sig->dat[x]->gfrq, i));
        }*/
/* DIAGNOSTICS
        for(i=0; i<sig->dat[x]->ngap;i++)
        {
            ajFmtPrint("npos/gfrq = %d:  [%d] = %3d\n", x, i, ajIntGet(sig->dat[x]->gfrq, i));
        }*/
    }
    


      
    /* Reorder the gap data so it is in order of increasing sized gap*/
/*  DIAGNOSTICS
   for(x=0; x<sig->npos;x++)
    {   
        printf("BEFORE SORTING!!!!\n");
        for(i=0; i<sig->dat[x]->ngap;i++)
        {
            ajFmtPrint("npos/ngap = %d:  [%d] = %3d\n", x, i, ajIntGet(sig->dat[x]->gsiz, i));
        }

        for(i=0; i<sig->dat[x]->ngap;i++)
        {
            ajFmtPrint("npos/gfrq = %d:  [%d] = %3d\n", x, i, ajIntGet(sig->dat[x]->gfrq, i));
        }
        printf("\n");
   
        ajSortIntIncI((ajint *) ajIntInt(sig->dat[x]->gsiz), 
                      (ajint *) ajIntInt(sig->dat[x]->gfrq),  
                      sig->dat[x]->ngap);
        ajSortIntInc((ajint *) ajIntInt(sig->dat[x]->gsiz), sig->dat[x]->ngap);

        printf("AFTER SORTING!!!!\n");
        for(i=0; i<sig->dat[x]->ngap;i++)
        {
            ajFmtPrint("npos/ngap = %d:  [%d] = %3d\n", x, i, ajIntGet(sig->dat[x]->gsiz, i));
        }

        for(i=0; i<sig->dat[x]->ngap;i++)
        {
            ajFmtPrint("npos/gfrq = %d:  [%d] = %3d\n", x, i, ajIntGet(sig->dat[x]->gfrq, i));
        }
        printf("\n");


    } */
    

/* DIAGNOSTICS
 Keep this until ajsort.c has been fixed
    printf("POSTORDER\n");

     printf("No.gaps: %d   No.res: %d\n", sig->dat[0]->ngap, 
     sig->dat[0]->nres);
    for(x=0; x<sig->dat[0]->ngap;x++)
        printf("siz:%d frq:%d\n", ajIntGet(sig->dat[0]->gsiz, x), 
        ajIntGet(sig->dat[0]->gfrq, x));
  */  
    
    
    /* JC stuff for printing out in old signature format */
    
/*    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
    {
        printf(">>>TEST_%d\n", memb_cnt); 
        num = 0;
        printf("SEQU      "); 

        for(i=0; i<alg->width; i++)

        {
            if((ajStrChar(alg->Seqs[memb_cnt], i) != '-'))

            {
                ajFmtPrint("%c", ajStrChar(alg->Seqs[memb_cnt], i)); 

                num++;
                ajStrAppK(&seq_array[memb_cnt], 

                ajStrChar(alg->Seqs[memb_cnt], i)); 

            }
        }

        printf("\n");
        printf("KEY       "); 
        for(i=0; i<ajIntGet(seq_len, memb_cnt); i++)       
        {
            if(ajInt2dGet(keyres_seq, memb_cnt, i) == 1)
                printf("V");
            else
                printf(" ");
        }
        printf("\n");
        printf("SSA4      \n");
        printf("SSA4      \n");
        printf("KEY       ");
        for(i=0; i<ajIntGet(seq_len, memb_cnt); i++)       
        {
            if(ajInt2dGet(keyres_seq, memb_cnt, i) == 1)
                printf("V");
            else
                printf(" ");

        }
        printf("\n");
        printf("SEQU      ");
        for(i=0; i<alg->width; i++)
        {
            if((ajStrChar(alg->Seqs[memb_cnt], i) != '-'))
            {
                ajFmtPrint("%c", ajStrChar(alg->Seqs[memb_cnt], i));
                num++;
                ajStrAppK(&seq_array[memb_cnt], 
                ajStrChar(alg->Seqs[memb_cnt], i));
            }
        }
        printf("\n");
        }
*/
        
    /* Diagnostics 
   for(x=0; x<alg->width;x++)
    {
        ajFmtPrint("%10d %5d %10.3f %10.3f %10c", x, ajIntGet(scores->ncon_thresh, x), 
                   ajFloatGet(scores->seqmat_score, x), ajFloatGet(seqmat_normal, x), 
                   ajStrChar(alg->Post_similar, x));


        ajFmtPrint("%5d %5d %10.3f %10.3f %10c", x, ajIntGet(scores->ncon_thresh, x), 
                   ajFloatGet(scores->seqvar_score, x),ajFloatGet(seqvar_normal, x), 
                   ajStrChar(alg->Post_similar, x));

        ajFmtPrint("%5d %5d %10.3f %10.3f %10c", x, ajIntGet(scores->ncon_thresh, x), 
                   ajFloatGet(scores->ncon_score, x), ajFloatGet(ncon_normal, x), 
                   ajStrChar(alg->Post_similar, x));
        
        ajFmtPrint("%5d %5d %10.3f %10.3f %10c", x, ajIntGet(scores->ncon_thresh, x), 
                   ajFloatGet(scores->ccon_score, x), ajFloatGet(ccon_normal, x), 
                   ajStrChar(alg->Post_similar, x));


        ajFmtPrint("%5d %10.3f %10c\n", x, ajFloatGet(total_score, x), ajStrChar(alg->Post_similar, x)); 
    }
    
*/
/*x, ajIntGet(scores->ncon_thresh, x), ajFloatGet(scores->seqmat_score, x), 
  ajFloatGet(seqmat_normal, x), x, ajIntGet(scores->ncon_thresh, x), 
  ajFloatGet(scores->seqvar_score, x),ajFloatGet(seqvar_normal, x), x, 
  ajIntGet(scores->ncon_thresh, x), ajFloatGet(scores->ncon_score, x), 
  ajFloatGet(ncon_normal, x), x, ajIntGet(scores->ncon_thresh, x), 
  ajFloatGet(scores->ccon_score, x), ajFloatGet(ccon_normal, x), 
  ajFloatGet(total_score, x)); */




    /* Tidy up */
    ajFloatDel(&seqmat_normal);
    ajFloatDel(&seqvar_normal);
    ajFloatDel(&ncon_normal);
    ajFloatDel(&ccon_normal);
    ajFloatDel(&total_score);
    ajIntDel(&keyres_pos);   
    ajIntDel(&post_sim);     
    ajIntDel(&rand_pos);     
    ajIntDel(&temp_rand);     
    ajInt2dDel(&keyres_seq);
    ajIntDel(&seq_len);
    for(x=0;x<nseqs;x++)
        ajStrDel(&seq_array[x]);
    AJFREE(seq_array);
    /*JISON*/ajInt2dDel(&atomres_seq);
    /*JISON*/ajIntDel(&fullseq_len);
    /* Return */
    return sig;
}





/* @funcstatic  siggen_ScoreAlignment ************************************************
 **
 ** Convenience routine - calls several functions to score an alignment.
 **
 ** @param [r] alg     [AjPScopalg ]    Alignment
 ** @param [w] scores  [AjPScorealg*]   Scores for alignment
 ** @param [r] cmaps   [AjPCmap*]       Residue contacts
 ** @param [r] mat     [AjPMatrixf]     Subsitution matrix
 ** @param [r] noca     [AjBool *]       Bool array for NOCA groups
 ** @param [r] seq_pos [AjPInt2d]       Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
static AjBool siggen_ScoreAlignment(AjPScorealg *scores, AjPScopalg alg, 
                             AjPCmap *cmaps, AjPMatrixf  mat, 
                             AjBool *noca, AjPInt2d seq_pos, AjPInt *atom_idx)
{
    /*Check args */
    if( !(*scores) || !alg || !mat || !seq_pos || !atom_idx || !noca)
    {
        printf("Bad args passed to siggen_ScoreAlignment\n");
        return ajFalse;
    }
    
    

    /* Call scoring functions as appropriate */
    if((*scores)->seqmat_do)
    {
        siggen_ScoreSeqMat(alg, scores, mat, seq_pos);
    }
    

    if((*scores)->seqvar_do)      
        siggen_ScoreSeqVar(alg, scores, seq_pos);
    

    if((*scores)->ncon_do)     
    {
        if(!(*cmaps))
            return ajFalse;
        siggen_ScoreNcon(alg, scores, cmaps, seq_pos, atom_idx, noca);
    }
    

    if((*scores)->ccon_do)
    {
        if(!(*cmaps))
            return ajFalse;
        siggen_ScoreCcon(alg, scores, cmaps, seq_pos, atom_idx, noca); 
    }
    

    /* siggen_ScoreCombined(scores);*/
    

    return ajTrue;
}





/* @funcstatic  siggen_CalcSeqpos ****************************************************
 **
 ** Reads a Scopalg object and calculates an index for the alignment.
 **
 ** @param [r] alg     [AjPScopalg]   Alignment
 ** @param [w] seq_pos [AjPInt2d]     Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
static AjBool siggen_CalcSeqpos(AjPScopalg alg, AjPInt2d *seq_pos)
{
    ajint       z             =0;       /* Loop counter */
    ajint       memb_cnt      =0;       /* Counter for members of the family (alignment) */
    ajint       wid_cnt       =0;       /* Counter for position in the sequence */
    ajint       seq_cnt       =0;       /* Counter for position in seq w.r.t alignment */
    AjIStr      iter          =NULL; /* Iterator for sequence string */





    
    /*Check args */
    if(!alg)
        return ajFalse;


    /* This section determines the position of each aligned residue 
       in its original protein sequence  */
    /* Allocate memory for the seq_pos array  */
    *seq_pos    = ajInt2dNewL((ajint)alg->N);    

    
    /*Set reserved size */
    for(z = 0; z < alg->N; z++)
        ajInt2dPut(seq_pos, z, alg->width, (ajint) 0);



    /* Determine position of each residue in alignment */
    for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
    {
        /* Assign iterator for post_similar line */
        iter = ajStrIter((alg->Seqs[memb_cnt]));

/* DIAGNOSTICS
     ajFmtPrint("%S\n", alg->Seqs[memb_cnt]);*/
        
        /* Counter of sequence, reset for each member */
        seq_cnt = 0;
        
        
        for(wid_cnt = 0; wid_cnt < alg->width; wid_cnt++)
        {
            /* Check if sequence line is not '-' */     
            if(ajStrIterGetK(iter) != '-')
            {
                /* For every position in alignment assign */
                /* position of residue from its respective sequence */
                ajInt2dPut(seq_pos, memb_cnt, wid_cnt, seq_cnt);
                seq_cnt++;
            }
            else
                ajInt2dPut(seq_pos, memb_cnt, wid_cnt, -1);
            
            
            ajStrIterNext(iter);                                   
        }
        ajStrIterFree(&iter);
    }
        

/*  DIAGNOSTICS
    for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
    {
        printf("\n");
        for(wid_cnt = 0; wid_cnt < alg->width; wid_cnt++)
            ajFmtPrint("%3d", ajInt2dGet(*seq_pos, memb_cnt, wid_cnt)); 
    }
    
    printf("\n");       
    for(memb_cnt=0;memb_cnt<alg->width;memb_cnt++)
        printf("%2d", memb_cnt);
    
        
    printf("\n");*/
    
    /* Tidy up and return */

    return ajTrue;
}




/* @funcstatic  siggen_Con_thresh ***********************************************
 **
 ** Reads Cmaps object, and determines whether each position in the 
 ** structural alignment displays greater than a threshold (conthresh)
 ** number of (residue-residue) contacts.  A value of '1' is entered
 ** in the corresponding element of the ncon_thresh array (within 
 ** the scores structure), otherwise the element = '0'
 **
 ** @param [r] alg         [AjPScopalg ]  Alignment
 ** @param [w] scores      [AjPScorealg*] Scores for alignment
 ** @param [r] cmaps       [AjPCmap*]     Residue contacts

 ** @param [r] conthresh   [ajint]        contact threshold
 ** @param [r] noca         [AjBool *]     Bool array for NOCA groups
 ** @param [r] seq_pos     [AjPInt2d]     Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
static AjBool siggen_Con_Thresh(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps, 
ajint conthresh, AjBool *noca, AjPInt2d seq_pos, AjPInt *atom_idx)
{

    ajint       memb_cnt     =0;    /* Counter for members of the family (alignment) */
    ajint       xmat_cnt     =0;    /* Counter for x axis of contact matrix */
    ajint       ymat_cnt     =0;    /* Counter for y axis of contact matrix */
    ajint       nconcount    =0;    /* Counter for number of contacts at position*/
    ajint       x            =0;    /* Counter for initializing arrays to zero */
    ajint       post_cnt     =0;    /* Counter for post_similar line */
    ajint       nconpos_cnt  =0;    /* Counter to hold ncon */
    ajint       idx_seqpos   =0;    /* Index into seq_pos array */
    ajint       idx_atomidx  =0;    /* Index into atom_idx array */
    ajint       con_counter  =0;    /* counter */
    float       av_ncon      =0;    /* Counter to hold average no. of contacts */
    AjIStr      iter         =NULL; /* Iterator for post_similar string */
    AjPInt2d    align_ncon   =NULL; /* Matrix of number of contacts for every residue */



    /* Allocate memory for the align_ncon array  */
    align_ncon = ajInt2dNewL((ajint)alg->width);        


    /* Assign iterator for post_similar line */
    iter = ajStrIter(alg->Post_similar);


    /* Create arrays of size width */
    for(x = 0; x < alg->N; x++)
        ajInt2dPut(&align_ncon, x, alg->width-1, (ajint) 0);

    /* Diagnostic to print out contact maps */
    /* DIAGNOSTICS
       for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
    {
        printf("\n");
        printf("%d\n", memb_cnt);
        for(xmat_cnt = 0; xmat_cnt < cmaps[memb_cnt]->Dim; xmat_cnt++)
        {
            printf("\n");
            for(ymat_cnt = 0; ymat_cnt < cmaps[memb_cnt]->Dim; ymat_cnt++)
                ajFmtPrint("%2d", ajInt2dGet(cmaps[memb_cnt]->Mat, xmat_cnt, ymat_cnt));
        }
    }*/
    
    /* Determine ncon value for every residue */
    /* Counter for sequences in alignment */
    for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
    {   
        /* Counter for x-axis of contact map */
        for(xmat_cnt = 0; xmat_cnt < cmaps[memb_cnt]->Dim; xmat_cnt++)
        {
            /* Counter for y-axis of contact map */
            for(ymat_cnt = 0; ymat_cnt < cmaps[memb_cnt]->Dim; ymat_cnt++)
            {
                /* Check if position in contact map is 1 (i.e. contact) */
                if(ajInt2dGet(cmaps[memb_cnt]->Mat, xmat_cnt, ymat_cnt) == 1)
                {
                    /* Increment ncon counter */
                    nconcount++;
                }
            }
            /* Put nconcounter value into array */
            ajInt2dPut(&align_ncon, memb_cnt, xmat_cnt, nconcount);
            nconcount = 0;
        }
    }





    /* Counter for positions in alignment */
    for(post_cnt = 0; post_cnt < alg->width; post_cnt++)
    {
        if(((ajStrChar(alg->Post_similar, post_cnt) == '1') && ((*scores)->filterpsim == ajTrue)) || 
           (((*scores)->filterpsim == ajFalse) && ((ajStrChar(alg->Post_similar, post_cnt) != '-'))))
        {
            /* Extract ncon for residues in alignment at that position */
            for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
            {
                /*Check to see if alignment position is a gap*/
                if((idx_seqpos=ajInt2dGet(seq_pos, memb_cnt, post_cnt))==-1)
                    continue;
                
                /* Assign position of atom_idx array to idx_atomidx */
                else
                    idx_atomidx = ajIntGet(atom_idx[memb_cnt], idx_seqpos);
                                
                /* If noca is true, increment counter into align_ncon array by 1 */
                /* to take into account extra 'residue' not present in alignment */
                if(noca[memb_cnt] == ajTrue)
                {
                    nconpos_cnt += ajInt2dGet(align_ncon, memb_cnt, idx_atomidx);
/* DIAGNOSTICS
                  ajFmtPrint("post_cnt   = %4d memb_cnt = %4d\nseq_pos    = %4d\natomidx    "
		    "= %4d\nalign_ncon = %4d\nnconpos    = %4d\n\n", 
                               post_cnt, memb_cnt, idx_seqpos, idx_atomidx, 
                               ajInt2dGet(align_ncon, memb_cnt, idx_atomidx), nconpos_cnt);*/

                }
                
                /* Else continue as normal */
                else
                {
                    nconpos_cnt += ajInt2dGet(align_ncon, memb_cnt, (idx_atomidx - 1));
/* DIAGNOSTICS
                  ajFmtPrint("post_cnt   = %4d memb_cnt = %4d\nseq_pos    = %4d\natomidx    "
		    "= %4d\nalign_ncon = %4d\nnconpos    = %4d\n\n", 
                               post_cnt, memb_cnt, idx_seqpos, idx_atomidx, 
                               ajInt2dGet(align_ncon, memb_cnt, (idx_atomidx - 1)), nconpos_cnt);*/
                }
            }


            /* Divide total ncon at the position by no. of */
            /* sequences in alignment */
            av_ncon = (float)nconpos_cnt/(float)alg->N;

            nconpos_cnt = 0;

            
            /* Check if av_ncon value is greater the conthresh */
            if((av_ncon > (float)conthresh) || (av_ncon == (float)conthresh))
            {
                /* Assign '1' into position post_cnt of ncon_thresh array */
                ajIntPut(&(*scores)->ncon_thresh, post_cnt, 1);
                con_counter++;
            }

            /* Else put '0' into array at position post_cnt */
            else
                ajIntPut(&(*scores)->ncon_thresh, post_cnt, 0);
        }
    }


    /* Code to test that sufficient number of positions
       have > conthresh to enable a signature to be
       generated.  If not return ajFalse */
    
    /* Check 3 or more residues are above conthresh */
    /* or exit */
    if(con_counter < 3)
    {
        ajFmtPrint("There are not sufficient residues making greater than threshold "
		   "number of contacts.\nExiting......signature not generated\n");
        ajExit();
        return(0);
    }
    


    /* Free memory for matrix and iterator */
    ajInt2dDel(&align_ncon);
    ajStrIterFree(&iter);


    /* Return */
    return ajTrue;
}


/* 
Put this in to stop compiler bitching about unused functions 
*/
void siggen_unused()
{
    siggen_ScoreNCCon(NULL, NULL, NULL, NULL);
    siggen_ScoreCombined(NULL);
}











/* @funcstatic  siggen_SigSelectSeq *******************************************
 **
 ** Read Scopalg and Scorealg objects and returns a pointer to a Signature
 ** object. The signature generated is derived from a number, determined
 ** by the sparsity of the signature, of the top-scoring positions in the 
 ** alignment
 **
 ** @param [r] alg        [AjPScopalg]  Alignment 
 ** @param [r] scores     [AjPScorealg] Scores for alignment
 ** @param [r] seq_pos    [AjPInt2d]    Index for alignment
 ** @param [r] sig_sparse [ajint]       Sparsity of signature
 ** @param [r] *pdb       [AjPPdb]      PDB structure
 ** @param [r] wsiz       [ajint]       Window size 
 ** @return [AjPSignature] Pointer to Signature structure or NULL on failure
 ** @@
 *****************************************************************************/
static AjPSignature  siggen_SigSelectSeq(AjPScopalg alg, AjPScorealg scores, 
					 AjPInt2d seq_pos, ajint sig_sparse,
					 float *spar_check, ajint wsiz)
{
    ajint       nseqs=0;                /*Number of sequences*/
    ajint       idx              =0;    /*Index*/
    ajint       cnt              =0;    /* Counter for post_similar line */
    ajint       first            =0;    /* Counter */
    ajint       x                =0;    /* Counter */
    ajint       memb_cnt         =0;    /* Counter */
    ajint       rand_cnt         =0;    /* Counter */
    ajint       j                =0;    /* Counter */
    ajint       i                =0;    /* Counter */
    ajint       av_temp          =0;    /* Counter */
    float       total_temp       =0;    /* Counter */
    ajint       imax             =0;    /* Loop exit condition */
    ajint       hold_pos         =0;    /* Counter to hold values whilst sorting */

    ajint       res_count        =0;    /* Counter for total number of residues */
    ajint       num_aligned      =0;    /* Number of positions scoring '1' in alignment */
    ajint       single_rescount  =0;
    ajint       gsiz             =0;    /* Temp. size of gap*/
    ajint       npos             =0;    /* Counter of signature positions*/
    ajint       sig_npos         =0;    /* Number of positions in signature */
    float       val              =0.0;  /*Temp. val*/
    float       seqmat_min       =0;    /* Variable for minimum seq subn score */
    float       seqmat_max       =0;    /* Variable for maximum seq subn score */
    float       seqvar_min       =0;    /* Variable for minimum seq var score */
    float       seqvar_max       =0;    /* Variable for maximum seq var score */
    float       hold             =0;    /* Counter to hold values whilst sorting */
    AjBool      done             =ajFalse;  /*Flag*/
    AjBool      finish           =ajFalse;  /*Flag*/
    AjBool      already_done     =ajFalse;  /*Flag*/
    AjPFloat    seqmat_normal    =NULL; /* Array of floats for normalised seqmat_score */
    AjPFloat    seqvar_normal    =NULL; /* Array of floats for normalised seqvar_score */
    AjPFloat    ncon_normal      =NULL; /* Array of floats for normalised ncon_score */
    AjPFloat    ccon_normal      =NULL; /* Array of floats for normalised ccon_score */
    AjPFloat    total_score      =NULL; /* Array of floats for total normalised scores */
    AjPInt      keyres_pos       =NULL; /* Total_score array, sorted in ascending order */
    AjPInt      post_sim         =NULL; /* Array for positions in post_similar line */
    AjPInt      seq_len          =NULL; /* Array of length of each seq, as in alignment  */
    AjPInt      rand_pos         =NULL; /* Array of positions for random selection  */
    AjPInt      temp_rand        =NULL; /* Array of positions for random selection  */
    AjPInt2d    keyres_seq       =NULL; /* Total_score array, sorted in ascending order */
    AjPStr      *seq_array       =NULL; /* Arrays of sequence (w/o gaps) from alignment */
    AjPSignature sig=NULL;              /* Signature */
    float       spar             =0.0;
    
    double      rn               = 0;   
    int         irn              = 0; 
    ajint       len              = 0; 

    /* New stuff for randomising */
    ajint   rand_num=0;
    ajint   randpos_cnt=0;
    ajint   rand_total=0;
    ajint   p=0;
    ajint   new_gsiz=0;
    


    /* Check args */
    if(!alg || !scores || !seq_pos || !sig_sparse)
    {
        ajWarn("Null args passed to siggen_SigSelect");
        return NULL;
    }
    
    /* Seed the number generator */
    ajRandomSeed();
    
    /* Create arrays */
    seqmat_normal       =  ajFloatNewL(alg->width);
    seqvar_normal       =  ajFloatNewL(alg->width);
    ncon_normal         =  ajFloatNewL(alg->width);
    ccon_normal         =  ajFloatNewL(alg->width);
    total_score         =  ajFloatNewL(alg->width);
    keyres_pos          =  ajIntNewL(alg->width);    


    post_sim            =  ajIntNewL(alg->width);
    rand_pos            =  ajIntNewL(alg->width);
    keyres_seq          =  ajInt2dNew();    
    seq_len             =  ajIntNewL(alg->N);    
    

    /* Initialise array elements to zero */
    ajFloatPut(&seqmat_normal, alg->width-1, (float) 0.0);

    ajFloatPut(&seqvar_normal, alg->width-1, (float) 0.0);
    ajFloatPut(&ncon_normal, alg->width-1, (float) 0.0);
    ajFloatPut(&ccon_normal, alg->width-1, (float) 0.0);
    ajFloatPut(&total_score, alg->width-1, (float) 0.0);

    ajIntPut(&keyres_pos, alg->width-1, (ajint) 0);
    ajIntPut(&post_sim, alg->width-1, (ajint) 0);
    ajIntPut(&rand_pos, alg->width-1, (ajint) 0);

    nseqs=ajXyzScopalgGetseqs(alg, &seq_array);

    /* Start of main application loop */
    /* Determine min and max values of seqmat_score */
    /* Iterate through (scores)->seqmat_score array */

    if((scores)->seqmat_do == ajTrue)
    {
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Check if value is not zero */
            if(ajFloatGet((scores)->seqmat_score, cnt) != 0)
            {

                /* If in loop for first time assign min and max */

                if(first == 0)
                {
                    seqmat_min = ajFloatGet((scores)->seqmat_score, cnt);
                    seqmat_max = ajFloatGet((scores)->seqmat_score, cnt);
                    first = 1;
                }


                /* Check if value is >, <, = to min/max */
                /* If true assign value to min/max variable */
                if(ajFloatGet((scores)->seqmat_score, cnt) < seqmat_min)
                    seqmat_min = ajFloatGet((scores)->seqmat_score, cnt);
                if(ajFloatGet((scores)->seqmat_score, cnt) == seqmat_min)
                    continue;
                if(ajFloatGet((scores)->seqmat_score, cnt) == seqmat_max)
                    continue;
                if(ajFloatGet((scores)->seqmat_score, cnt) > seqmat_max)
                    seqmat_max = ajFloatGet((scores)->seqmat_score, cnt);
            }
        }
    }

    /* Start of main application loop */
    /* Determine min and max values of seqvar_score */
    /* Iterate through (scores)->seqvar_score array */
    if((scores)->seqvar_do == ajTrue)
    {
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Check if value is not zero */
            if(ajFloatGet((scores)->seqvar_score, cnt) != 0)
            {
                /* If in loop for first time assign min and max */
                if(first == 0)
                {
                    seqvar_min = ajFloatGet((scores)->seqvar_score, cnt);
                    seqvar_max = ajFloatGet((scores)->seqvar_score, cnt);

                    first = 1;
                }



                /* Check if value is >, <, = to min/max */
                /* If true assign value to min/max variable */
                if(ajFloatGet((scores)->seqvar_score, cnt) < seqvar_min)
                    seqvar_min = ajFloatGet((scores)->seqvar_score, cnt);
                if(ajFloatGet((scores)->seqvar_score, cnt) == seqvar_min)
                    continue;
                if(ajFloatGet((scores)->seqvar_score, cnt) == seqvar_max)
                    continue;

                if(ajFloatGet((scores)->seqvar_score, cnt) > seqvar_max)
                    seqvar_max = ajFloatGet((scores)->seqvar_score, cnt);
            }
        }
    }





    /* Perform normalising calculation on seqmat_score array */
    if((scores)->seqmat_do == ajTrue)
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Only perform nornalisation on Post_similar */
            /* positions with value '1' or '0', if filter = ajFalse */
	    /*  if((((scores)->filterpsim) && 
		(ajStrChar(alg->Post_similar, cnt) == '1')) ||
               ((scores)->filterpsim == ajFalse))*/
	    
	    /* if(((ajStrChar(alg->Post_similar, cnt) == '1') && ((scores)->filterpsim == ajTrue)) 
               || (((scores)->filterpsim == ajFalse) && ((ajStrChar(alg->Post_similar, cnt) == '1')
              ||  (ajStrChar(alg->Post_similar, cnt) == '0'))))*/

	    if(((ajStrChar(alg->Post_similar, cnt) == '1') && 
		((scores)->filterpsim == ajTrue) &&
		((scores)->filtercon == ajTrue) && 	
		(ajIntGet((scores)->ncon_thresh, cnt) == 1))
	       ||
	       (((scores)->filterpsim == ajTrue) && 
		(ajStrChar(alg->Post_similar, cnt) == '1') &&
		((scores)->filtercon == ajFalse))
	       ||
	       (((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, cnt) != '-') && 
		((scores)->filtercon == ajTrue) && 
		(ajIntGet((scores)->ncon_thresh, cnt) == 1))
	       ||
	       (((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, cnt) != '-') && 
		((scores)->filtercon == ajFalse)))
            {   
                /* Put normalised score into array at eqiuvalent position */
                ajFloatPut(&seqmat_normal, cnt,((ajFloatGet((scores)->seqmat_score, cnt) 
                                                 - seqmat_min)/(seqmat_max - seqmat_min)));
            }	
            else
                ajFloatPut(&seqmat_normal, cnt, 0);
        }


    /* Perform normalising calculation on seqvar_score array */
    if((scores)->seqvar_do == ajTrue)
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Only perform nornalisation on Post_similar */
            /* positions with value '1'                   */

/*          if((((scores)->filterpsim) && (ajStrChar(alg->Post_similar, cnt) == '1')) ||
               ((scores)->filterpsim == ajFalse))*/
/*        if(((ajStrChar(alg->Post_similar, cnt) == '1') && ((scores)->filterpsim == ajTrue)) || 
           (((scores)->filterpsim == ajFalse) && ((ajStrChar(alg->Post_similar, cnt) == '1')
           ||  (ajStrChar(alg->Post_similar, cnt) == '0'))))*/

	    if(((ajStrChar(alg->Post_similar, cnt) == '1') && 
		((scores)->filterpsim == ajTrue) &&
		((scores)->filtercon == ajTrue) && 
		(ajIntGet((scores)->ncon_thresh, cnt) == 1))
	       ||
	       (((scores)->filterpsim == ajTrue) && 
		(ajStrChar(alg->Post_similar, cnt) == '1') &&
		((scores)->filtercon == ajFalse))
	       ||
	       (((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, cnt) != '-') && 
		((scores)->filtercon == ajTrue) && 
		(ajIntGet((scores)->ncon_thresh, cnt) == 1))
	       ||
	       (((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, cnt) != '-') && 
		((scores)->filtercon == ajFalse)))
            {   
                /* Put normalised score into array at eqiuvalent position */
                ajFloatPut(&seqvar_normal, cnt,((ajFloatGet((scores)->seqvar_score, cnt) 
                                          - seqvar_min)/(seqvar_max - seqvar_min)));

            }

            else

                ajFloatPut(&seqvar_normal, cnt, 0);
        }
    
 


    
    
    /* Add total scores for each position depending on the */
    /* scoring options selected.  Enter value in total_score array */

    for(x=0; x<alg->width; x++)
    {
        val=0.0;
        if((scores)->seqmat_do == ajTrue) 
            val+=ajFloatGet(seqmat_normal, x);

        if((scores)->seqvar_do == ajTrue) 
            val+=ajFloatGet(seqvar_normal, x);


        ajFloatPut(&total_score, x, val);

    }
    
    /* Initialise array elements from 0 to alg->width */
    /* Count number of potential signature positions  */
    /* depending on the scoring methods selected      */
    num_aligned = -1;
    
    for(x=0; x<alg->width; x++)
    {
        /* initialise post_sim array to zero */
        ajIntPut(&post_sim, x, x);
        
	/* New stuff for randomising */
        ajIntPut(&rand_pos, j++, x);
	rand_num++;
	

        if(((scores)->filterpsim == ajTrue) && 
		(ajStrChar(alg->Post_similar, x) == '1') &&
           ((scores)->filtercon == ajFalse))
	    {
		num_aligned++;
		/* New stuff for randomising 
		    ajIntPut(&rand_pos, j++, x); */
	    }
        else if(((scores)->filterpsim == ajFalse) && 
		(ajStrChar(alg->Post_similar, x) != '-') && 
		((scores)->filtercon == ajFalse))
	{
            num_aligned++;
	    /* New stuff for randomising 
	        ajIntPut(&rand_pos, j++, x); */
	}
    }    



    /* Perform bubble sort of total_score array  */ 
    for(i=1; i<=(alg->width-1); i++)
        for(j=0; j<=(alg->width-2); j++)
        { 
            /* Check if element j is > than element j+1 */
            if((ajFloatGet(total_score, j)) > 
               (ajFloatGet(total_score, (j + 1))))
            {
                /* Swap elements j and j+1 via hold/hold_pos variables */
                hold = ajFloatGet(total_score, j);

                hold_pos = ajIntGet(post_sim, j);
                ajFloatPut(&total_score, j, (ajFloatGet(total_score, (j+1))));

                ajIntPut(&post_sim, j, (ajIntGet(post_sim, (j+1))));
                ajFloatPut(&total_score, (j+1), hold);
                ajIntPut(&post_sim, (j+1), hold_pos);
            }           

        }

    /* Determine average number of residues for each sequence from ALIGNMENT  */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
    {
        single_rescount = 0;
        for(i=0; i<alg->width; i++)
            if(ajStrChar(alg->Seqs[memb_cnt], i) != '-')
            {
                single_rescount++;
            }

        ajIntPut(&seq_len, memb_cnt, single_rescount);
    }

    /* ASK MATT ABOUT THIS */
    /* Determinine actual length of each sequence from */
    /* dimensions of cmap, NOT the STAMP alignment     */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
    {
	len = ajIntGet(seq_len, memb_cnt);
	
	res_count += len;
    }
    

    /* Initialise keyres_seq array to zero */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
        for(i=0; i<ajIntGet(seq_len, memb_cnt); i++)
            ajInt2dPut(&keyres_seq, memb_cnt, i, 0);


    
    /* Calculate the number of positions the signature should have */
    /* Determine no. of positions the signature will have */
    /* JC New way of calculating sig_npos */
    sig_npos = (ajint) ceil((double)  ((res_count/alg->N) * 
                                       ( (float)sig_sparse/(float)100)));


    for(i=((alg->width)-1); i>((alg->width)-sig_npos); i--)
    {
        /*ajFmtPrint("i = %d %f %d \n", i, ajFloatGet(total_score, i), ajIntGet(post_sim, i));*/
        if(ajFloatGet(total_score, i) == 0)

            printf("Total_score array = 0.00 at position = %d\n", i);
    }


    /* Do random number generating here and fill post_sim array */
    /* from the end with the random numbers which equate to the */
    /* putative signature positions identified above            */

    /* Assign temp array and initialise */
    temp_rand =  ajIntNewL(num_aligned);
    for(i=0;i<num_aligned;i++)
        ajIntPut(&temp_rand, i, -1);
    
    if(scores->random == ajTrue)
    {    
        while(finish == ajFalse)
        {
            /* Generate random number */
            rn = ajRandomNumberD();


	    /* New stuff for randomising 
	    irn = (int) (rn * (double)num_aligned);*/
	    irn = (int) (rn * (double)rand_num);

            already_done = ajFalse;
            
            /* Check number hasn't already been put into array */
	    /* New stuff for randomising 
            for(i=0;i<num_aligned;i++)  */
            for(i=0;i<rand_num;i++) 
            {
                if(ajIntGet(temp_rand, i) == irn)
                {
                    already_done = ajTrue;
                    break;
                }       
            
                else
                    continue;
            }

            /* If number not already in array, then put it in */
            if(already_done == ajFalse)
                ajIntPut(&temp_rand, rand_cnt++, irn);

            /* Number already in array so continue and choose another */
            else
                continue;

            /* If all array elements filled then finish while loop */
	    /* New stuff for randomising 
            if(rand_cnt == num_aligned)  */
            if(rand_cnt == rand_num) 

            {   
                finish = ajTrue;
                /*printf("rand_cnt = %d num_aligned = %d\n", rand_cnt, num_aligned);*/
            }
        }
    
        /*printf("out!!\n");
        printf("rand_cnt = %d num_aligned = %d\n", rand_cnt, num_aligned);
        
        printf("temp_rand\n");
        for(i=0;i<num_aligned;i++)

            ajFmtPrint("%4d\n", ajIntGet(temp_rand, i));*/
        
        /* Diagnostic to sort temp_rand and check all number are present */
        /*for(i=0;i<num_aligned;i++)
          ajSortIntInc((ajint *) ajIntInt(temp_rand), num_aligned);
          
          printf("sorted temp_rand\n");
          for(i=0;i<num_aligned;i++)
          ajFmtPrint("%4d\n", ajIntGet(temp_rand, i));*/
        
/*      printf("post_sim\n");
        for(i=0;i<alg->width;i++)
            ajFmtPrint("%4d\n", ajIntGet(post_sim, i));*/
        
        
        /* Copy the random numbers to the last 'num_aligned' positions */
        /* of the post_sim array */
        for(i=0;i<num_aligned;i++)
            ajIntPut(&post_sim, ((alg->width) - i), ajIntGet(rand_pos, ajIntGet(temp_rand, i)));
        
/*      printf("new post_sim\n");
        for(i=0;i<alg->width;i++)
            ajFmtPrint("%4d\n", ajIntGet(post_sim, i));*/
    }



    /* Check if the user entered sparsity exceeds */
    /* the number of positions which are aligned  */
    /* in the alignment                           */
    if(num_aligned < sig_npos)
    {
        /* calculate sparsity for number of aligned positions */
        av_temp = (ajint) (res_count/alg->N);
        total_temp = (((float)num_aligned/(float)av_temp) * (float)100);

        /* If so print message */
	/*  DIAGNOSTICS */
        ajFmtPrint("There are not sufficient aligned positions to generate a "
		   "signature of the specified sparsity.\nSignature sparsity = %.2f\n", 
		   total_temp);

	if(total_temp < 1)
	{
	    /* Tidy up */
	    ajFloatDel(&seqmat_normal);
	    ajFloatDel(&seqvar_normal);
	    ajFloatDel(&ncon_normal);
	    ajFloatDel(&ccon_normal);
	    ajFloatDel(&total_score);
	    ajIntDel(&keyres_pos);   
	    ajIntDel(&post_sim);     
	    ajIntDel(&rand_pos);     
	    ajIntDel(&temp_rand);     
	    ajInt2dDel(&keyres_seq);
	    ajIntDel(&seq_len);
	    for(x=0;x<nseqs;x++)
		ajStrDel(&seq_array[x]);
	    AJFREE(seq_array);

	    return NULL;
	}

        spar = total_temp;
        (*spar_check) = (ceil((double)spar));

        /* Generate signature using all of the aligned positions */
        /* scoring '1' */
        /* Begin at end i.e. highest scoring positions */
        /* of post_sim array */
        /* Count down from end until all '1' positions are */
        /* entered in keyres_pos array */
        for(i=alg->width-1; i>=alg->width-(num_aligned); i--)
        {
            /* Put a '1' in keyres_pos array at position */
            /* corresponding to position in post_sim array */
            ajIntPut(&keyres_pos, ajIntGet(post_sim, i), 1);

        }
    }
    
    /* Else output signature of sparsity specified by user */
    else
    {
        /* Begin at end i.e. highest scoring positions */
        /* of post_sim array */
        /* Count down from end until sparsity is fulfilled */
        for(i=alg->width-1; i>=alg->width-(sig_npos); i--)
        {
            /* Put a '1' in keyres_pos array at position */
            /* corresponding to position in post_sim array */
            ajIntPut(&keyres_pos, ajIntGet(post_sim, i), 1);
        }
    }    



/* New stuff for randomising, new first block of code below*/
    /* fill 2d array with positions of each key res w.r.t. alignment seq */
    if(scores->random ==ajTrue)
    {
	for(i=0; i<alg->width; i++)
	{
	    if(ajIntGet(keyres_pos, i) == 1)
	    {
		randpos_cnt++;
		
		for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)            
		{
		    /*Check to see if alignment position is a gap*/
		    if((idx=ajInt2dGet(seq_pos, memb_cnt, i))==-1)
			continue;
		    else
			ajInt2dPut(&keyres_seq, randpos_cnt, idx, 1); 
		}
	    }
	}
    }
    else
    {
    	/* fill 2d array with positions of each key res w.r.t. alignment seq */
	for(i=0; i<alg->width; i++)
	{
	    if(ajIntGet(keyres_pos, i) == 1)
	    {
		for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)            
		{
		    /*Check to see if alignment position is a gap*/
		    if((idx=ajInt2dGet(seq_pos, memb_cnt, i))==-1)
			continue;
		    else
			ajInt2dPut(&keyres_seq, memb_cnt, idx, 1); 
		}
	    }
	}
    }

    rand_total=randpos_cnt;
    

    /* Allocate signature structure and write SCOP classification records*/
    /* If not enough aligned positions then make structure size num_aligned */
    if(num_aligned < sig_npos)
            sig =  ajXyzSignatureNew(num_aligned);
    else
        sig =  ajXyzSignatureNew(sig_npos);

    ajStrAss(&sig->Class, alg->Class);
    ajStrAss(&sig->Fold, alg->Fold);
    ajStrAss(&sig->Superfamily, alg->Superfamily);
    ajStrAss(&sig->Family, alg->Family);
    sig->Sunid_Family =  alg->Sunid_Family;

    /* Allocate sigdat structures, don't know the number of 
       residue or gaps in advance, these are set below, but
       set the window size here */
    /* Tue Oct  1 08:13:45 BST 2002 */
    for(x=0; x<sig->npos; x++)
    {
	sig->dat[x]=ajXyzSigdatNew(0, 0);
	sig->dat[x]->wsiz=wsiz;
    }
    

    /* Write signature structure */
    /* New stuff for randomising, both for loops duplicated */
    if(scores->random==ajTrue)
    {
    
	/* Write signature structure */
	for(j=0; j<alg->N; j++)
	{				/* seq_len changed to fullseq_len */
	    randpos_cnt = 1;
	    for(npos=0, gsiz=0, i=0, imax=ajIntGet(seq_len, j); 
		i<imax; 
		i++)       
	    {

		/* The position is a signature position */
		if(ajInt2dGet(keyres_seq, j, i) == randpos_cnt)
		{
		    /*Process gap */
		    for(done=ajFalse,x=0;x<sig->dat[randpos_cnt-1]->ngap;x++)
		    {
			/*The gap length is NOT new*/
			if((ajIntGet(sig->dat[randpos_cnt-1]->gsiz, x)==gsiz))
			{
			    ajIntInc(&sig->dat[randpos_cnt-1]->gfrq, x);
			    /*printf("npos = %4d, memb_cnt = %4d, gsiz = %4d gfrq = %4d\n", npos, j, gsiz, 
			      ajIntGet(sig->dat[npos]->gfrq, x));*/
			    done=ajTrue;
			    break;

			}   
		    }

                

		    /*The gap length is new*/
		    if(!done)
		    {
			sig->dat[randpos_cnt-1]->ngap++;
			ajIntPut(&sig->dat[randpos_cnt-1]->gsiz, 
				 sig->dat[randpos_cnt-1]->ngap-1, 
				 gsiz);
			ajIntPut(&sig->dat[randpos_cnt-1]->gfrq, 
				 sig->dat[randpos_cnt-1]->ngap-1, 
				 (ajint) 1);
			/*printf("npos = %4d, memb_cnt = %4d, gsiz = %4d gfrq = %4d\n", npos, j, gsiz, 
			  ajIntGet(sig->dat[npos]->gfrq, x));*/
		    }    


		    /* Set variables*/
		    gsiz=0;
		    npos++;
		    randpos_cnt++;
		}



		else if(ajInt2dGet(keyres_seq, j, i) > randpos_cnt)
		{
		    rand_total = ajInt2dGet(keyres_seq, j, i);
		    

		    for(p=1;p<100;p++)
		    {
			printf("randpos_cnt = %d p = %d\n", randpos_cnt, p);
			
			if((randpos_cnt + p) == rand_total)
			{	
			    new_gsiz = (int)(gsiz/(p+1));
			    printf("old_ gsiz = %d new_gsiz = %d\n", 
				   gsiz, new_gsiz);
			    break;
			}
		    }
		    

		    /*Process gap */
		    for(done=ajFalse,x=0;x<sig->dat[rand_total-1]->ngap;x++)
		    {
			/*The gap length is NOT new*/
			if((ajIntGet(sig->dat[rand_total-1]->gsiz, x)==new_gsiz))
			{
			    ajIntInc(&sig->dat[rand_total-1]->gfrq, x);
			    /*printf("npos = %4d, memb_cnt = %4d, gsiz = %4d gfrq = %4d\n", npos, j, gsiz, 
			      ajIntGet(sig->dat[npos]->gfrq, x));*/
			    done=ajTrue;
			    break;

			}   
		    }

                

		    /*The gap length is new*/
		    if(!done)
		    {
			sig->dat[rand_total-1]->ngap++;
			ajIntPut(&sig->dat[rand_total-1]->gsiz, 
				 sig->dat[rand_total-1]->ngap-1, 
				 new_gsiz);
			ajIntPut(&sig->dat[rand_total-1]->gfrq, 
				 sig->dat[rand_total-1]->ngap-1, 
				 (ajint) 1);
			/*printf("npos = %4d, memb_cnt = %4d, gsiz = %4d gfrq = %4d\n", npos, j, gsiz, 
			  ajIntGet(sig->dat[npos]->gfrq, x));*/
		    }    


		    /* Set variables*/
		    gsiz=0;
		    npos++;
		    randpos_cnt = ajInt2dGet(keyres_seq, j, i);
		    randpos_cnt++;
		}


		else
		{
		    gsiz++;
		}
	    }
	}




	/* Write residue id into signature structure */
	for(j=0; j<alg->N; j++)
	{
	    randpos_cnt = 1;
	    
	    /* seq_len changed to fullseq_len */
	    for(npos=0, i=0, imax=ajIntGet(seq_len, j); 
		i<imax; 
		i++)       
	    {
		/* The position is a signature position */
		if(ajInt2dGet(keyres_seq, j, i) == randpos_cnt)
		{
		    /*Process residue*/
		    for(done=ajFalse,x=0;x<sig->dat[randpos_cnt-1]->nres;x++)
			/*The residue id is NOT new*/
		    {
			if((ajChararrGet(sig->dat[randpos_cnt-1]->rids, x))
			   ==ajStrChar(seq_array[j], i))
			{
			    ajIntInc(&sig->dat[randpos_cnt-1]->rfrq, x);
			    done=ajTrue;
			    break;
			}
		    }


		    /*The residue id is new*/
		    if(!done)
		    {
			sig->dat[randpos_cnt-1]->nres++;
			ajChararrPut(&sig->dat[randpos_cnt-1]->rids, 
				     sig->dat[randpos_cnt-1]->nres-1, 	
				     ajStrChar(seq_array[j], i));

			ajIntPut(&sig->dat[randpos_cnt-1]->rfrq, sig->dat[randpos_cnt-1]->nres-1, 
				 (ajint) 1);
		    }    
                

		    /* Set variables*/
		    npos++;
		    randpos_cnt++;
		}

		else if(ajInt2dGet(keyres_seq, j, i) > randpos_cnt)
		{
		    rand_total = ajInt2dGet(keyres_seq, j, i);
		    /*Process residue*/
		    for(done=ajFalse,x=0;x<sig->dat[rand_total-1]->nres;x++)
			/*The residue id is NOT new*/
		    {
			if((ajChararrGet(sig->dat[rand_total-1]->rids, x))
			   ==ajStrChar(seq_array[j], i))
			{
			    ajIntInc(&sig->dat[rand_total-1]->rfrq, x);
			    done=ajTrue;
			    break;
			}
		    }


		    /*The residue id is new*/
		    if(!done)
		    {
			sig->dat[rand_total-1]->nres++;
			ajChararrPut(&sig->dat[rand_total-1]->rids, 
				     sig->dat[rand_total-1]->nres-1, 	
				     ajStrChar(seq_array[j], i));

			ajIntPut(&sig->dat[rand_total-1]->rfrq, sig->dat[rand_total-1]->nres-1, 
				 (ajint) 1);
		    }    
                

		    /* Set variables*/
		    npos++;
		    randpos_cnt = ajInt2dGet(keyres_seq, j, i);
		    randpos_cnt++;
		}

		else
		{
		    continue;
		}
	    }
	}
    }
    else
    {
	/* Write signature structure */
	for(j=0; j<alg->N; j++)
	{				
	    for(npos=0, gsiz=0, i=0, imax=ajIntGet(seq_len, j); 
		i<imax; 
		i++)       
	    {

		/* The position is a signature position */
		if(ajInt2dGet(keyres_seq, j, i) == 1)
		{
		    /*Process gap */
		    for(done=ajFalse,x=0;x<sig->dat[npos]->ngap;x++)
		    {
			/*The gap length is NOT new*/
			if((ajIntGet(sig->dat[npos]->gsiz, x)==gsiz))
			{
			    ajIntInc(&sig->dat[npos]->gfrq, x);
			    done=ajTrue;
			    break;

			}   
		    }

                

		    /*The gap length is new*/
		    if(!done)
		    {
			sig->dat[npos]->ngap++;
			ajIntPut(&sig->dat[npos]->gsiz, sig->dat[npos]->ngap-1, 
				 gsiz);
			ajIntPut(&sig->dat[npos]->gfrq, sig->dat[npos]->ngap-1, 
				 (ajint) 1);
		    }    


		    /* Set variables*/
		    gsiz=0;
		    npos++;
		}
		else
		{
		    gsiz++;
		}
	    }

	}



	/* Write residue id into signature structure */
	for(j=0; j<alg->N; j++)
	{
	    /* seq_len changed to fullseq_len */
	    for(npos=0, i=0, imax=ajIntGet(seq_len, j); 
		i<imax; 
		i++)       
	    {
		/* The position is a signature position */
		if(ajInt2dGet(keyres_seq, j, i) == 1)
		{
		    /*Process residue*/
		    for(done=ajFalse,x=0;x<sig->dat[npos]->nres;x++)
			/*The residue id is NOT new*/
		    {
			if((ajChararrGet(sig->dat[npos]->rids, x))
			   ==ajStrChar(seq_array[j], i))
			{
			    ajIntInc(&sig->dat[npos]->rfrq, x);
			    done=ajTrue;
			    break;
			}
		    }


		    /*The residue id is new*/
		    if(!done)
		    {
			sig->dat[npos]->nres++;
			ajChararrPut(&sig->dat[npos]->rids, sig->dat[npos]->nres-1,         
				     ajStrChar(seq_array[j], i));

			ajIntPut(&sig->dat[npos]->rfrq, sig->dat[npos]->nres-1, 
				 (ajint) 1);
		    }    
                

		    /* Set variables*/
		    npos++;
		}
		else
		{
		    continue;
		}
	    }
	}

    }   




    

  
    /* Perform bubble sort of gap sizes and frequencies array  */ 
    for(x=0; x<sig->npos;x++) 
    { 
        for(cnt=1; cnt<(sig->dat[x]->ngap);cnt++)
            for(i=0; i<(sig->dat[x]->ngap-1);i++)
            {    
                /* Check if element i is > than element i+1 */
                if(ajIntGet(sig->dat[x]->gsiz, i) > ajIntGet(sig->dat[x]->gsiz, i+1))
                {       
                    /* Swap elements i and i+1 via y/hold_pos variables */
                    j        = ajIntGet(sig->dat[x]->gsiz, i);
                    hold_pos = ajIntGet(sig->dat[x]->gfrq, i);

                    ajIntPut(&sig->dat[x]->gsiz, i, ajIntGet(sig->dat[x]->gsiz, i+1));
                    ajIntPut(&sig->dat[x]->gfrq, i, ajIntGet(sig->dat[x]->gfrq, i+1));
                
                    ajIntPut(&sig->dat[x]->gsiz, i+1, j);
                    ajIntPut(&sig->dat[x]->gfrq, i+1, hold_pos);
                }               
            }
    }
    


      
    /* Reorder the gap data so it is in order of increasing sized gap*/
/* Stuff for printing out in old signature format*/
    
/*    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
    {
        printf(">>>TEST_%d\n", memb_cnt); 
        num = 0;
        printf("SEQU      "); 

        for(i=0; i<alg->width; i++)

        {
            if((ajStrChar(alg->Seqs[memb_cnt], i) != '-'))

            {
                ajFmtPrint("%c", ajStrChar(alg->Seqs[memb_cnt], i)); 

                num++;
                ajStrAppK(&seq_array[memb_cnt], 

                ajStrChar(alg->Seqs[memb_cnt], i)); 

            }
        }

        printf("\n");
        printf("KEY       "); 
        for(i=0; i<ajIntGet(seq_len, memb_cnt); i++)       
        {
            if(ajInt2dGet(keyres_seq, memb_cnt, i) == 1)
                printf("V");
            else
                printf(" ");
        }
        printf("\n");
        printf("SSA4      \n");
        printf("SSA4      \n");
        printf("KEY       ");
        for(i=0; i<ajIntGet(seq_len, memb_cnt); i++)       
        {
            if(ajInt2dGet(keyres_seq, memb_cnt, i) == 1)
                printf("V");
            else
                printf(" ");

        }
        printf("\n");
        printf("SEQU      ");
        for(i=0; i<alg->width; i++)
        {
            if((ajStrChar(alg->Seqs[memb_cnt], i) != '-'))
            {
                ajFmtPrint("%c", ajStrChar(alg->Seqs[memb_cnt], i));
                num++;
                ajStrAppK(&seq_array[memb_cnt], 
                ajStrChar(alg->Seqs[memb_cnt], i));
            }
        }
        printf("\n");
        }
*/
        



    /* Tidy up */
    ajFloatDel(&seqmat_normal);
    ajFloatDel(&seqvar_normal);
    ajFloatDel(&ncon_normal);
    ajFloatDel(&ccon_normal);
    ajFloatDel(&total_score);
    ajIntDel(&keyres_pos);   
    ajIntDel(&post_sim);     
    ajIntDel(&rand_pos);     
    ajIntDel(&temp_rand);     
    ajInt2dDel(&keyres_seq);
    ajIntDel(&seq_len);
    for(x=0;x<nseqs;x++)
        ajStrDel(&seq_array[x]);
    AJFREE(seq_array);
    /* Return */
    return sig;
}



/* @funcstatic siggen_SigSelectManual **************************************
 **
 ** Convenience routine - calls several functions to score an alignment.
 **
 ** @param [r] alg        [AjPScopalg ]   Alignment
 ** @param [w] scores     [AjPScorealg*]  Scores for alignment
 ** @param [r] seq_pos    [AjPInt2d]      Index for alignment
 ** @param [w] spar_check [float *]       Sparsity of signature
 ** @param [r] wsiz       [ajint]         Window size 
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
static AjPSignature siggen_SigSelectManual(AjPScopalg alg, AjPScorealg *scores, 
				     AjPInt2d seq_pos, float *spar_check,
				     ajint wsiz)
{ 
 ajint       nseqs=0;                /*Number of sequences*/
    ajint       idx              =0;    /*Index*/
    ajint       cnt              =0;    /* Counter for post_similar line */
    ajint       x                =0;    /* Counter */
    ajint       memb_cnt         =0;    /* Counter */
    ajint       j                =0;    /* Counter */
    ajint       i                =0;    /* Counter */
    ajint       imax             =0;    /* Loop exit condition */
    ajint       hold_pos         =0;    /* Counter to hold values whilst sorting */

    ajint       single_rescount  =0;
    ajint       gsiz             =0;    /* Temp. size of gap*/
    ajint       npos             =0;    /* Counter of signature positions*/
    ajint       sig_npos         =0;    /* Number of positions in signature */
    float       val              =0.0;  /*Temp. val*/
    AjBool      done             =ajFalse;  /*Flag*/
    AjPFloat    total_score      =NULL; /* Array of floats for total normalised scores */
    AjPInt      keyres_pos       =NULL; /* Total_score array, sorted in ascending order */
    AjPInt      post_sim         =NULL; /* Array for positions in post_similar line */
    AjPInt      seq_len          =NULL; /* Array of length of each seq, as in alignment  */
    AjPInt      fullseq_len      =NULL; /* Array of length of each seq, as in original seq  */
    AjPInt2d    keyres_seq       =NULL; /* Total_score array, sorted in ascending order */
    AjPStr      *seq_array       =NULL; /* Arrays of sequence (w/o gaps) from alignment */
    AjPSignature sig=NULL;              /* Signature */

    




    /*Check args */
    if( !(*scores) || !alg || !seq_pos)
    {
        printf("Bad args passed to siggen_SigSelectManual\n");
        return NULL;
    }


    
    /* Create arrays */
    total_score         =  ajFloatNewL(alg->width);
    keyres_pos          =  ajIntNewL(alg->width);    


    post_sim            =  ajIntNewL(alg->width);
    keyres_seq          =  ajInt2dNew();    
    seq_len             =  ajIntNewL(alg->N);    
    fullseq_len         =  ajIntNewL(alg->N);    
    

    /* Initialise array elements to zero */
    ajFloatPut(&total_score, alg->width-1, (float) 0.0);

    ajIntPut(&keyres_pos, alg->width-1, (ajint) 0);
    ajIntPut(&post_sim, alg->width-1, (ajint) 0);

    nseqs=ajXyzScopalgGetseqs(alg, &seq_array);

    /* Start of main application loop */
    /* Determine min and max values of seqmat_score */
    /* Iterate through (scores)->seqmat_score array */

    
    /* Add total scores for each position depending on the */
    /* scoring options selected.  Enter value in total_score array */

    for(x=0; x<alg->width; x++)
    {
        val=0.0;
        ajFloatPut(&total_score, x, val);
    }
    


    /* Perform bubble sort of total_score array  */ 
 for(i=0; i<alg->width; i++)
     /* Check manual position line is 1 */	
     if(ajStrChar(alg->Positions, i)=='1')
     {
	 ajIntPut(&post_sim, alg->width-i, i);
     }           


    /* Determine average number of residues for each sequence from ALIGNMENT  */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
    {
        single_rescount = 0;
        for(i=0; i<alg->width; i++)
            if(ajStrChar(alg->Seqs[memb_cnt], i) != '-')
            {
                single_rescount++;
            }

        ajIntPut(&seq_len, memb_cnt, single_rescount);
    }


    /* Initialise keyres_seq array to zero */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
        for(i=0; i<ajIntGet(seq_len, memb_cnt); i++)
            ajInt2dPut(&keyres_seq, memb_cnt, i, 0);

    
    /* Calculate the number of positions the signature has */
 for(sig_npos=0,i=0; i<alg->width; i++)
     /* Check manual position line is 1 */	
     if(ajStrChar(alg->Positions, i)=='1')
     {
	 sig_npos++;
     }
 
    for(i=((alg->width)-1); i>((alg->width)-sig_npos); i--)
    {
        /*ajFmtPrint("i = %d %f %d \n", i, ajFloatGet(total_score, i), ajIntGet(post_sim, i));*/
        if(ajFloatGet(total_score, i) == 0)

            printf("Total_score array = 0.00 at position = %d\n", i);
    }



 /* output signature of sparsity specified by user */
 
 /* Begin at end i.e. highest scoring positions */
 /* of post_sim array */
 /* Count down from end until sparsity is fulfilled */
 for(i=alg->width-1; i>=alg->width-(sig_npos); i--)
 {
     /* Put a '1' in keyres_pos array at position */
     /* corresponding to position in post_sim array */
     ajIntPut(&keyres_pos, ajIntGet(post_sim, i), 1);
 }
     

    /* fill 2d array with positions of each key res w.r.t. alignment seq */
    for(i=0; i<alg->width; i++)
    {
        if(ajIntGet(keyres_pos, i) == 1)
        {
            for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)            
            {
                /*Check to see if alignment position is a gap*/
                if((idx=ajInt2dGet(seq_pos, memb_cnt, i))==-1)
                    continue;
                else
                    ajInt2dPut(&keyres_seq, memb_cnt, idx, 1); 
            }
        }
    }




    /* Allocate signature structure and write SCOP classification records*/
    /* If not enough aligned positions then make structure size num_aligned */
 sig =  ajXyzSignatureNew(sig_npos);

    ajStrAss(&sig->Class, alg->Class);
    ajStrAss(&sig->Fold, alg->Fold);
    ajStrAss(&sig->Superfamily, alg->Superfamily);
    ajStrAss(&sig->Family, alg->Family);
    sig->Sunid_Family =  alg->Sunid_Family;

    /* Allocate sigdat structures, don't know the number of 
       residue or gaps in advance, these are set below, but
       set the window size here */
    /* Tue Oct  1 08:13:45 BST 2002 */
    for(x=0; x<sig->npos; x++)
    {
	sig->dat[x]=ajXyzSigdatNew(0, 0);
	sig->dat[x]->wsiz=wsiz;
    }
    


    /* Write signature structure */
    for(j=0; j<alg->N; j++)
    {   /* seq_len changed to fullseq_len */
        for(npos=0, gsiz=0, i=0, imax=ajIntGet(fullseq_len, j); 
            i<imax; 
            i++)       
        {

            /* The position is a signature position */
            if(ajInt2dGet(keyres_seq, j, i) == 1)
            {
                /*Process gap */
                for(done=ajFalse,x=0;x<sig->dat[npos]->ngap;x++)
                {
                    /*The gap length is NOT new*/
                    if((ajIntGet(sig->dat[npos]->gsiz, x)==gsiz))
                    {
                        ajIntInc(&sig->dat[npos]->gfrq, x);
                        /* DIAGNOSTICS
			   printf("npos = %4d, memb_cnt = %4d, gsiz = %4d gfrq = %4d\n", npos, j, gsiz, 
                               ajIntGet(sig->dat[npos]->gfrq, x));*/
                        done=ajTrue;
                        break;

                    }   
                }

                

                /*The gap length is new*/
                if(!done)
                {
                    sig->dat[npos]->ngap++;
                    ajIntPut(&sig->dat[npos]->gsiz, sig->dat[npos]->ngap-1, 
                             gsiz);
                    ajIntPut(&sig->dat[npos]->gfrq, sig->dat[npos]->ngap-1, 
                             (ajint) 1);
		    /* DIAGNOSTICS 
		       printf("npos = %4d, memb_cnt = %4d, gsiz = %4d gfrq = %4d\n", npos, j, gsiz, 
		       ajIntGet(sig->dat[npos]->gfrq, x));*/
                }    



                /*Process residue*/
               /* for(done=ajFalse,x=0;x<sig->dat[npos]->nres;x++)*/
                    /*The residue id is NOT new*/
                /*{*/
                   /* if((ajChararrGet(sig->dat[npos]->rids, x))
                       ==ajStrChar(seq_array[j], i))
                    {
                        ajIntInc(&sig->dat[npos]->rfrq, x);
                        done=ajTrue;
                        break;
                    }
                }*/


                /*The residue id is new*/
               /* if(!done)
                {
                    sig->dat[npos]->nres++;
                    ajChararrPut(&sig->dat[npos]->rids, sig->dat[npos]->nres-1, 

                                 ajStrChar(seq_array[j], i));

                    ajIntPut(&sig->dat[npos]->rfrq, sig->dat[npos]->nres-1, 
                             (ajint) 1);
                }*/    
                

                /* Set variables*/
                gsiz=0;
                npos++;
            }
            else
            {
                gsiz++;
            }
        }

    }





    /* Write residue id into signature structure */
    for(j=0; j<alg->N; j++)
    {
        /* seq_len changed to fullseq_len */
        for(npos=0, i=0, imax=ajIntGet(seq_len, j); 
            i<imax; 
            i++)       
        {
            /* The position is a signature position */
            if(ajInt2dGet(keyres_seq, j, i) == 1)
            {
                /*Process residue*/
                for(done=ajFalse,x=0;x<sig->dat[npos]->nres;x++)
                    /*The residue id is NOT new*/
                {
                    if((ajChararrGet(sig->dat[npos]->rids, x))
                       ==ajStrChar(seq_array[j], i))
                    {
                        ajIntInc(&sig->dat[npos]->rfrq, x);
                        done=ajTrue;
                        break;
                    }
                }


                /*The residue id is new*/
                if(!done)
                {
                    sig->dat[npos]->nres++;
                    ajChararrPut(&sig->dat[npos]->rids, sig->dat[npos]->nres-1,         
                                 ajStrChar(seq_array[j], i));

                    ajIntPut(&sig->dat[npos]->rfrq, sig->dat[npos]->nres-1, 
                            (ajint) 1);
                }    
                

                /* Set variables*/
                npos++;
            }
            else
            {
                continue;
            }
        }
    }
    
    


  
    /* Perform bubble sort of gap sizes and frequencies array  */ 
    for(x=0; x<sig->npos;x++) 
    { 
        for(cnt=1; cnt<(sig->dat[x]->ngap);cnt++)
            for(i=0; i<(sig->dat[x]->ngap-1);i++)
            {    
                /* Check if element i is > than element i+1 */
                if(ajIntGet(sig->dat[x]->gsiz, i) > ajIntGet(sig->dat[x]->gsiz, i+1))
                {       
                    /* Swap elements i and i+1 via y/hold_pos variables */
                    j        = ajIntGet(sig->dat[x]->gsiz, i);
                    hold_pos = ajIntGet(sig->dat[x]->gfrq, i);

                    ajIntPut(&sig->dat[x]->gsiz, i, ajIntGet(sig->dat[x]->gsiz, i+1));
                    ajIntPut(&sig->dat[x]->gfrq, i, ajIntGet(sig->dat[x]->gfrq, i+1));
                
                    ajIntPut(&sig->dat[x]->gsiz, i+1, j);
                    ajIntPut(&sig->dat[x]->gfrq, i+1, hold_pos);
                }               
            }         
    }
    


      

    /* Tidy up */
    ajFloatDel(&total_score);
    ajIntDel(&keyres_pos);   
    ajIntDel(&post_sim);     
    ajInt2dDel(&keyres_seq);
    ajIntDel(&seq_len);
    for(x=0;x<nseqs;x++)
        ajStrDel(&seq_array[x]);
    AJFREE(seq_array);

     /* Return */
    return sig;

  

}





/* @funcstatic  siggen_ScoreAlignmentSeq **************************************
 **
 ** Convenience routine - calls several functions to score an alignment.
 **
 ** @param [r] alg     [AjPScopalg ]    Alignment
 ** @param [w] scores  [AjPScorealg*]   Scores for alignment
 ** @param [r] mat     [AjPMatrixf]     Subsitution matrix
 ** @param [r] seq_pos [AjPInt2d]       Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
static AjBool siggen_ScoreAlignmentSeq(AjPScorealg *scores, AjPScopalg alg, 
				       AjPMatrixf  mat, AjPInt2d seq_pos)
{
    /*Check args */
    if( !(*scores) || !alg || !mat || !seq_pos)
    {
        printf("Bad args passed to siggen_ScoreAlignment\n");
        return ajFalse;
    }
    
    

    /* Call scoring functions as appropriate */
    if((*scores)->seqmat_do)
    {
        siggen_ScoreSeqMat(alg, scores, mat, seq_pos);
    }
    

    if((*scores)->seqvar_do)      
        siggen_ScoreSeqVar(alg, scores, seq_pos);
    


    /* siggen_ScoreCombined(scores);*/
    

    return ajTrue;
}


