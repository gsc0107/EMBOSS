/* @source scopalign application
**
** Generate alignments for families in a scop classification file by using STAMP.
**
** @author: Copyright (C) Ranjeeva Ranasinghe (rranasin@hgmp.mrc.ac.uk)
** @author: Copyright (C) Jon Ison (jison@hgmp.mrc.ac.uk)
** @@
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
**

*******************************************************************************
**  Application name
**  scopalign
**  
** 
**  
**  Summary
**  Generate alignments for families in a scop classification file by using STAMP.
** 
**   
**  
**  Input and Output
**  scopalign reads a scop classification file and generates a structural 
**  alignment for each scop family in turn.  The alignments are calculated by 
**  using stamp and this application must be installed on the system that is 
**  running scopalign (see 'Notes' below).  A file containing a structure-based
**  sequence alignment annotated with scop classification data (scop family 
**  alignment) and a file in pdb format of the structural superimposition
**  is generated for each family.  scopalign requires a directory of domain 
**  coordinate files in pdb format; the path and extension of these files must 
**  be specified by the user in the stamp "pdb.directories" file (see 'Notes' 
**  below).  The scop Sunid (an integer) of a family will be used as the base 
**  name for its output file. The input file and paths and extensions for the 
**  two types of alignment (output) files are provided by the user. 
**  
**
**
**  Sister applications
**  A 'scop classification file' contains classification and other data for 
**  domains from the scop database.  The file is in embl-like format and is 
**  generated by scopparse.  Domain sequence information can be added to the 
**  file by using scopseqs.
**  A 'domain coordinate file' contains coordinate and other data for a single
**  scop domain.  The files are generated by domainer and are in embl-like and
**  pdb formats.
**  scopalign will produce better alignments if the scop classification file 
**  is reordered so that the representative structure of each family is given
**  first (see 'Notes' below for an explanation why).  This is achieved by 
**  using scoprep.
**  scop family alignments are used by hmmgen, profgen, siggen, seqsearch, 
**  seqnr, seqalign, modelscan and sigplot.  A scop family alignment can be 
**  extended with sequence relatives (of unknown structure) to the family in 
**  question by using seqalign.
**  
**  
**  
**  Notes
**  1. Handling of singlet families
**  For those families that contain a single domain only, a structure-based 
**  sequence alignment file will still be generated, but will not contain an
**  alignment: 
**  CL   Designed proteins
**  XX
**  FO   Hairpin peptide
**  XX
**  SF   Hairpin peptide
**  XX
**  FA   Hairpin peptide
**  XX
**  SI   64705
**  XX
**
**  2. Adaption of STAMP for domain codes
**  scopalign will only run with with a version of stamp which has been modified
**  so that pdb id codes of length greater than 4 characters are acceptable.
**  This involves a trivial change to the stamp module getdomain.c (around line
**  number 155), a 4 must be changed to a 7 as follows:
**  temp=getfile(domain[0].id,dirfile,4,OUTPUT); 
**  temp=getfile(domain[0].id,dirfile,7,OUTPUT); 
**  
**  3. Adaption of STAMP for larger datasets
**  STAMP was failing to align a large dataset of all the available V set Ig 
**  domains. The ver2hor module generated the following error:
**  Transforming coordinates...
**   ...done.
**  ver2hor -f ./scopalign-1022069396.11280.76.post > ./scopalign-1022069396.11280.out
**  error: something wrong with STAMP file
**           STAMP length is 370, Alignment length is 422
**           STAMP nseq is 155, Alignment nseq is 155
** 
**  This was fixed by changing #define MAXtlen 200 to #define MAXtlen 2000 in 
**  alignfit.h.
**  
**  At the same time I changed the following as a safety measure:
**  gstamp.c  : #define MAX_SEQ_LEN 10000    (was 2000)
**  pdbseq.c  : #define MAX_SEQ_LEN 10000    (was 3000)
**  defaults.h: #define MAX_SEQ_LEN 10000    (was 8000)
**  defaults.h: #define MAX_NSEQ 10000       (was 1000)
**  defaults.h: #define MAX_BLOC_SEQ 5000    (was 500)
**  dstamp.h  : #define MAX_N_SEQ 10000      (was 1000)
**  ver2hor.h : #define MAX_N_SEQ 10000      (was 1000)
** 
** 
**  The modified code is kept on the HGMP file system in /packages/stamp/src2
**  WHEN RUNNING SCOPALIGN AT THE HGMP IT IS ESSENTIAL THAT THE COMMAND 
**  'use stamp2' (which runs the script /packages/menu/USE/stamp2) IS GIVEN 
**  BEFORE SCOPALIGN IS RUN.  This will ensure that the modified version of 
**  stamp is used.
**  
**  stamp searches for pdb files with a certain prefix, extension and path as 
**  specified in the stamp "pdb.directories" file.  For the HGMP, this file is
**  /packages/stamp/defs/pdb.directories and should look like :
** 
**  /data/pdb - -
**  /data/pdb _ .ent
**  /data/pdb _ .pdb
**  /data/pdb pdb .ent
**  /data/pdbscop _ _
**  /data/pdbscop _ .ent
**  /data/pdbscop _ .pdb
**  /data/pdbscop pdb .ent
**  ./ _ _
**  ./ _ .ent
**  ./ _ .ent.z
**  ./ _ .ent.gz
**  ./ _ .pdb
**  ./ _ .pdb.Z
**  ./ _ .pdb.gz
**  ./ pdb .ent
**  ./ pdb .ent.Z
**  ./ pdb .ent.gz
**  /data/CASS1/pdb/coords/ _ .pdb
**  /data/CASS1/pdb/coords/ _ .pdb.Z
**  /data/CASS1/pdb/coords/ _ .pdb.gz
**  
**  Code is available but commented out to make the the names of the output 
**  files to be identical to the names of the families given in the SCOP 
**  classification records, except that if a file of a certain name already 
**  exists, then an "_1", "_2" etc will be added as appropriate.
**
**  
**  
**  Known bugs & warnings
**  stamp will ignore (omit from the alignment and *not* replace with '-' or 
**  any other symbol) ANY residues or groups in a pdb file that
**  (i) are not structured (i.e. do not appear in the ATOM records) or
**  (ii) lack a CA atom, regardless of whether it is a known amino acid or
**  not.
** 
**  This means that the position (column) in the alignment cannot reliably be 
**  used as the basis for an index into arrays representing the full length 
**  sequences.
**
**  stamp will however include in the alignment residues with a single atom
**  only, so long as it is the CA atom.
**  
**  
**  
**  Description
**  This program is part of a suite of EMBOSS applications that directly or 
**  indirectly make use of the protein structure databases pdb and scop.  
**  This program is part of an experimental analysis pipeline described in an
**  accompanying document.  We provide the software in the hope that it will
**  be useful.  The applications were designed for specific research purposes
**  and may not be useful or reliable in contexts other than the described 
**  pipeline.  The development of the suite was coordinated by Jon Ison to
**  whom enquiries and bug reports should be sent (email jison@hgmp.mrc.ac.uk).
**  
**  The generation of structural alignments for large datasets such as scop 
**  potentially requires a lot of time for preparation of datasets, running 
**  jobs and so on, in addition to the compute time required for the 
**  alignments themselves.  scopalign reads a scop classification file and 
**  generates a structural alignment for each scop family in turn by using
**  the structural alignment program stamp.
**  
**  
**  
**  Algorithm
**  More information on stamp can be found at
**  http://www.compbio.dundee.ac.uk/manuals/stamp.4.2/
**  
**  
**  
**  Usage 
**  Unix % scopalign
**  An example of interactive use of scopalign is shown below. Most of the 
**  output is from stamp.
**  
**  Generate alignments for families in a scop classification file by using
**  STAMP
**  Name of scop classification file (embl format input): /test_data/all.scop2
**  Location of scop structure-based sequence alignment files (output) [./]: /test_data/
**  Extension of scop structure-based sequence alignment files (output) [.salign]: 
**  Location of scop structure alignment files (output) [./]: /test_data/
**  The format of the scop classification file is described in scopparse.c
**  Extension of scop structure alignment files (output) [.palign]: 
**  
**  STAMP Structural Alignment of Multiple Proteins
**   by Robert B. Russell & Geoffrey J. Barton 
**   Please cite PROTEINS, v14, 309-323, 1992
**  
**  Results of scan will be written to file ./scopalign-1031311354.32710.scan
**  Fits  = no. of fits performed, Sc = STAMP score, RMS = RMS deviation
**  Align = alignment length, Nfit = residues fitted, Eq. = equivalent residues
**  Secs  = no. equiv. secondary structures, %I = seq. identity, %S = sec. str. identity
**  P(m)  = P value (p=1/10) calculated after Murzin (1993), JMB, 230, 689-694
**  
**       Domain1         Domain2          Fits  Sc      RMS   Len1 Len2 Align Fit   Eq. Secs    %I    %S     P(m)
**  Scan d1cs4a_         d1cs4a_            1   9.799   0.001  189  189  189  189  188    0 100.00 100.00 0.00e+00
**  Scan d1cs4a_         d1fx2a_            1   6.522   1.343  189  235  225  135  133    0  20.30 100.00 0.00017
**  See the file ./scopalign-1031311354.32710.scan
**  TRANSFORM R.B. Russell, 1995
**   Using PDB files
**   Files will not include heteroatoms
**   Files will not include DNA/RNA 
**   Files will not include waters
**   All coordinates will be in file /test_data/55074.palign
**   Domain   1, d1cs4a_ => to /test_data/55074.palign (chain A)
**   Domain   2, d1fx2a__1 => to /test_data/55074.palign (chain B)
**  stamp -l ./scopalign-1031311354.32710.dom -s -n 2 -slide 5 -prefix ./scopalign-1031311354.32710 -d ./scopalign-1031311354.32710.set;sorttrans -f ./scopalign-1031311354.32710.scan -s Sc 2.5 > ./scopalign-1031311354.32710.sort;stamp -l ./scopalign-1031311354.32710.sort -prefix ./scopalign-1031311354.32710 > ./scopalign-1031311354.32710.log
**  transform -f ./scopalign-1031311354.32710.sort -g -o /test_data/55074.palign
**  
**  poststamp -f ./scopalign-1031311354.32710.1 -min 0.5
**  
**  POSTSTAMP, R.B. Russell 1995
**   New output will be in file ./scopalign-1031311354.32710.1
**   E1 =   3.800, E2 =   3.800
**   Minimum Pij set to 0.500
**   Reading domain descriptors/transformations from the file ./scopalign-1031311354.32710.1
**   Reading alignment...
**    Reading coordinates...
**   Domain   1 /cpdbscop_pdb/d1cs4a_.ent d1cs4a_
**          all residues 189 CAs =>  189 CAs in total
**   Transforming coordinates...
**   Domain   2 /cpdbscop_pdb/d1fx2a_.ent d1fx2a__1
**          all residues 235 CAs =>  235 CAs in total
**   Transforming coordinates...
**   ...done.
**  ver2hor -f ./scopalign-1031311354.32710.1.post > ./scopalign-1031311354.32710.out
**  
**  Unix % 
**  
**  Two domains belonging to the same family were aligned and a file called 
**  /test_data/55074.salign containing a structure-based sequence alignment 
**  and a file called 55074.palign containing a structure alignment were
**  written.  The base name of these files (55074) is identical to the Sunid
**  for the family taken from the scop classification /test_data/all.scop2.
**  
**  The following command line would achieve the same result.
**  scopalign /test_data/all.scop2 /test_data/ .salign /test_data/ .palign
**
**  
**  
**  Input file format
**  The format of the scop classification file is described in scopparse.c
**  
**  
**  
**  Output file format
**  The format of the scopalign structure-based sequence alignment output 
**  file (below) is similar to the output file generated by stamp when 
**  issued with the following three types of command:
** 
**  (1) stamp -l ./stamps_file.dom -s -n 2 -slide 5 -prefix ./stamps_file -d 
**  ./stamps_file.set;sorttrans -f ./stamps_file.scan -s Sc 2.5 > 
**  ./stamps_file.sort;stamp -l ./stamps_file.sort -prefix ./stamps_file > 
**  ./stamps_file.log
**
**  (2) poststamp -f ./stamps_file.3 -min 0.5
** 
**  (3) ver2hor -f ./stamps_file.3.post > ./stamps_file.out
**
**  However, the SCOP classification records for the appopriate family are 
**  written above the alignment, no dssp assignments are given, and only the
**  'Post similar' line is given. Also, 7 character domain identifier codes 
**  taken from the scop classificaiton file are given.
** 
**  Example of scopalign output file (structure-based sequence alignment)
**
**  CL   All alpha proteins
**  XX
**  FO   Globin-like
**  XX
**  SF   Globin-like
**  XX
**  FA   Globins
**  XX
**  SI   1321321
**  XX
**  Number               10        20        30        40        50    
**  d1vrea_              LSAAQRQVVASTWKDIAgsdngAGVGKECFTKFLSAHHDMAAV f gFS
**  d3sdhb_      svydaaaqLTADVKKDLRDSWKVIG sd kKGNGVALMTTLFADNQETIGYfkrlGN
**  d3hbia_      svydaaaqLTADVKKDLRDSWKVIG sd kKGNGVALMTTLFADNQETIGYfkrlGN
**  d3sdha_      svydaaaqLTADVKKDLRDSWKVIG sd kKGNGVALMTTLFADNQETIGYfkrlGN
**  Post_similar --------11111111111111111-00-1111111111111111111111-0-111
**  
**  Number        60        70        80        90       100       110 
**  d1vrea_      GAS   dpGVADLGAKVLAQIGVAVSHLgDEGKMVAEMKAVGVRHKgygnkhIKAEY
**  d3sdhb_      VSQgmandKLRGHSITLMYALQNFIDQLdNPDDLVCVVEKFAVNHI  t rkISAAE
**  d3hbia_      VSQgmandKLRGHSITLMYALQNFIDQLdNPDDLVCVVEKLAVNHI  t rkISAAE
**  d3sdha_      VSQgmandKLRGHSITLMYALQNFIDQLdNPDDLVCVVEKFAVNHI  t rkISAAE
**  Post_similar 111---0011111111111111111111011111111111111111--0-0011111
**  
**  Number          120       130       140       150       160
**  d1vrea_      FEPlGASL LSAMEhriggkMNAAAKDAWAAAYADisgalisglqs
**  d3sdhb_      FGK INGPiKKVLA s k nFGDKYANAWAKLVAVvqa al     
**  d3hbia_      FGK INGPiKKVLA s k nFGDKYANAWAKLVAVvqa al     
**  d3sdha_      FGK INGPiKKVLA s k nFGDKYANAWAKLVAVvqa al     
**  Post_similar 111-1111-11111-0-0-1111111111111111100-00-----
**  
**  
**  pdb format is used for the scopalign structure alignment output file 
**  (excerpt shown below).  This is unmodified stamp output.  A detailed 
**  explanation of the pdb file format is available on the pdb web site:
**  http://www.rcsb.org/pdb/info.html#File_Formats_and_Standards
**  
**  Excerpt of scopalign output file (structure alignment)
**  
**  REMARK Output from transform
**  REMARK  STAMP Package (Russell and Barton Proteins, 14, 309-323, 1992)
**  REMARK Domains were read from the file ./scopalign-1031313039.24319.sort
**  REMARK Chains are labelled sequentially starting with 'A' and
**  REMARK  after the order given in the file ./scopalign-1031313039.24319.sort
**  REMARK The domains in this file are:
**  REMARK       d1cs4a_  chain A 
**  REMARK       d1fx2a__1  chain B 
**  REMARK Does not include heteroatoms
**  REMARK  Does not include DNA/RNA 
**  REMARK Does not include waters
**  ATOM      1  N   MET A  22      28.568 -27.770  32.255  1.00 73.77           N  
**  ATOM      2  CA  MET A  22      28.292 -26.443  32.794  1.00 72.28           C  
**  ATOM      3  C   MET A  22      29.325 -25.377  32.396  1.00 69.48           C  
**  ATOM      4  O   MET A  22      30.485 -25.687  32.098  1.00 67.04           O  
**  ATOM      5  CB  MET A  22      28.075 -26.504  34.312  1.00 74.79           C  
**  ATOM      6  CG  MET A  22      29.171 -27.205  35.092  1.00 78.73           C  
**  ATOM      7  SD  MET A  22      28.708 -27.446  36.824  1.00 83.74           S  
**  ATOM      8  CE  MET A  22      28.745 -25.745  37.440  1.00 81.94           C  
**  ATOM      9  N   MET A  23      28.883 -24.120  32.395  1.00 66.44           N  
**  ATOM     10  CA  MET A  23      29.698 -22.969  32.011  1.00 62.94           C  
**  ATOM     11  C   MET A  23      30.928 -22.727  32.886  1.00 59.70           C  
**  ATOM     12  O   MET A  23      32.059 -22.739  32.400  1.00 57.00           O  
**  ATOM     13  CB  MET A  23      28.824 -21.715  31.966  1.00 64.01           C  
**  ATOM     14  CG  MET A  23      27.551 -21.872  31.137  1.00 64.35           C  
**
**  < data ommitted for clarity >
**  
**  ATOM   1853  CA  ASP B 235      47.656 -10.920  50.374  1.00 73.64           C  
**  ATOM   1854  C   ASP B 235      46.520 -10.365  49.515  1.00 74.17           C  
**  ATOM   1855  O   ASP B 235      46.464 -10.761  48.332  1.00 75.01           O  
**  ATOM   1856  CB  ASP B 235      47.790 -12.446  50.171  1.00 73.22           C  
**  
**  
**  
**  Data files
**  scopalign does not use any data files but does make use of the stamp 
**  "pdb.directories" file (see 'Notes').
**  
**  
**  
**  Diagnostic error messages
**  
**  
**  
**  Authors
**  Ranjeeva Ranasinghe (rranasin@hgmp.mrc.ac.uk)
**  Jon Ison (jison@hgmp.mrc.ac.uk)
**  
**  
**  
**  References
**  Please cite the authors.
**  
**  Related references are given below.
**  Russell, R. B. & Barton, G. J. (1992), Multiple Sequence Alignment from 
**  Tertiary Structure Comparison: Assignment of Global and Residue Confidence
**  Levels,  PROTEINS: Struct. Funct. Genet., 14, 309-323.
**  
**  More information on stamp can be found at
**  http://www.compbio.dundee.ac.uk/manuals/stamp.4.2/
** 
**  
**  
******************************************************************************/






#include "emboss.h"


static void scopalign_ProcessStampFile(AjPStr in, AjPStr out, AjPScop scop);



/* @prog scopalign *******************************************************
**
** Generate alignments for families in a scop classification file by using 
** STAMP.
**
******************************************************************************/

int main(int argc, char **argv)
{
    ajint     nfam      = 0;	/* Counter for the families */
    ajint     ncluster  = 0;	/* Counter for the number of clusters*/    
    ajint     x         = 0;  /* Counter */
    
    ajint     last_famid=    0; /* SCOP Sunid of last family that was processed */
    AjPStr    last_fam  = NULL; /* Last family that was processed */
    AjPStr    exec      = NULL;	/* The UNIX command line to be executed*/
    AjPStr    out       = NULL;	/* Name of stamp alignment file */
    AjPStr    align     = NULL;	/* Name of sequence alignment file */
    AjPStr    alignc    = NULL;	/* Name of structure alignment file */
    AjPStr    log       = NULL;	/* Name of STAMP log file */
    AjPStr    dom       = NULL;	/* Name of file containing single domain*/
    AjPStr    set       = NULL;	/* Name of file containing set of domains*/
    AjPStr    scan      = NULL;	/* Name of temp. file used by STAMP*/
    AjPStr    sort      = NULL;	/* Name of temp. file used by STAMP*/
    AjPStr    name      = NULL;	/* Base name of STAMP temp files */
    AjPStr    line      = NULL;	/* Holds a line from the log file*/
    AjPStr    path      = NULL;	/* Path of sequence alignment files for output */
    AjPStr    extn      = NULL;	/* Extension of sequence alignment files for output */
    AjPStr    pathc     = NULL;	/* Path of structure alignment files for output */
    AjPStr    extnc     = NULL;	/* Extension of structure alignment files for output */
    AjPStr    temp      = NULL;	/* A temporary string */
    AjPStr    temp1     = NULL;	/* A temporary string */

    AjPFile   scopf     = NULL;	/* File pointer for original Escop.dat file */
    AjPFile   domf      = NULL;	/* File pointer for single domain file */
    AjPFile   setf      = NULL;	/* File pointer for domain set file */
    AjPFile   logf      = NULL;	/* File pointer for log file */

    AjPRegexp rexp      = NULL;	/*For parsing no. of clusters in log file*/
    AjPScop   scop      = NULL;	/* Pointer to scop structure */
    AjPScop   prevscop  = NULL;	/* Pointer to previous scop structure */





    /* Initialise strings etc*/
    last_fam = ajStrNew();
    exec     = ajStrNew();
    out      = ajStrNew();
    align    = ajStrNew();
    alignc   = ajStrNew();
    log      = ajStrNew();
    dom      = ajStrNew();
    set      = ajStrNew();
    scan     = ajStrNew();
    sort     = ajStrNew();
    name     = ajStrNew();
    line     = ajStrNew();
    temp     = ajStrNew();
    temp1    = ajStrNew();

    

    /* Read data from acd */
    ajNamInit("emboss");
    ajAcdInitP("scopalign",argc,argv,"DOMAINATRIX");
    scopf     = ajAcdGetInfile("scopf");
    path      = ajAcdGetString("path");
    extn      = ajAcdGetString("extn");
    pathc     = ajAcdGetString("pathc");
    extnc     = ajAcdGetString("extnc");

    
    /* Check directory is OK*/
    if(!ajFileDir(&path))
	ajFatal("Could not open directory for output");
    if(!ajFileDir(&pathc))
	ajFatal("Could not open directory for output");


    /* Compile regular expression*/
    /*    rexp     = ajRegCompC("^(Cluster:)  ([0-9])"); */
    rexp     = ajRegCompC("^(Cluster:)");

    /* Initialise random number generator for naming of temp. files*/
    ajRandomSeed();
    ajStrAssC(&name, ajFileTempName(NULL));


    /* Create names for temp. files*/
    ajStrAssS(&log, name);	
    ajStrAppC(&log, ".log");
    ajStrAssS(&dom, name);	
    ajStrAppC(&dom, ".dom");
    ajStrAssS(&set, name);	
    ajStrAppC(&set, ".set");
    ajStrAssS(&scan, name);	
    ajStrAppC(&scan, ".scan");
    ajStrAssS(&sort, name);	
    ajStrAppC(&sort, ".sort");
    ajStrAssS(&out, name);	
    ajStrAppC(&out, ".out");


    /* Initialise last_fam with something that is not in SCOP*/
    ajStrAssC(&last_fam,"!!!!!");
    
    

    
    /* Open domain set file*/
    if(!(setf=ajFileNewOut(set)))
	ajFatal("Could not open domain set file\n");





    /* Start of main application loop*/
    while((ajXyzScopReadC(scopf, "*", &scop)))
    {
	/* A new family */
/*	if(ajStrMatch(last_fam, scop->Family)==ajFalse)  */
	if( last_famid !=  scop->Sunid_Family)
	{
	    /* If we have done the first family*/
	    if(nfam)
	    {
		/*Close domain set file*/
		ajFileClose(&setf);	
		


		/* Create the output file for the alignment - the name will
		   be the same as the Sunid for the SCOP family */

		ajStrFromInt(&temp, prevscop->Sunid_Family);
		ajStrAssS(&align, temp);	
		ajStrInsert(&align, 0, path);	
		ajStrApp(&align, extn);

		ajStrAssS(&alignc, temp);	
		ajStrInsert(&alignc, 0, pathc);	
		ajStrApp(&alignc, extnc);



		/* Create the output file for the alignment - the name will
		  be the same as the SCOP family but with ' ' and '&' 
		  replaced by '_'*/
		/*
		ajStrAssS(&align, last_fam);	
		ajStrSubstituteCC(&align, " ", "_");
		ajStrSubstituteCC(&align, "&", "_");
		ajStrInsert(&align, 0, path);	
		ajStrApp(&align, extn);
		*/
		
		/* If a file of that name exists, then append _1 or _2 etc 
		   as necessary until a unique name is found */
		/*
		ajStrAssS(&temp, align);	
		for(x=1;
		    (ajFileStat(&temp, AJ_FILE_R ) ||
		     ajFileStat(&temp, AJ_FILE_W ) ||
		     ajFileStat(&temp, AJ_FILE_X ));
		    x++)
		{
		    ajStrAssS(&temp, align);	
		    ajStrAppC(&temp, "_");
		    ajFmtPrintS(&temp1, "%d", x);
		    ajStrApp(&temp, temp1);
		}
		ajStrAssS(&align, temp);	
		*/




		/* Call STAMP */
		ajFmtPrintS(&exec,"stamp -l %S -s -n 2 -slide 5 -prefix "
			    "%S -d %S;sorttrans -f %S -s Sc 2.5 > %S;"
			    "stamp -l %S -prefix %S > %S\ntransform -f %S -g -o %S\n", 
			    dom, name, set, scan, sort, sort, name, log, sort, alignc); 


/*		ajFmtPrintS(&exec,"stamp -l %S -s -n 2 -slide 5 -prefix "
			    "%S -d %S;sorttrans -f %S -s Sc 2.5 > %S;"
			    "stamp -l %S -prefix %S > %S\n", 
			    dom, name, set, scan, sort, sort, name, log);  */


		ajFmtPrint("%S\n", exec);
		system(ajStrStr(exec));  
		

		/* Count the number of clusters in the log file*/
		if(!(logf=ajFileNewIn(log)))
		    ajFatal("Could not open log file\n");
		ncluster=0;
		while(ajFileReadLine(logf,&line))
		    if(ajRegExec(rexp,line))
			ncluster++;
		ajFileClose(&logf);	
		


				
		/* Call STAMP ... calculate two fields for structural 
		   equivalence using threshold Pij value of 0.5, see stamp 
		   manual v4.1 pg 27*/
		ajFmtPrintS(&exec,"poststamp -f %S.%d -min 0.5\n",
			    name, ncluster);
		ajFmtPrint("%S\n", exec);
		system(ajStrStr(exec));


		/* Call STAMP ... convert block format alignment into clustal 
		   format*/
/*
		ajFmtPrintS(&exec,"aconvert  -in b -out c <%S.%d.post > %S\n",
			    name, ncluster, out); */
		ajFmtPrintS(&exec,"ver2hor -f %S.%d.post > %S\n",
			    name, ncluster, out); 
		ajFmtPrint("%S\n", exec);
		system(ajStrStr(exec));


		/* Process STAMP alignment file and generate alignment file 
		   for output */
		scopalign_ProcessStampFile(out, align, prevscop);
		

		/* Remove all temporary files */
		for(x=1;x<ncluster+1;x++)
		{
		    ajFmtPrintS(&temp, "rm %S.%d", name, x);
		    ajSystem(&temp);
		}
		ajFmtPrintS(&temp, "rm %S.%d.post", name, ncluster);
		ajSystem(&temp);
		
		/* Open domain set file */
		if(!(setf=ajFileNewOut(set)))
		    ajFatal("Could not open domain set file\n");
	    }
	    
	    
	    	    	    	    
	    
	    /* Open, write and close domain file*/
	    if(!(domf=ajFileNewOut(dom)))
		ajFatal("Could not open domain file\n");
	    ajStrAssS(&temp, scop->Entry);
	    ajStrToLower(&temp);
	    ajFmtPrintF(domf, "%S %S { ALL }\n", temp, temp);
	    ajFileClose(&domf);	

	    
	    /* Increment family counter*/
	    nfam++;


	    /* Copy current family name to last_fam*/
	    ajStrAssS(&last_fam,scop->Family);
	    last_famid = scop->Sunid_Family;
	    
	    
	    /* Copy current scop pointer to prevscop */
	    ajXyzScopDel(&prevscop);
	    prevscop=NULL;
	    ajXyzScopCopy(&prevscop, scop);
	    /* prevscop = scop; */
	}
						
	
	/* Write to domain set file*/
	ajStrAssS(&temp, scop->Entry);
	ajStrToLower(&temp);
	ajFmtPrintF(setf, "%S %S { ALL }\n", temp, temp);

	ajXyzScopDel(&scop);
    }
    /* End of main application loop*/

    scop=prevscop;
    



    /* Start of code to process last family */
    /*Close domain set file*/
    ajFileClose(&setf);	
		


    /* Create the output file for the alignment - the name will
       be the same as the Sunid for the SCOP family */
    ajStrFromInt(&temp, scop->Sunid_Family);
    ajStrAssS(&align, temp);	
    ajStrInsert(&align, 0, path);	
    ajStrApp(&align, extn);

    ajStrAssS(&alignc, temp);	
    ajStrInsert(&alignc, 0, pathc);	
    ajStrApp(&alignc, extnc);
    

    /* Create the output file for the alignment*/
    /*
    ajStrAssS(&align, scop->Family);	
    ajStrSubstituteCC(&align, " ", "_");
    ajStrInsert(&align, 0, path);	
    ajStrApp(&align, extn);
    */

    /* If a file of that name exists, then append _1 or _2 etc 
       as necessary until a unique name is found */
    /*
    ajStrAssS(&temp, align);	
    for(x=1;
	(ajFileStat(&temp, AJ_FILE_R ) ||
	 ajFileStat(&temp, AJ_FILE_W ) ||
	 ajFileStat(&temp, AJ_FILE_X ));
	x++)
    {
	ajStrAssS(&temp, align);	
	ajStrAppC(&temp, "_");
	ajFmtPrintS(&temp1, "%d", x);
	ajStrApp(&temp, temp1);
    }
    ajStrAssS(&align, temp);	
    */




    /* Call STAMP */
    ajFmtPrintS(&exec,"stamp -l %S -s -n 2 -slide 5 -prefix %S -d %S;"
		"sorttrans -f %S -s Sc 2.5 > %S;stamp -l %S "
		"-prefix %S > %S\ntransform -f %S -g -o %S\n", 
		dom, name, set, scan, sort, sort, name, log, sort, alignc);  

/*    ajFmtPrintS(&exec,"stamp -l %S -s -n 2 -slide 5 -prefix %S -d %S;"
		"sorttrans -f %S -s Sc 2.5 > %S;stamp -l %S "
		"-prefix %S > %S\n", 
		dom, name, set, scan, sort, sort, name, log); */

    system(ajStrStr(exec));  
    ajFmtPrint("%S\n", exec);


    /* Count the number of clusters in the log file*/
    if(!(logf=ajFileNewIn(log)))
	ajFatal("Could not open log file\n");
    /*count the number of clusters*/
    ncluster=0;
    while(ajFileReadLine(logf,&line))
	if(ajRegExec(rexp,line))
	    ncluster++;
    ajFileClose(&logf);	
    		


    /* Call STAMP ... calculate two fields for structural equivalence */
    /* using threshold Pij value of 0.5, see stamp manual v4.1 pg 27*/
    ajFmtPrintS(&exec,"poststamp -f %S.%d -min 0.5\n",
		name, ncluster);
    ajFmtPrint("%S\n", exec);
    system(ajStrStr(exec));


    /* Call STAMP ... convert block format alignment into clustal format*/
    /*    ajFmtPrintS(&exec,"aconvert -in b -out c <%S.%d.post > %S\n",
	  name, ncluster, out); */
    ajFmtPrintS(&exec,"ver2hor -f %S.%d.post > %S\n",name, ncluster, out); 
    ajFmtPrint("%S\n", exec);
    system(ajStrStr(exec));
    

    /* Process STAMP alignment file and generate alignment file for output */
    scopalign_ProcessStampFile(out, align, scop);


    /* Remove all temporary files */
    ajFmtPrintS(&temp, "rm %S", log);
    ajSystem(&temp);
    ajFmtPrintS(&temp, "rm %S", dom);
    ajSystem(&temp);
    ajFmtPrintS(&temp, "rm %S", set);
    ajSystem(&temp);
    ajFmtPrintS(&temp, "rm %S", scan);
    ajSystem(&temp);
    ajFmtPrintS(&temp, "rm %S", sort);
    ajSystem(&temp);
    ajFmtPrintS(&temp, "rm %S", out);
    ajSystem(&temp);
    ajStrAssS(&temp, name);	
    ajStrAppC(&temp, ".mat");
    ajFmtPrintS(&temp1, "rm %S", temp);
    ajSystem(&temp1);

    /* Remove all temporary files */
    for(x=1;x<ncluster+1;x++)
    {
	ajFmtPrintS(&temp, "rm %S.%d", name, x);
	ajSystem(&temp);
    }
    ajFmtPrintS(&temp, "rm %S.%d.post", name, ncluster);
    ajSystem(&temp);
    
    /* Tidy up*/
    ajXyzScopDel(&scop);
    ajFileClose(&scopf);	
    ajRegFree(&rexp);
    ajStrDel(&last_fam);
    ajStrDel(&exec);
    ajStrDel(&log);
    ajStrDel(&dom);
    ajStrDel(&set);
    ajStrDel(&scan);
    ajStrDel(&sort);
    ajStrDel(&name);
    ajStrDel(&out);
    ajStrDel(&align);
    ajStrDel(&alignc);
    ajStrDel(&line);
    ajStrDel(&path); 
    ajStrDel(&extn); 
    ajStrDel(&pathc); 
    ajStrDel(&extnc); 
    ajStrDel(&temp); 
    ajStrDel(&temp1); 


    /* Bye Bye */
    ajExit();
    return 0;
}




/* @funcstatic scopalign_ProcessStampFile ***********************************
**
** This function is very specific to scopalign, hence it is not library code.
** This function reads the output of ver2hor, i.e. a stamp alignment (Figure 
** 1 below) and creates an output file which is annotated with SCOP records 
** (Figure 2 below).
** 
** 
** Figure 1
** 
** VER2HOR R.B. Russell, 1995
**  Prints STAMP alignments in horizontal format
**   for quick viewing
**  Reading Alignment...
**  Getting STAMP information...
**  6 STAMP fields read in for 547 positions 
**  Processing the alignment...
**  Output:
**  Very reliable => Pij' >=6 for stretches of >=3
**  Less reliable => Pij' >=4.5 for stretches of >=3
**  Post reliable => All Pij' > stamp_post parameter for stretches >=3
** 
** Number               10        20        30        40        50    
**   d1maac_    egrEDPQLLVRVRGGQLRGIRLKAPGGPVSAFLGIPFAEPPVGSRRFMPPEPKRPWS
** d1maad__1       EDPQLLVRVRGGQLRGIRLKAPGGPVSAFLGIPFAEPPVGSRRFMPPEPKRPWS
** 
** d1maac__ds   ?????????????????????????????????????????????????????????
** d1maad__1_      ??????????????????????????????????????????????????????
** 
** Very similar ---111111111111111111111111111111111111111111111111111111
** Less similar ---111111111111111111111111111111111111111111111111111111
** Post similar ---111111111111111111111111111111111111111111111111111111
** 
** Number        60        70        80        90       100       110 
**   d1maac_    GVLDATTFQNVCYQYVDTLYPGFEGTEMWNPNRELSEDCLYLNVWTPYPRPASPTPV
** d1maad__1    GVLDATTFQNVCYQYVDTLYPGFEGTEMWNPNRELSEDCLYLNVWTPYPRPASPTPV
** 
** d1maac__ds   ?????????????????????????????????????????????????????????
** d1maad__1_   ?????????????????????????????????????????????????????????
** 
** Very similar 111111111111111111111111111111111111111111111111111111111
** Less similar 111111111111111111111111111111111111111111111111111111111
** Post similar 111111111111111111111111111111111111111111111111111111111
** 
** Number          120       130       140       150       160       170
**   d1maac_    LIWIYGGGFYSGAASLDVYDGRFLAQVEGAVLVSMNYRVGTFGFLALPGSREAPGNV
** d1maad__1    LIWIYGGGFYSGAASLDVYDGRFLAQVEGAVLVSMNYRVGTFGFLALPGSREAPGNV
** 
** d1maac__ds   ?????????????????????????????????????????????????????????
** d1maad__1_   ?????????????????????????????????????????????????????????
** 
** Very similar 111111111111111111111111111111111111111111111111111111111
** Less similar 111111111111111111111111111111111111111111111111111111111
** Post similar 111111111111111111111111111111111111111111111111111111111
** 
** 
** 
** Figure 2
**
** CL   Alpha and beta proteins (a/b)
** XX
** FO   alpha/beta-Hydrolases
** XX
** SF   alpha/beta-Hydrolases
** XX
** FA   Acetylcholinesterase-like
** XX
** SI   1321321
** XX
** Number               10        20        30        40        50    
**   d1maac_    egrEDPQLLVRVRGGQLRGIRLKAPGGPVSAFLGIPFAEPPVGSRRFMPPEPKRPWS
**   d1maad_       EDPQLLVRVRGGQLRGIRLKAPGGPVSAFLGIPFAEPPVGSRRFMPPEPKRPWS
** Post similar ---111111111111111111111111111111111111111111111111111111
** 
** Number        60        70        80        90       100       110 
**   d1maac_    GVLDATTFQNVCYQYVDTLYPGFEGTEMWNPNRELSEDCLYLNVWTPYPRPASPTPV
**   d1maad_    GVLDATTFQNVCYQYVDTLYPGFEGTEMWNPNRELSEDCLYLNVWTPYPRPASPTPV
** Post similar 111111111111111111111111111111111111111111111111111111111
** 
** Number          120       130       140       150       160       170
**   d1maac_    LIWIYGGGFYSGAASLDVYDGRFLAQVEGAVLVSMNYRVGTFGFLALPGSREAPGNV
**   d1maad_    LIWIYGGGFYSGAASLDVYDGRFLAQVEGAVLVSMNYRVGTFGFLALPGSREAPGNV
** Post similar 111111111111111111111111111111111111111111111111111111111
** 
**
** @param [r] in  [AjPStr] Name of input file
** @param [r] out [AjPStr] Name of output file
** @param [r] scop [AjPScop] SCOP structure with SCOP classification records
**
** @return [void]
** @@
*****************************************************************************/

static void scopalign_ProcessStampFile(AjPStr in, AjPStr out, AjPScop scop)
{
    AjPFile  outf =NULL;  /* Output file pointer */
    AjPFile   inf =NULL;  /* Input file pointer */
    AjPStr  temp1 =NULL;  /* Temporary string */
    AjPStr  temp2 =NULL;  /* Temporary string */
    AjPStr  temp3 =NULL;  /* Temporary string */
    AjPStr   line =NULL;  /* Line of text from input file */
    ajint     blk =1;     /* Count of the current block in the input file.
			     Block 1 is the numbering and protein sequences, 
			     Block 2 is the secondary structure, 
			     Block 3 is the Very/Less/Post similar records*/
    
    
    /* Initialise strings */
    line    = ajStrNew();
    temp1    = ajStrNew();
    temp2    = ajStrNew();
    temp3    = ajStrNew();


    /* Open input and output files */
    if(!(outf=ajFileNewOut(out)))
	ajFatal("Could not open output file in scopalign_ProcessStampFile");
    if(!(inf=ajFileNewIn(in)))
	ajFatal("Could not open input file in scopalign_ProcessStampFile");
    

    /*Write SCOP classification records to file*/
    ajFmtPrintF(outf,"CL   %S",scop->Class);
    ajFmtPrintSplit(outf,scop->Fold,"\nXX\nFO   ",75," \t\n\r");
    ajFmtPrintSplit(outf,scop->Superfamily,"XX\nSF   ",75," \t\n\r");
    ajFmtPrintSplit(outf,scop->Family,"XX\nFA   ",75," \t\n\r");
    ajFmtPrintF(outf,"XX\n");
    ajFmtPrintF(outf,"SI   %d\nXX",scop->Sunid_Family);

    
    /* Start of code for reading input file */
    /*Ignore everything up to first line beginning with 'Number'*/
    while((ajFileReadLine(inf,&line)))
	/* ajFileReadLine will trim the tailing \n */
	if((ajStrChar(line, 1)=='\0'))
	    break;

    
    /* Read rest of input file */
    while((ajFileReadLine(inf,&line)))
    {
	/* Increment counter for block of file */
	if((ajStrChar(line, 1)=='\0'))
	{
	    blk++;
	    if(blk==4)
		blk=1;
	    
	    continue;
	}


	/* Block of numbering line and protein sequences */
	if(blk==1)
	{
	    /* Print the number line out as it is */
	    if(ajStrPrefixC(line,"Number"))
		ajFmtPrintF(outf,"\n%S\n",line);
	    else
	    {
		/* Read only the 7 characters of the domain identifier code in */
		ajFmtScanS(line, "%S", &temp1);
		ajStrAssSub(&temp2, temp1, 0, 6);


		/* Read the sequence */
		ajStrAssSub(&temp3, line, 13, 69);
		ajStrConvertCC(&temp3, " ", "-");
		ajStrToUpper(&temp3);
		

		/* Write domain id code and sequence out */
		ajFmtPrintF(outf,"%-13S%S\n",temp2, temp3);
	    }
	}
	/* Secondary structure filled with '????' (unwanted) */
	else if(blk==2)
	{
	    continue;
	}
	/* Similarity lines */
	else
	{
	    if(ajStrPrefixC(line,"Post"))
	    {
		/* Read the sequence */
		ajStrAssSub(&temp3, line, 13, 69);

		/* Write post similar line out */
		ajFmtPrintF(outf,"%-13s%S\n","Post_similar", temp3);
	    }
	    /* Ignore Very and Less similar lines */
	    else continue;
	    
	   
	    
	}
    }
    

    /* Clean up and close input and output files */
    ajFileClose(&outf);
    ajFileClose(&inf);
    ajStrDel(&line);
    ajStrDel(&temp1);
    ajStrDel(&temp2);
    ajStrDel(&temp3);
    

    /* All done */
    return;
}





