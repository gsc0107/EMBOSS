seqset: sequence [
  parameter: "Y"
  type: "gapany"
]

integer: jumble [
  optional: "Y"
  information: "Number of times to jumble"
  minimum: "1"
  default: "1"

  help: "In most of the tree construction programs (except for the
  '...PENNY' programs and CLIQUE), the exact details of the search of
  different trees depend on the order of input of species. In these
  programs the 'jumble' option enables you to tell the program to use a random
  number generator to choose the input order of species. The program
  will then prompt you for a 'seed' for the random number
  generator. \

The Jumble option defines how many times you want to restart the
process. If you answer 10, the program will try ten different orders
of species in constructing the trees, and the results printed out will
reflect this entire search process (that is, the best trees found
among all 10 runs will be printed out, not the best trees from each
individual run)."

]

integer: seed [
  required: "$(jumble)"
  information: "Random number seed (must be odd)"
  minimum: 1
  maximum: "32765"
  default: 1
  help: "The seed should be an integer between 1 and 32765, and
  should be of form 4n+1, which means that it must give a remainder of 1
  when divided by 4. This can be judged by looking at the last two
  digits of the number. Each different seed leads to a different
  sequence of addition of species. By simply changing the random
  number seed and re-running the programs one can look for other, and
  better trees. If the seed entered is not 4n+1 the program will
  choose the next highest valid seed. \

Some people have asked what are good values of the random number
seed. The random number seed is used to start a process of choosing
'random' (actually pseudorandom) numbers, which behave as if they were
unpredictably randomly chosen between 0 and 232-1 (which is
4,294,967,296). You could put in the number 133 and find that the next
random number was 1,876,973,009. As they are effectively
unpredictable, there is no such thing as a choice that is better than
any other, provided that the numbers are of the form 4n+1. However if
you re-use a random number seed, the sequence of random numbers that
result will be the same as before, resulting in exactly the same
series of choices, which may not be what you want."

]

integer: outgroup [
  optional: "Y"
  information: "Number of the outgroup"
  default: "0"
  minimum: "0"
  maximum: "$(sequence.size)"

  help: "Specifies which species is to be used to root the tree by
having it become the outgroup. The program will then prompt for the
number of the outgroup (the species being taken in the numerical order
that they occur in the input file). A value of 6 indicates that the
sixth species in the data is the outgroup. Outgroup-rooting will not
be attempted if the data have already established a root for the tree
from some other consideration, and may not be if it is a user-defined
tree, despite your invoking the option. Thus programs such as FDOLLOP
that produce only rooted trees do not allow the Outgroup option. It is
also not available in FKITSCH or FDNAMLK. When it is used, the tree as
printed out is still listed as being an unrooted tree, though the
outgroup is connected to the bottommost node so that it is easy to
visually convert the tree into rooted form."

 ]

float: threshold [
  optional: "Y"
  information: "Threshold value"
  minimum: "1.0"
  maximum: "$(sequence.size)"
  default: "$(sequence.size)"

  help: "Sets a threshold for the parsimony programs such that if the
  number of steps counted in a character is higher than the threshold,
  it will be taken to be the threshold value rather than the actual
  number of steps. The default is a threshold so high that it will
  never be surpassed (in which case the steps will simply be
  counted). \
  The use of thresholds to obtain methods
  intermediate between parsimony and compatibility methods is
  described in the 1981b PHYLIP paper. \

The numerical threshold value will be
  a positive real number greater than 1. \

In programs FMIX, FMOVE, FPENNY,
  FPROTPARS, FDNAPARS, FDNAMOVE, and FDNAPENNY, do not use threshold
  values less than or equal to 1.0, as they have no meaning and lead
  to a tree which depends only on considerations such as the input
  order of species and not at all on the character state data! \

In
  programs FDOLLOP, FDOLMOVE, and FDOLPENNY the threshold should never be
  0.0 or less, for the same reason. \

The 'threhold' option is an important and
  underutilized one: it is, for example, the only way in this package
  (except for program FDNACOMP) to do a compatibility analysis when
  there are missing data. It is a method of de-weighting characters
  that evolve rapidly. I wish more people were aware of its
  properties."

]

integer: categories [
  optional: "Y"
  information: "Number of categories"
  minimum: "1"
  default: "1"
  maximum: "9"

  help: "Allows us to specify to the program that there will be a
number of different possible evolutionary rates, what the prior
probabilities of occurrence of each is, and what is the average length of
a patch of sites all having the same rate. "

]

array: rates [
  required: "$(categories)"
  information: "Rates for each category"
  size: "$(categories)"
  sum; "1.0"
  minimum: "0.0"
  maximum: "1.0"

  help: "Specifies the rates for each evlutionary category.
The rates can also be
chosen by the program to approximate a Gamma distribution of rates, or
a Gamma distribution plus a class of invariant sites. The program
computes the the likelihood by summing it over all possible
assignments of rates to sites, weighting each by its prior probability
of occurrence."

]

array: probabilities [
  required: "$(categories)"
  information: "Probabilities for each category"
  size: "$(categories)"
  sum; "1.0"
  minimum: "0.0"
  maximum: "1.0"

  help: "Specify what the prior probability of occurrence of each
  evolutionary category is"

]

integer: howoften [
  optional: "Y"
  information: "How often to report, in trees"
  minimum: "1"
  default: "100"
  help: "The program will keep count of how many trees
  it has examined. Suppose that howoften is 100 and howmany is 1000,
  the default settings. Every time 100 trees have been examined,
  the program will print out a line saying how many multiples of 100
  trees have now been examined, how many steps the most parsimonious
  tree found so far has, how many trees of with that number of steps
  have been found, and a very rough estimate of what fraction of all
  trees have been looked at so far. \

When the number of these multiples printed out reaches the number
howmany (say 1000), the whole algorithm aborts and prints out that it
has not found all most parsimonious trees, but prints out what is has
got so far anyway. These trees need not be any of the most
parsimonious trees: they are simply the most parsimonious ones found
so far. By setting the product (howoften times howmany) large you can
make the algorithm less likely to abort, but then you risk getting
bogged down in a gigantic computation. You should adjust these
constants so that the program cannot go beyond examining the number of
trees you are reasonably willing to pay for (or wait for). In their
initial setting the program will abort after looking at 100,000
trees. Obviously you may want to adjust howoften in order to get more
or fewer lines of intermediate notice of how many trees have been
looked at so far. Of course, in small cases you may never even reach
the first multiple of howoften, and nothing will be printed out except
some headings and then the final trees.

The indication of the approximate percentage of trees searched so far
will be helpful in judging how much farther you would have to go to
get the full search. Actually, since that fraction is the fraction of
the set of all possible trees searched or ruled out so far, and since
the search becomes progressively more efficient, the approximate
fraction printed out will usually be an underestimate of how far along
the program is, sometimes a serious underestimate."
]

integer: howmany [
  optional: "Y"
  information:"How many groups of reported trees"
  minimum: "1"
  default: "1000"
  help: "The program will keep count of how many trees
  it has examined. Suppose that howoften is 100 and howmany is 1000,
  the default settings. Every time 100 trees have been examined,
  the program will print out a line saying how many multiples of 100
  trees have now been examined, how many steps the most parsimonious
  tree found so far has, how many trees of with that number of steps
  have been found, and a very rough estimate of what fraction of all
  trees have been looked at so far. \

When the number of these multiples printed out reaches the number
howmany (say 1000), the whole algorithm aborts and prints out that it
has not found all most parsimonious trees, but prints out what is has
got so far anyway. These trees need not be any of the most
parsimonious trees: they are simply the most parsimonious ones found
so far. By setting the product (howoften times howmany) large you can
make the algorithm less likely to abort, but then you risk getting
bogged down in a gigantic computation. You should adjust these
constants so that the program cannot go beyond examining the number of
trees you are reasonably willing to pay for (or wait for). In their
initial setting the program will abort after looking at 100,000
trees. Obviously you may want to adjust howoften in order to get more
or fewer lines of intermediate notice of how many trees have been
looked at so far. Of course, in small cases you may never even reach
the first multiple of howoften, and nothing will be printed out except
some headings and then the final trees.

The indication of the approximate percentage of trees searched so far
will be helpful in judging how much farther you would have to go to
get the full search. Actually, since that fraction is the fraction of
the set of all possible trees searched or ruled out so far, and since
the search becomes progressively more efficient, the approximate
fraction printed out will usually be an underestimate of how far along
the program is, sometimes a serious underestimate."
]


float: lambda [
  optional: "Y"
  information: "Mean block length of sites having the same rate"
  minimum: "1.0"
  default: "1.0"

  help: "If more than one category is specified, then this allows us
to specify that we want to assume that sites that have the same HMM
rate category are expected to be clustered so that there is
autocorrelation of rates. The program asks for the value of the
average patch length. This is an expected length of patches that have
the same rate. If it is 1, the rates of successive sites will be
independent. If it is, say, 10.25, then the chance of change to a new
rate will be 1/10.25 after every site. However the 'new rate' is
randomly drawn from the mix of rates, and hence could even be the
same. So the actual observed length of patches with the same rate will
be a bit larger than 10.25. Note below that if you choose multiple
patches, there will be an estimate in the output file as to which
combination of rate categories contributed most to the likelihood."

]

array: basefreqs [
  optional: "Y"
  information: "Base frequencies for A, C, G, T/U"
  size: "4"
  minimum: "0.0"
  maximum: "1.0"
  default; "0.25"

  help: "An option which may save users much time. If you want to use
  the empirical frequencies of the bases, observed in the input
  sequences, as the base frequencies, you simply use the default
  setting. These empirical frequencies are not really
  the maximum likelihood estimates of the base frequencies, but they
  will often be close to those values (what they are is maximum
  likelihood estimates under a 'star' or 'explosion' phylogeny). If
  you change the setting of the F option you will be prompted for the
  frequencies of the four bases. These must add to 1.0"

]

float: ttratio [
  optional: "Y"
  information: "Transition/transversion ratio"
  default: "2.0"
  minimum: "0.0"

  help: "The Transition/transversion option. A number greater than
0.0, as the expected ratio of transitions to transversions. Note that
this is not the ratio of the first to the second kinds of events, but
the resulting expected ratio of transitions to transversions. The
exact relationship between these two quantities depends on the
frequencies in the base pools. The default value is 2.0."

]

float: power [
  optional: "Y"
  information: "Power"
  default: "2.0"
  minimum: "1.0"

  help: "The power (P in the standard formula described in the
  documentation). The default value is 2.0 (the Fitch-Margoliash
  method)."

]


integer: weights [
  optional: "Y"
  information: "Number of sets of weights
  default: "0"
  minimum: "1"

  help: "If non-zero, signals the program that, in addition to the
  data set, you want to read in a series of weights that tell how many
  times each character is to be counted. If the weight for a character
  is zero (0) then that character is in effect to be omitted when the
  tree is evaluated. If it is (1) the character is to be counted
  once. Some programs allow weights greater than 1 as well. These have
  the effect that the character is counted as if it were present that
  many times, so that a weight of 4 means that the character is
  counted 4 times. The values 0-9 give weights 0 through 9, and the
  values A-Z give weights 10 through 35. By use of the weights we can
  give overwhelming weight to some characters, and drop others from
  the analysis. \
\

In the molecular sequence programs only two values of
the weights, 0 or 1 are allowed. \
\

The weights are used to analyze subsets of the characters, and also
can be used for resampling of the data as in bootstrap and jackknife
resampling. For those programs that allow weights to be greater than
1, they can also be used to emphasize information from some characters
more strongly than others. Of course, you must have some rationale for
doing this.
\
\

The weights are provided as a sequence of digits. Thus they might be 
\
\

10011111100010100011110001100 
\
\

The weights are to be provided in an input file whose default name is
weights. In programs such as FSEQBOOT that can also output a file of
weights, the input weights have a default file name of inweights, and
the output file name has a default file name of outweights.
\
\

Weights can be used to analyze different subsets of characters (by
weighting the rest as zero). Alternatively, in the discrete characters
programs they can be used to force a certain group to appear on the
phylogeny (in effect confining consideration to only phylogenies
containing that group). This is done by adding an imaginary character
that has 1's for the members of the group, and 0's for all the other
species. That imaginary character is then given the highest weight
possible: the result will be that any phylogeny that does not contain
that group will be penalized by such a heavy amount that it will not
(except in the most unusual circumstances) be considered. Of course,
the new character brings extra steps to the tree, but the number of
these can be calculated in advance and subtracted out of the total
when reporting the results. This use of weights is an important one,
and one sadly ignored by many users who could profit from it. In the
case of molecular sequences we cannot use weights this way, so that to
force a given group to appear we have to add a large extra segment of
sites to the molecule, with (say) A's for that group and C's for every
other species."

]

infile: weightfile [
  information: "Weights file"
  standardtype: "phylip weights"
  default: "weights"
]


integer: datasets [
  information: "Number of input data sets"
  default: "1"
  minimum: "1"
  maximum: "1"
  help: "Fixed at 1 until we can read multiple sequence sets"
]

boolean: progress [
  optional: "Y"
  default: "N"
  information: "Print indications of progress of run"
  prompt: "Print indications of progress of run"
]

infile: infile [
  parameter: "Y"
  information: "input file"
  standardtype: "xxx file"
]

infile: intreefile [
  parameter: "Y"
  standardtype: "Newick tree"
]

outfile: outfile  [
  parameter: "Y"
  standardtype: "xxx file"
]

outfile: outtreefile  [
  required: "$(trout)"
  extension: "treefile"
  information: "Tree file name"
]

list: multiple [
  default: "none"
  required: "Y"
  minimum: "1"
  maximum: "1"
  information: "Multiple input option"
  values: "none:None;
           datasets:Multiple datasets;
           weights: Multiple weights"
]
