/* @source contacts application
**
** Calculate residue contacts from clean coordinate files
** @author: Copyright (C) Jon Ison (jison@hgmp.mrc.ac.uk)
** @author: Copyright (C) Alan Bleasby (ableasby@hgmp.mrc.ac.uk)
** @@
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
******************************************************************************
** 
** 
** 
** 
** 
** 
** Operation
** 
** contacts parses an embl-like clean coordinate files generated by the coorde 
** application (not currently in emboss, email Jon Ison jison@hgmp.mrc.ac.uk) 
** or the domainer application and writes, for each file in a given directory, 
** files of residue-residue contact data in embl-like format.  Each of these 
** files contains residue contact data for each chain of every model in the 
** coordinate file (or the single scop domain in the case where domainer output
** is read).  
**
** Contact between two residues is defined as when the Van der Waals surface of 
** any atom of the first residue comes within the threshold contact distance of 
** the Van der Waals surface of any atom of the second residue. The threshold 
** contact distance is a user-defined distance with a default value of 1 
** Angstrom.
** 
** The following Van der Waals radii are used: 
** C:1.8 Angstrom 
** O:1.4 Angstrom 
** N:1.7 Angstrom 
** S:2.0 Angstrom
** H:1.0 Angstrom (default for other or unknown atom types)
**
** The embl-like format used for the contact files (Figure 1) uses the following 
** records:
** (1)  ID - either the 4-character PDB identifier code (where clean protein 
** coordinate files are used as input) or the 7-character domain identifier 
** code taken from scop (where domain coordinate files were used as input; see 
** documentation for the EMBOSS application scope for further info.)
** (2)  DE - bibliographic information.  The text "Residue-residue contact 
** data" is always given.
** (4)  EX - experimental information. The value of the threshold contact 
** distance is given as a floating point number after 'THRESH'. The number of 
** models and number of polypeptide chains are given after 'NMOD' and 'NCHA' 
** respectively. domain coordinate files a 1 is always given. Following the EX 
** record, the file will have a section containing a CN, IN and SM records 
** (see below) for each chain. The sections for each chain of a model are given 
** after the MO record.
** (5) MO - model number. The number given in brackets after this record 
** indicates the start of a section of model-specific data. 
** (6) CN - chain number.  The number given in brackets after this record 
** indicates the start of a section of chain-specific data.
** (7) IN - chain specific data. The character given after ID is the PDB chain 
** identifier taken from the input file, (a '.` given in cases where a chain 
** identifier was not specified in the original pdb file or, for domain 
** coordinate files, the domain is comprised of more than one domain).  The 
** number of amino acid residues comprising the chain (or the chains from 
** which a domain is comprised) is given after NR. The number of residue-residue
** contacts is given after NSMCON. 
** (8) SM - Line of residue contact data. Pairs of amino acid identifiers and 
** residue numbers are delimited by a ';'. Residue numbers are taken from the 
** clean coordinate file and give a correct index into the sequence (i.e. they
** are not necessarily the same as the original pdb file).
** (9) XX - used for spacing.
** (10) // - given on the last line of the file only.
** 
** Note - SM records are used for contacts between either either side-chain 
** or main-chain atoms as defined above.  In a future implementation, SS will
** be used for side-chain only contacts, MM will be used for main-chain only 
** contacts, and there will probably be several other forms of contact too.
** 
** domainer generates a log file an excerpt of which is shown (Figure 2). If 
** there is a problem in processing a coordinate file, three lines containing 
** the record '//', the scop domain or pdb identifier code and an error message 
** respectively are written. The text 'WARN  file open error filename',
** 'ERROR file read error filename' or 'ERROR file write error filename ' will 
** be reported when an error was encountered during a file open, read or write 
** respectively.  Various other error messages may also be given (in case of 
** difficulty email Jon Ison, jison@hgmp.mrc.ac.uk).
**
** Figure 1 Excerpt from contacts output file
**  ID   D1HBBB_
**  XX
**  DE   Residue-residue side-chain contact data
**  XX
**  EX   THRESH 10.0; NMOD 1; NCHA 1;
**  XX
**  MO   [1]
**  XX
**  CN   [1]
**  XX
**  IN   ID B; NR 146; NSMCON 2514;
**  XX
**  SM   VAL 1 ; HIS 2
**  SM   VAL 1 ; LEU 3
**  SM   VAL 1 ; THR 4
**  SM   VAL 1 ; PRO 5
**  SM   VAL 1 ; GLU 6
**  SM   VAL 1 ; GLU 7
**  SM   VAL 1 ; LYS 8
**  SM   VAL 1 ; VAL 11
**  SM   VAL 1 ; PHE 71
**
** Figure 2 Excerpt of log file
** //
** DS002__
** WARN  Could not open for reading cpdb file s002.pxyz
** //
** DS003__
** WARN  Could not open for reading cpdb file s003.pxyz
**
** Notes
** Should give an example of the output file here.
**
** Change two acd paths to \
******************************************************************************/






#include "emboss.h"
#include "math.h"

AjBool	ajXyzContactsWrite(AjPFile logf, AjPFile outf, float thresh, AjPPdb pdb);
AjBool	ajXyzPrintContactMap(AjPFile outf, AjPInt2d mat, char *txt, ajint mod, ajint chn, AjPPdb pdb);
AjBool	ajXyzWriteContactMap(AjPInt2d *mat, ajint *ncon, ajint dim, float thresh, ajint mod, ajint chn, AjPPdb pdb);
AjBool  ajXyzInContact(AjPAtom atm1, AjPAtom atm2, float thresh);









int main(ajint argc, char **argv)
{
    AjPStr   cpdb_path     =NULL;	/* Path of cpdb files */
    AjPStr   cpdb_extn     =NULL;	/* Extn. of cpdb files */
    AjPStr   cpdb_name     =NULL;	/* Name of cpdb file */
    AjPStr   con_path      =NULL;	/* Path of contact files */
    AjPStr   con_extn      =NULL;	/* Extn. of contact files */
    AjPStr   con_name 	   =NULL;	/* Name of contact file */
    AjPStr   msg           =NULL;	/* Error message */
    AjPStr   temp          =NULL;	/* Temp string */

    AjPFile  cpdb_inf      =NULL;       /* cpdb input file pointer */
    AjPFile  con_outf      =NULL;       /* contact output file pointer */
    AjPFile  logf          =NULL;       /* log file pointer*/

    AjPPdb   pdb           =NULL;

    AjPList  list          =NULL;       

    float    thresh        =0;
    



    
    /* Initialise strings */
    temp          = ajStrNew();
    msg           = ajStrNew();
    cpdb_path     = ajStrNew();
    cpdb_extn     = ajStrNew();
    cpdb_name     = ajStrNew();
    con_path      = ajStrNew();
    con_extn      = ajStrNew();
    con_name      = ajStrNew();


    /* Read data from acd */
    embInit("contacts",argc,argv); 
    cpdb_path     = ajAcdGetString("cpdb");
    cpdb_extn     = ajAcdGetString("cpdbextn");
    con_path      = ajAcdGetString("con");
    con_extn      = ajAcdGetString("conextn");
    logf          = ajAcdGetOutfile("conerrf");
    thresh        = ajAcdGetFloat("thresh");

    /* Check directories*/
    if(!ajFileDir(&cpdb_path))
	ajFatal("Could not open cpdb directory");

    if(!ajFileDir(&con_path))
	ajFatal("Could not open contact directory");


    /* Create list of files in cpdb directory */
    list = ajListNew();
    ajStrAssC(&temp, "*");	
    if((ajStrChar(cpdb_extn, 0)=='.'))
	ajStrApp(&temp, cpdb_extn);    
    else
    {
	ajStrAppC(&temp, ".");    
	ajStrApp(&temp, cpdb_extn);    
    }
    ajFileScan(cpdb_path, temp, &list, ajFalse, ajFalse, NULL, NULL, ajFalse, NULL); 





    /*Start of main application loop*/
    while(ajListPop(list,(void **)&temp))
    {
	/* Read clean coordinate file*/
	if((cpdb_inf=ajFileNewIn(temp))==NULL)
	{
	    ajFmtPrintS(&msg, "Could not open for reading %S %S", 
			temp);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(logf, "WARN  Could not open for reading %S\n", 
			temp);
	    ajFileClose(&cpdb_inf);
	    ajStrDel(&temp);	
	    continue;	    
	}


	/* Read pdb structure */
	if(!ajXyzCpdbRead(cpdb_inf, &pdb))	       
	{
	    ajFmtPrintS(&msg, "ERROR file read error %S", temp);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(logf, "ERROR  file read error %S\n", temp);
	    ajFileClose(&cpdb_inf);
	    ajXyzPdbDel(&pdb);
	    ajStrDel(&temp);	
	    continue;
	}


	/* Open contact file for writing*/
	ajStrAss(&con_name, con_path);
	ajStrApp(&con_name, pdb->Pdb);
	ajStrToLower(&con_name);
	ajStrAppC(&con_name, ajStrStr(con_extn));
	if(!(con_outf=ajFileNewOut(con_name)))
	{
	    ajFmtPrintS(&msg, "ERROR file open error %S", 
			con_name);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(logf, "ERROR file open error %S\n", con_name);
	    ajFileClose(&cpdb_inf);
	    ajFileClose(&con_outf);
	    ajXyzPdbDel(&pdb);
	    ajStrDel(&temp);	
	    continue;
	}  

	
	/* Write contacts file */
	if(!ajXyzContactsWrite(logf, con_outf, thresh, pdb))
	{
	    ajFmtPrintS(&msg, "ERROR  file write error %S", con_name);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(logf, "ERROR  file write error %S\n", con_name);

	    ajFmtPrintS(&temp, "rm %S", con_name);
	    ajFmtPrint("%S", temp);
	    ajSystem(&temp);

	    ajFileClose(&cpdb_inf);
	    ajFileClose(&con_outf);
	    ajXyzPdbDel(&pdb);
	    ajStrDel(&temp);	
	    continue;
	}


	/* Write diagnostic */
	ajFmtPrint("%S\n", pdb->Pdb);   
	ajFmtPrintF(logf, "%S\n", pdb->Pdb);   
	

	/* Tidy up*/
	ajFileClose(&cpdb_inf);
	ajFileClose(&con_outf);
	ajXyzPdbDel(&pdb);
	ajStrDel(&temp);	
    }
    /*End of main application loop*/    
    




    /*Tidy up */
    ajStrDel(&cpdb_path);
    ajStrDel(&cpdb_extn);
    ajStrDel(&cpdb_name);

    ajStrDel(&con_path);
    ajStrDel(&con_extn);
    ajStrDel(&con_name);

    ajStrDel(&msg);
    ajStrDel(&temp);

    ajFileClose(&cpdb_inf);
    ajFileClose(&con_outf);
    ajFileClose(&logf);

    ajListDel(&list);


    /* Bye Bye */
    ajExit();
    return 0;
}	





/* @func ajXyzContactsWrite **************************************************
**
** Writes a file of residue contact data in embl-like format for a pdb 
** structure.
**
** @param [w] logf   [AjPFile] Output file stream (log file)
** @param [w] outf   [AjPFile] Output file stream (contact file)
** @param [r] thresh [float]   Threshold contact distance
** @param [r] pdb    [AjPPdb]  Pdb object
**
** @return [AjBool] True on success
** @@
**
******************************************************************************/

AjBool	ajXyzContactsWrite(AjPFile logf, AjPFile outf, float thresh, AjPPdb pdb)
{
    AjPInt2d    mat   =NULL;    /* Contact map */
    ajint       x,y,z;          /* Loop counters */
    ajint       ncon  =0;       /* No. contacts (1's) in matrix */
    

    /* Error checking on args */
    if(!logf || !outf || !pdb)
	return ajFalse;
    
    
    /* Print out header data */
    ajFmtPrintF(outf, "%-5s%S\n", "ID", pdb->Pdb);
    ajFmtPrintF(outf, "XX\n");
    ajFmtPrintF(outf, "%-5s%s\n", "DE", "Residue-residue side-chain contact data");
    ajFmtPrintF(outf, "XX\n");
    ajFmtPrintF(outf, "%-5s%s%.1f; NMOD %d; NCHA %d;\n", "EX", "THRESH ", thresh, pdb->Nmod, pdb->Nchn);


    /* Start of loop to print out data for each model / chain */
    for(x=0;x<pdb->Nmod;x++)
    {
	/* Print out model-specific data */
	ajFmtPrintF(outf, "XX\n%-5s[%d]\n", "MO", x+1);	
	ajFmtPrintF(outf, "XX\n");	


	for(y=0;y<pdb->Nchn;y++)
	{
	    /* Allocate memory for the contact map (a SQUARE 2d int array) */
	    mat = ajInt2dNewL((ajint)pdb->Chains[y]->Nres);   	
	    for(z=0;z<pdb->Chains[y]->Nres;++z)
		ajInt2dPut(&mat, z, pdb->Chains[y]->Nres-1, (ajint) 0);


	    if(!ajXyzWriteContactMap(&mat, &ncon, pdb->Chains[y]->Nres, thresh, x+1, y+1, pdb))
	    {
		ajFmtPrintF(logf, "ERROR  Writing contact map\n");
		ajInt2dDel(&mat);
		return ajFalse;
	    }


	    /* Print out chain-specific data */
	    ajFmtPrintF(outf, "%-5s[%d]\n", "CN", y+1);	
	    ajFmtPrintF(outf, "XX\n");	
	    ajFmtPrintF(outf, "%-5sID %c; NR %d; NSMCON %d;\n", 
			"IN", 
 			pdb->Chains[y]->Id,
			pdb->Chains[y]->Nres,
			ncon);
	    ajFmtPrintF(outf, "XX\n");	


	    if(ncon)
	    {
		/*Matrix written OK and has at least 1 contact*/
		ajXyzPrintContactMap(outf, mat, "SM", x+1, y+1, pdb);   
		ajFmtPrintF(outf, "XX\n");	
	    }
	    else 
	    {
		/* Empty matrix ! */
		ajFmtPrintF(outf, ".\nXX\n");	
	    }


	    /* Free memory for matrix */
	    ajInt2dDel(&mat);
	}
    }
    /* End of loop to print out data for each model / chain */


    ajFmtPrintF(outf, "//\n");    



    /* Return */
    return ajTrue;
}





/* @func ajXyzPrintContactMap **************************************************
**
** Writes data in a contact map to file for a certain model and chain in a pdb 
** structure.
**
** @param [w] outf [AjPFile]     Output file stream (contact file)
** @param [r] mat  [AjPInt2d]    Contact map
** @param [r] txt  [char]        Text to print at start of each line
** @param [r] mod  [ajint]         Model number
** @param [r] chn  [ajint]         Chain number
** @param [r] pdb  [AjPPdb]      Pdb object
** 
** It writes a line to the output file for each contact. In the example below, 
** txt has a value of "SM":
** 
** SM   His 2 ; Val 8
** SM   Ala 6 ; Trp 21
** 
** @return [AjBool] True if file was succesfully written.
** @@
**
******************************************************************************/
AjBool	ajXyzPrintContactMap(AjPFile outf, AjPInt2d mat, char *txt, int mod, int chn, AjPPdb pdb)
{
    ajint      x,y;           /* Loop counters */    
    ajint      done1=0;       /* Flag */
    ajint      done2=0;       /* Flag */
    AjPStr   res1;          /* ID of residue 1 */
    AjPStr   res2;          /* ID of residue 2 */
    AjIList  iter=NULL;     /* Iterator for list of atoms */
    AjPAtom  atm=NULL;      /* Atom structure */


    /* Error checking on args */
    if(!outf || !mat || !pdb || !txt)
	{
	    ajWarn("Null arg. passed to ajXyzPrintContactMap");		
	    return ajFalse;
	}
    

    /* Allocate strings */
    res1 = ajStrNew();
    res2 = ajStrNew();


    /* Start of loop for printing out contacts */
    for(x=0; x<pdb->Chains[chn-1]->Nres; x++)
	for(y=x+1; y<pdb->Chains[chn-1]->Nres; y++)
	{
	    if((ajInt2dGet(mat, x, y)==1))
	    {
		/* If the residue type from the sequence is unkown - 
		   there may be missing electron density or it may be 
		   an unusual amino acid - so check the list of atoms */

		
		if((ajStrChar(pdb->Chains[chn-1]->Seq, x)=='X'))
		    done1=0;
		else
		    done1=1;
		if((ajStrChar(pdb->Chains[chn-1]->Seq, y)=='X'))
		    done2=0;
		else
		    done2=1;

		if((!done1)||(!done2))
		{
		    /* Free list iterator */
		    ajListIterFree(iter);	


		    /* Intitialise iterator for list of atoms*/
		    iter=ajListIter(pdb->Chains[chn-1]->Atoms);	


		    /* Iterate through list of atoms*/
		    while((atm=(AjPAtom)ajListIterNext(iter)))
		    {
			/* Find the correct model */
			if(atm->Mod<mod)
			    continue;
			
			
			/* Break if a non-protein atom is found or in the wrong model*/
			if(atm->Type!='P' || atm->Mod>mod)
			    break;

			
			/* Assign residue id */
			if((!done1) && (atm->Idx == x+1))
			    {
				ajStrAss(&res1, atm->Id3);
				done1=1;
			    }
			
			if((!done2) && (atm->Idx == y+1))
			    {
				ajStrAss(&res2, atm->Id3);
				done2=1;
			    }
			if(done1 && done2)
			    break;
		    }		
		}


		/* Assign residue id if not already done*/
		if(!done1)
		    if(!ajBaseAa1ToAa3(ajStrChar(pdb->Chains[chn-1]->Seq, x), &res1))
		    {
			ajStrDel(&res1);
			ajStrDel(&res2);  
			ajListIterFree(iter);	
			ajWarn("Index out of range in ajXyzPrintPdbSeqresChain");		
			return ajFalse;
		    }
		if(!done2)
		    if(!ajBaseAa1ToAa3(ajStrChar(pdb->Chains[chn-1]->Seq, y), &res2))
		    {
			ajStrDel(&res1);
			ajStrDel(&res2);  
			ajListIterFree(iter);	
			ajWarn("Index out of range in ajXyzPrintPdbSeqresChain");		
			return ajFalse;
		    }
 		/* Print out the contact */
		ajFmtPrintF(outf, "%-5s%S %d ; %S %d\n", txt, res1, x+1, res2, y+1);	
	    }
	}

    
    /*Tidy up */
    ajStrDel(&res1);
    ajStrDel(&res2);  
    ajListIterFree(iter);	


    /* Return */
    return ajTrue;
}	





/* @func ajXyzWriteContactMap *************************************************
**
** Writes a residue contact map for a specified model and chain in a pdb 
** structure.  
**
** @param [w] mat    [AjPInt2d *]  Contact map
** @param [w] ncon   [ajint *]       No. contacts (1's) in contact map
** @param [w] dim    [ajint]        Dimension of the contact map 
** @param [r] thresh [float]       Threshold contact distance
** @param [r] mod    [ajint]         Model number
** @param [r] chn    [ajint]         Chain number
** @param [r] pdb    [AjPPdb]      Pdb object
**
** Contact between two residues is defined as when the Van der Waals surface of 
** any atom of the first residue comes within the threshold contact distance
** (thresh) of the Van der Waals surface of any atom of the second residue. 
**
** @return [AjBool] True if mat was succesfully written.
** @@
**
******************************************************************************/
AjBool	ajXyzWriteContactMap(AjPInt2d *mat, ajint *ncon, ajint dim, float thresh, ajint mod, ajint chn, AjPPdb pdb)
{
    AjPAtom   *arr;              /* Array of AjPAtom from pdb list */
    ajint      siz;            /* Size of array */
    ajint      x,y;            /* Loop counters */
   
    

    /* Error checking on args */
    if(!mat || !pdb || !chn || !mod)
    {	
	ajWarn("Null or zero arg. passed to ajXyzWriteContactMap");		
	return ajFalse;
    }
    
    

    /* Initialise no. contacts to zero */
    (*ncon)=0;
    

    /*Convert the AjPList of atoms to an array of AjPAtom*/
    if(!(siz=ajListToArray((AjPList)pdb->Chains[chn-1]->Atoms,(void ***)&arr)))
    {
	ajWarn("Zero sized list of sequences passed into ajXyzWriteContactMap");
	return ajFalse;
    }
    

    /* r1 is counter for 1st residue 
       r2 is counter for 2nd residue 
       a1 is counter for atom from 1st residue 
       a2 is counter for atom from 2nd residue 
       last_atm is the index of the last atom to consider
       */


    /* Advance both atom counters to the correct model */
/*    for(a1=0; a1<siz; a1++) */
	/* Find the correct model */
/*	if(arr[a1]->Mod!=mod)
	    continue;
	else
	{
	    a2=a1;
	    done=1;
	    break;
	}
    if(!done)
    {
	ajWarn("Zero sized list of sequences passed into ajXyzWriteContactMap");
	AJFREE(arr);
	return ajFalse;
    } */
    
    
    /* Find index for last atom */
/*    for(last_atm=a1; last_atm<siz; last_atm++)
	if(arr[last_atm]->Mod!=mod  || arr[last_atm]->Type!='P')
	{
	    last_atm--;
	    break;	
	}
    if(last_atm==siz)
	last_atm--;
    if(last_atm == a1)
    {
	ajWarn("No atoms for the chain in ajXyzWriteContactMap");
	AJFREE(arr);
	return ajFalse;
    } */
    
    
    /* Loop for 1st residue */ 
/*    for(r1=0; r1<pdb->Chains[chn-1]->Nres; r1++)
    { */
	/* Loop for 2nd residue */
/*	for(r2=r1+1; r2<pdb->Chains[chn-1]->Nres; r2++)
	{
	    for( ; (a1<=last_atm) && (arr[a1]->Idx-1==r1); a1++)
	    {
		
	    }	
	

	}
    } */
    




    
    /* Atom 1 counter - Iterate through the list of atoms */
    for(x=0; x<siz; x++)
    {
	/* Find the correct model */
	if(arr[x]->Mod<mod)
	    continue;

	
	/* Break if the atom is non-protein or in the wrong model */
	if(arr[x]->Mod>mod  || arr[x]->Type!='P')
	    break;


	/* Atom 2 counter - Iterate through the list of atoms */
	for(y=x; y<siz; y++)
	{
	    /* Break if the atom is non-protein or in the wrong model */
	    if(arr[y]->Mod>mod  || arr[y]->Type!='P')
		break;


	    /* Jump to next residue if necessary */
	    if(arr[y]->Idx <= arr[x]->Idx)
		continue;


	    /* Check we do not already have a contact for this pair of residues 
	       First check to see whether index is in range (it should be!)*/
	    if((arr[x]->Idx-1 < dim) && (arr[y]->Idx-1 < dim))
	    {
		if((ajInt2dGet(*mat, arr[x]->Idx-1, arr[y]->Idx-1)==1))
		    continue;   
	    }
	    else
	    {
		/* The residue number should never exceed dim (no. residues in the chain) */
		ajFatal("Unexpected fatal error.  email culprit (jison@hgmp.mrc.ac.uk)");
	    }
	    
	    
	    
	    /* Determines whether the two atoms make contact */
	    if(ajXyzInContact(arr[x], arr[y], thresh))
	    {
		if((ajInt2dGet(*mat, arr[x]->Idx-1, arr[y]->Idx-1)==0))
		{
		    /* Increment no. contacts and write contact map */
		    (*ncon)++;
		    ajInt2dPut(mat, arr[x]->Idx-1, arr[y]->Idx-1, (ajint) 1);
		    ajInt2dPut(mat, arr[y]->Idx-1, arr[x]->Idx-1, (ajint) 1); 
		}
	    }
	}
    }


    /* Tidy up */
    AJFREE(arr);
    

    /* Return */
    return ajTrue;
}









/* @func ajXyzInContact *****************************************************
**
** Determines whether two atoms are in physical contact  
**
** @param [r] atm1   [AjPAtom]     Atom 1 object
** @param [r] atm2   [AjPAtom]     Atom 1 object
** @param [r] thresh [float]       Threshold contact distance
**
** Contact between two atoms is defined as when the Van der Waals surface of 
** the first atom comes within the threshold contact distance (thresh) of the 
** van der Waals surface of the second atom.
**
** @return [AjBool] True if the two atoms form contact
** @@
**
******************************************************************************/
AjBool  ajXyzInContact(AjPAtom atm1, AjPAtom atm2, float thresh)
{
    float val=0;

    
    val=((atm1->X -  atm2->X) * (atm1->X -  atm2->X)) +
	((atm1->Y -  atm2->Y) * (atm1->Y -  atm2->Y)) +
	((atm1->Z -  atm2->Z) * (atm1->Z -  atm2->Z));


/*     printf("thresh: %.1f   dis: %.1f\n", thresh, sqrt(val)); */
    
    
    if(sqrt(val) <= thresh)
	return ajTrue;
    else
	return ajFalse;
} 




